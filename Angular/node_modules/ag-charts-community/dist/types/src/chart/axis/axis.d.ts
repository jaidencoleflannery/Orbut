import type { AgAxisBoundSeries, CssColor, FontFamily, FontSize, FontStyle, FontWeight } from 'ag-charts-types';
import type { AxisContext } from '../../module/axisContext';
import type { ModuleInstance } from '../../module/baseModule';
import type { ModuleContext, ModuleContextWithParent } from '../../module/moduleContext';
import { ModuleMap } from '../../module/moduleMap';
import type { AxisOptionModule } from '../../module/optionsModule';
import type { FromToDiff } from '../../motion/fromToMotion';
import type { Scale } from '../../scale/scale';
import { BBox } from '../../scene/bbox';
import { Group, TransformableGroup } from '../../scene/group';
import type { Node } from '../../scene/node';
import { Selection } from '../../scene/selection';
import { Line } from '../../scene/shape/line';
import { TransformableText } from '../../scene/shape/text';
import type { ChartAnimationPhase } from '../chartAnimationPhase';
import type { ChartAxis, ChartAxisLabel, ChartAxisLabelFlipFlag } from '../chartAxis';
import { ChartAxisDirection } from '../chartAxisDirection';
import type { CrossLine } from '../crossline/crossLine';
import type { AnimationManager } from '../interaction/animationManager';
import type { AxisLayout } from '../layout/layoutManager';
import type { ISeries } from '../series/seriesTypes';
import { AxisGridLine } from './axisGridLine';
import { AxisInterval } from './axisInterval';
import { AxisLine } from './axisLine';
import { AxisTick, type TickInterval } from './axisTick';
import { AxisTitle } from './axisTitle';
import type { AxisLineDatum } from './axisUtil';
type TickStrategyResult = {
    index: number;
    tickData: TickData;
    autoRotation: number;
    terminate: boolean;
};
declare enum TickGenerationType {
    CREATE = 0,
    CREATE_SECONDARY = 1,
    FILTER = 2,
    VALUES = 3
}
export type TickDatum = {
    tickLabel: string;
    tick: any;
    tickId: string;
    translationY: number;
};
export type LabelNodeDatum = {
    tickId: string;
    fill?: CssColor;
    fontFamily?: FontFamily;
    fontSize?: FontSize;
    fontStyle?: FontStyle;
    fontWeight?: FontWeight;
    rotation: number;
    rotationCenterX: number;
    text: string;
    textAlign?: CanvasTextAlign;
    textBaseline: CanvasTextBaseline;
    visible: boolean;
    x: number;
    y: number;
    translationY: number;
    range: number[];
};
type TickData = {
    rawTicks: any[];
    fractionDigits: number;
    ticks: TickDatum[];
    labelCount: number;
};
export type AxisModuleMap = ModuleMap<AxisOptionModule, ModuleInstance, ModuleContextWithParent<AxisContext>>;
declare const TranslatableLine_base: new (...args: any[]) => import("../../scene/transformable").TranslatableType<Line>;
declare class TranslatableLine extends TranslatableLine_base {
}
/**
 * A general purpose linear axis with no notion of orientation.
 * The axis is always rendered vertically, with horizontal labels positioned to the left
 * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,
 * so that it can be used as a top, right, bottom, left, radial or any other kind
 * of linear axis.
 * The generic `D` parameter is the type of the domain of the axis' scale.
 * The output range of the axis' scale is always numeric (screen coordinates).
 */
export declare abstract class Axis<S extends Scale<D, number, TickInterval<S>> = Scale<any, number, any>, D = any> implements ChartAxis {
    protected readonly moduleCtx: ModuleContext;
    readonly scale: S;
    static readonly defaultTickMinSpacing = 50;
    protected static CrossLineConstructor: new () => CrossLine<any>;
    readonly id: string;
    nice: boolean;
    /** Reverse the axis scale domain. */
    reverse: boolean;
    keys: string[];
    readonly interval: AxisInterval<unknown>;
    dataDomain: {
        domain: D[];
        clipped: boolean;
    };
    get type(): string;
    abstract get direction(): ChartAxisDirection;
    layoutConstraints: ChartAxis['layoutConstraints'];
    boundSeries: ISeries<unknown, unknown>[];
    includeInvisibleDomains: boolean;
    interactionEnabled: boolean;
    readonly axisGroup: TransformableGroup;
    protected lineNode: TranslatableLine;
    protected readonly tickLineGroup: Group;
    protected readonly tickLabelGroup: Group;
    protected readonly crossLineGroup: TransformableGroup;
    protected readonly labelGroup: Group;
    readonly gridGroup: TransformableGroup;
    protected readonly gridLineGroup: Group;
    protected tickLineGroupSelection: Selection<TranslatableLine, any>;
    protected tickLabelGroupSelection: Selection<TransformableText, LabelNodeDatum>;
    protected gridLineGroupSelection: Selection<TranslatableLine, any>;
    private _crossLines;
    set crossLines(value: CrossLine[]);
    get crossLines(): CrossLine[];
    readonly line: AxisLine;
    readonly tick: AxisTick;
    readonly gridLine: AxisGridLine;
    readonly label: ChartAxisLabel;
    protected defaultTickMinSpacing: number;
    readonly translation: {
        x: number;
        y: number;
    };
    rotation: number;
    protected readonly layout: Pick<AxisLayout, 'label'>;
    protected axisContext?: AxisContext;
    protected animationManager: AnimationManager;
    private readonly animationState;
    private readonly destroyFns;
    constructor(moduleCtx: ModuleContext, scale: S);
    resetAnimation(phase: ChartAnimationPhase): void;
    private attachCrossLine;
    private detachCrossLine;
    destroy(): void;
    protected updateRange(): void;
    setCrossLinesVisible(visible: boolean): void;
    attachAxis(axisNode: Node, gridNode: Node): void;
    attachLabel(axisLabelNode: Node): void;
    detachAxis(axisNode: Node, gridNode: Node): void;
    range: [number, number];
    visibleRange: [number, number];
    /**
     * Checks if a point or an object is in range.
     * @param x A point (or object's starting point).
     * @param tolerance Expands the range on both ends by this amount.
     */
    inRange(x: number, tolerance?: number): boolean;
    protected datumFormatter?: (datum: any) => string;
    protected labelFormatter?: (datum: any) => string;
    protected onFormatChange(ticks: any[], fractionDigits: number, _domain: any[], format?: string): void;
    readonly title: AxisTitle;
    /**
     * The length of the grid. The grid is only visible in case of a non-zero value.
     */
    gridLength: number;
    /**
     * The distance between the grid ticks and the axis ticks.
     */
    gridPadding: number;
    /**
     * Is used to avoid collisions between axis labels and series.
     */
    seriesAreaPadding: number;
    protected onGridLengthChange(value: number, prevValue: number): void;
    protected onGridVisibilityChange(): void;
    protected createLabel(): ChartAxisLabel;
    /**
     * Creates/removes/updates the scene graph nodes that constitute the axis.
     */
    update(animated?: boolean): number | undefined;
    private getAxisLineCoordinates;
    private getTickLineCoordinates;
    private getTickLabelProps;
    protected getTickSize(): number;
    private setTitleProps;
    private tickGenerationResult;
    calculateLayout(domain?: any[], primaryTickCount?: number): {
        primaryTickCount: number | undefined;
        bbox: BBox;
    };
    private updateLayoutState;
    protected getTransformBox(bbox: BBox): BBox;
    setDomain(domain: D[]): void;
    updateScale(domain?: any[]): void;
    private calculateRotations;
    private generateTicks;
    private getTickStrategies;
    createTickData(tickGenerationType: TickGenerationType, index: number, tickData: TickData, terminate: boolean, primaryTickCount?: number): TickStrategyResult;
    private createLabelData;
    private getAutoRotation;
    private getTicks;
    private filterTicks;
    private createTicks;
    protected estimateTickCount({ minSpacing, maxSpacing }: {
        minSpacing: number;
        maxSpacing: number;
    }): {
        minTickCount: number;
        maxTickCount: number;
        defaultTickCount: number;
    };
    private updateVisibility;
    protected updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation, }: {
        rotation: number;
        parallelFlipRotation: number;
        regularFlipRotation: number;
    }): void;
    protected updateTickLines(): void;
    protected calculateAvailableRange(): number;
    /**
     * Calculates the available range with an additional "bleed" beyond the canvas that encompasses the full axis when
     * the visible range is only a portion of the axis.
     */
    protected calculateRangeWithBleed(): number;
    protected calculateDomain(): void;
    protected getAxisTransform(): {
        rotation: number;
        translationX: number;
        translationY: number;
    };
    updatePosition(): void;
    updateSecondaryAxisTicks(_primaryTickCount: number | undefined): any[];
    protected updateSelections(lineData: AxisLineDatum, data: TickDatum[], params: {
        combinedRotation: number;
        textBaseline: CanvasTextBaseline;
        textAlign: CanvasTextAlign;
        range: number[];
    }): void;
    private updateAxisLine;
    protected updateGridLines(sideFlag: ChartAxisLabelFlipFlag): void;
    protected updateLabels(): void;
    protected updateTitle(params: {
        anyTickVisible: boolean;
    }): void;
    formatTick(datum: any, fractionDigits: number, index: number): string;
    formatDatum(datum: any): string;
    getFormatter(index?: number, isTickLabel?: boolean): (datum: any, fractionDigits?: number) => string;
    getBBox(): BBox;
    getRegionNode(): Node | undefined;
    initCrossLine(crossLine: CrossLine): void;
    isAnySeriesActive(): boolean;
    clipTickLines(x: number, y: number, width: number, height: number): void;
    clipGrid(x: number, y: number, width: number, height: number): void;
    protected getTitleFormatterParams(): {
        direction: ChartAxisDirection;
        boundSeries: AgAxisBoundSeries[];
        defaultValue: string | undefined;
    };
    normaliseDataDomain(d: D[]): {
        domain: D[];
        clipped: boolean;
    };
    getLayoutState(): AxisLayout;
    private readonly moduleMap;
    getModuleMap(): AxisModuleMap;
    createModuleContext(): ModuleContextWithParent<AxisContext>;
    createAxisContext(): AxisContext;
    private getScaleValueFormatter;
    animateReadyUpdate(diff: FromToDiff): void;
    protected resetSelectionNodes(): void;
    private calculateUpdateDiff;
    isReversed(): boolean;
}
export {};
