"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// packages/ag-charts-community/src/main-modules.ts
var main_modules_exports = {};
__export(main_modules_exports, {
  AgCharts: () => AgCharts,
  setupCommunityModules: () => setupCommunityModules
});
module.exports = __toCommonJS(main_modules_exports);

// packages/ag-charts-community/src/util/id.ts
var ID_MAP = /* @__PURE__ */ new Map();
function createId(instance) {
  const constructor = instance.constructor;
  const className = Object.hasOwn(constructor, "className") ? constructor.className : constructor.name;
  if (!className) {
    throw new Error(`The ${constructor} is missing the 'className' property.`);
  }
  const nextId = (ID_MAP.get(className) ?? 0) + 1;
  ID_MAP.set(className, nextId);
  return `${className}-${nextId}`;
}

// packages/ag-charts-community/src/util/iterator.ts
function* iterate(...iterators) {
  for (const iterator of iterators) {
    yield* iterator;
  }
}
function toIterable(value) {
  return value != null && typeof value === "object" && Symbol.iterator in value ? value : [value];
}

// packages/ag-charts-community/src/util/interpolating.ts
var interpolate = Symbol("interpolate");
var isInterpolating = (x) => x[interpolate] != null;

// packages/ag-charts-community/src/util/nearest.ts
function nearestSquared(x, y, objects, maxDistanceSquared = Infinity) {
  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };
  for (const obj of objects) {
    const thisDistance = obj.distanceSquared(x, y);
    if (thisDistance === 0) {
      return { nearest: obj, distanceSquared: 0 };
    } else if (thisDistance < result.distanceSquared) {
      result.nearest = obj;
      result.distanceSquared = thisDistance;
    }
  }
  return result;
}

// packages/ag-charts-community/src/util/dom.ts
var verifiedGlobals = {};
if (typeof window !== "undefined") {
  verifiedGlobals.window = window;
} else if (typeof global !== "undefined") {
  verifiedGlobals.window = global.window;
}
if (typeof document !== "undefined") {
  verifiedGlobals.document = document;
} else if (typeof global !== "undefined") {
  verifiedGlobals.document = global.document;
}
function getDocument(propertyName) {
  return propertyName ? verifiedGlobals.document?.[propertyName] : verifiedGlobals.document;
}
function getWindow(propertyName) {
  return propertyName ? verifiedGlobals.window?.[propertyName] : verifiedGlobals.window;
}
function createElement(tagName, className, style) {
  const element2 = getDocument().createElement(tagName);
  if (typeof className === "object") {
    style = className;
    className = void 0;
  }
  if (className) {
    for (const name of className.split(" ")) {
      element2.classList.add(name);
    }
  }
  if (style) {
    Object.assign(element2.style, style);
  }
  return element2;
}
function createElementNS(namespaceURI, qualifiedName) {
  return getDocument().createElementNS(namespaceURI, qualifiedName);
}
function downloadUrl(dataUrl, fileName) {
  const { body } = getDocument();
  const element2 = createElement("a", { display: "none" });
  element2.href = dataUrl;
  element2.download = fileName;
  body.appendChild(element2);
  element2.click();
  setTimeout(() => body.removeChild(element2));
}
function setDocument(document2) {
  verifiedGlobals.document = document2;
}
function setWindow(window2) {
  verifiedGlobals.window = window2;
}
function setElementBBox(element2, bbox) {
  if (element2) {
    element2.style.width = `${bbox.width}px`;
    element2.style.height = `${bbox.height}px`;
    element2.style.left = `${bbox.x}px`;
    element2.style.top = `${bbox.y}px`;
  }
}

// packages/ag-charts-community/src/util/number.ts
function clamp(min, value, max) {
  return Math.min(max, Math.max(min, value));
}
function clampArray(value, array2) {
  const [min, max] = findMinMax(array2);
  return clamp(min, value, max);
}
function findMinMax(array2) {
  if (array2.length === 0)
    return [];
  const result = [Infinity, -Infinity];
  for (const val of array2) {
    if (val < result[0])
      result[0] = val;
    if (val > result[1])
      result[1] = val;
  }
  return result;
}
function findRangeExtent(array2) {
  const [min, max] = findMinMax(array2);
  return max - min;
}
function isNegative(value) {
  return Math.sign(value) === -1 || Object.is(value, -0);
}
function round(value, decimals = 2) {
  const base = 10 ** decimals;
  return Math.round(value * base) / base;
}
function toFixed(value, fractionOrSignificantDigits = 2) {
  const power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);
  if (power >= 0 || !isFinite(power)) {
    return value.toFixed(fractionOrSignificantDigits);
  }
  return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits);
}
function mod(n, m) {
  return Math.floor(n % m + (n < 0 ? m : 0));
}
function countFractionDigits(value) {
  if (Math.floor(value) === value)
    return 0;
  let valueString = String(value);
  let exponent = 0;
  if (value < 1e-6 || value >= 1e21) {
    let exponentString;
    [valueString, exponentString] = valueString.split("e");
    if (exponentString != null) {
      exponent = Number(exponentString);
    }
  }
  const decimalPlaces2 = valueString.split(".")[1]?.length ?? 0;
  return Math.max(decimalPlaces2 - exponent, 0);
}
function formatNormalizedPercentage(ratio2, locale) {
  locale = locale ?? getWindow("navigator").language;
  return new Intl.NumberFormat(locale, {
    style: "percent",
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(ratio2);
}
function formatPercentage(percent, locale) {
  return formatNormalizedPercentage(percent / 100, locale);
}

// packages/ag-charts-community/src/scene/bbox.ts
var _BBox = class _BBox {
  constructor(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  static fromDOMRect({ x, y, width, height }) {
    return new _BBox(x, y, width, height);
  }
  toDOMRect() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height,
      top: this.y,
      left: this.x,
      right: this.x + this.width,
      bottom: this.y + this.height,
      toJSON() {
        return {};
      }
    };
  }
  clone() {
    const { x, y, width, height } = this;
    return new _BBox(x, y, width, height);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
  }
  containsPoint(x, y) {
    return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;
  }
  intersection(other) {
    if (!this.collidesBBox(other))
      return;
    const newX1 = clamp(other.x, this.x, other.x + other.width);
    const newY1 = clamp(other.y, this.y, other.y + other.height);
    const newX2 = clamp(other.x, this.x + this.width, other.x + other.width);
    const newY2 = clamp(other.y, this.y + this.height, other.y + other.height);
    return new _BBox(newX1, newY1, newX2 - newX1, newY2 - newY1);
  }
  collidesBBox(other) {
    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;
  }
  computeCenter() {
    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
  }
  isFinite() {
    return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.width) && Number.isFinite(this.height);
  }
  distanceSquared(x, y) {
    if (this.containsPoint(x, y)) {
      return 0;
    }
    const dx = x - clamp(this.x, x, this.x + this.width);
    const dy = y - clamp(this.y, y, this.y + this.height);
    return dx * dx + dy * dy;
  }
  static nearestBox(x, y, boxes) {
    return nearestSquared(x, y, boxes);
  }
  clip(clipRect) {
    if (clipRect === void 0)
      return this;
    const x1 = Math.max(this.x, clipRect.x);
    const y1 = Math.max(this.y, clipRect.y);
    const x2 = Math.min(this.x + this.width, clipRect.x + clipRect.width);
    const y2 = Math.min(this.y + this.height, clipRect.y + clipRect.height);
    this.x = x1;
    this.y = y1;
    this.width = Math.max(0, x2 - x1);
    this.height = Math.max(0, y2 - y1);
    return this;
  }
  shrink(amount, position) {
    const apply2 = (pos, amt) => {
      switch (pos) {
        case "top":
          this.y += amt;
        case "bottom":
          this.height -= amt;
          break;
        case "left":
          this.x += amt;
        case "right":
          this.width -= amt;
          break;
        case "vertical":
          this.y += amt;
          this.height -= amt * 2;
          break;
        case "horizontal":
          this.x += amt;
          this.width -= amt * 2;
          break;
        case void 0:
          this.x += amt;
          this.width -= amt * 2;
          this.y += amt;
          this.height -= amt * 2;
          break;
        default:
      }
    };
    if (typeof amount === "number") {
      apply2(position, amount);
    } else if (typeof amount === "object") {
      Object.entries(amount).forEach(([pos, amt]) => apply2(pos, amt));
    }
    return this;
  }
  grow(amount, position) {
    if (typeof amount === "number") {
      this.shrink(-amount, position);
    } else {
      const paddingCopy = { ...amount };
      for (const key in paddingCopy) {
        paddingCopy[key] *= -1;
      }
      this.shrink(paddingCopy);
    }
    return this;
  }
  translate(x, y) {
    this.x += x;
    this.y += y;
    return this;
  }
  combine(other) {
    const { x, y, width, height } = this;
    this.x = Math.min(x, other.x);
    this.y = Math.min(y, other.y);
    this.width = Math.max(x + width, other.x + other.width) - this.x;
    this.height = Math.max(y + height, other.y + other.height) - this.y;
  }
  static merge(boxes) {
    let left = Infinity;
    let top = Infinity;
    let right = -Infinity;
    let bottom = -Infinity;
    for (const box of boxes) {
      if (box.x < left) {
        left = box.x;
      }
      if (box.y < top) {
        top = box.y;
      }
      if (box.x + box.width > right) {
        right = box.x + box.width;
      }
      if (box.y + box.height > bottom) {
        bottom = box.y + box.height;
      }
    }
    return new _BBox(left, top, right - left, bottom - top);
  }
  [interpolate](other, d) {
    return new _BBox(
      this.x * (1 - d) + other.x * d,
      this.y * (1 - d) + other.y * d,
      this.width * (1 - d) + other.width * d,
      this.height * (1 - d) + other.height * d
    );
  }
};
_BBox.zero = Object.freeze(new _BBox(0, 0, 0, 0));
_BBox.NaN = Object.freeze(new _BBox(NaN, NaN, NaN, NaN));
var BBox = _BBox;

// packages/ag-charts-community/src/scene/changeDetectable.ts
var RedrawType = /* @__PURE__ */ ((RedrawType2) => {
  RedrawType2[RedrawType2["NONE"] = 0] = "NONE";
  RedrawType2[RedrawType2["TRIVIAL"] = 1] = "TRIVIAL";
  RedrawType2[RedrawType2["MINOR"] = 2] = "MINOR";
  RedrawType2[RedrawType2["MAJOR"] = 3] = "MAJOR";
  return RedrawType2;
})(RedrawType || {});
function SceneChangeDetection(opts) {
  return function(target, key) {
    const privateKey = `__${key}`;
    if (target[key]) {
      return;
    }
    prepareGetSet(target, key, privateKey, opts);
  };
}
function prepareGetSet(target, key, privateKey, opts) {
  const {
    redraw = 1 /* TRIVIAL */,
    type = "normal",
    changeCb,
    convertor,
    checkDirtyOnAssignment = false
  } = opts ?? {};
  const requiredOpts = { redraw, type, changeCb, checkDirtyOnAssignment, convertor };
  let setter;
  switch (type) {
    case "normal":
      setter = buildNormalSetter(privateKey, requiredOpts);
      break;
    case "transform":
      setter = buildTransformSetter(privateKey, requiredOpts);
      break;
    case "path":
      setter = buildPathSetter(privateKey, requiredOpts);
      break;
  }
  setter = buildCheckDirtyChain(
    buildChangeCallbackChain(buildConvertorChain(setter, requiredOpts), requiredOpts),
    requiredOpts
  );
  const getter = function() {
    return this[privateKey];
  };
  Object.defineProperty(target, key, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: true
  });
}
function buildConvertorChain(setterFn, opts) {
  const { convertor } = opts;
  if (convertor) {
    return function(value) {
      setterFn.call(this, convertor(value));
    };
  }
  return setterFn;
}
var NO_CHANGE = Symbol("no-change");
function buildChangeCallbackChain(setterFn, opts) {
  const { changeCb } = opts;
  if (changeCb) {
    return function(value) {
      const change = setterFn.call(this, value);
      if (change !== NO_CHANGE) {
        changeCb.call(this, this);
      }
      return change;
    };
  }
  return setterFn;
}
function buildCheckDirtyChain(setterFn, opts) {
  const { checkDirtyOnAssignment } = opts;
  if (checkDirtyOnAssignment) {
    return function(value) {
      const change = setterFn.call(this, value);
      if (change !== NO_CHANGE && value != null && value._dirty > 0 /* NONE */) {
        this.markDirty(value._dirty);
      }
      return change;
    };
  }
  return setterFn;
}
function buildNormalSetter(privateKey, opts) {
  const { redraw = 1 /* TRIVIAL */, changeCb } = opts;
  return function(value) {
    const oldValue = this[privateKey];
    if (value !== oldValue) {
      this[privateKey] = value;
      this.markDirty(redraw);
      changeCb?.(this);
      return value;
    }
    return NO_CHANGE;
  };
}
function buildTransformSetter(privateKey, opts) {
  const { redraw = 1 /* TRIVIAL */ } = opts;
  return function(value) {
    const oldValue = this[privateKey];
    if (value !== oldValue) {
      this[privateKey] = value;
      this.markDirtyTransform(redraw);
      return value;
    }
    return NO_CHANGE;
  };
}
function buildPathSetter(privateKey, opts) {
  const { redraw = 1 /* TRIVIAL */ } = opts;
  return function(value) {
    const oldValue = this[privateKey];
    if (value !== oldValue) {
      this[privateKey] = value;
      if (!this._dirtyPath) {
        this._dirtyPath = true;
        this.markDirty(redraw);
      }
      return value;
    }
    return NO_CHANGE;
  };
}

// packages/ag-charts-community/src/scene/node.ts
var _Node = class _Node {
  // Discriminators for render order within a zIndex
  constructor(options) {
    /** Unique number to allow creation order to be easily determined. */
    this.serialNumber = _Node._nextSerialNumber++;
    this.childNodeCounts = { groups: 0, nonGroups: 0 };
    /** Unique node ID in the form `ClassName-NaturalNumber`. */
    this.id = createId(this);
    this.pointerEvents = 0 /* All */;
    this._dirty = 3 /* MAJOR */;
    this.dirtyZIndex = false;
    this.virtualChildrenCount = 0;
    /**
     * To simplify the type system (especially in Selections) we don't have the `Parent` node
     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.
     * But we still need to distinguish regular leaf nodes from container leafs somehow.
     */
    this.isContainerNode = false;
    this.visible = true;
    this.zIndex = 0;
    this.zIndexSubOrder = void 0;
    this.name = options?.name;
    this.isVirtual = options?.isVirtual ?? false;
    this.tag = options?.tag ?? NaN;
    this.zIndex = options?.zIndex ?? 0;
  }
  static *extractBBoxes(nodes, skipInvisible) {
    for (const n of nodes) {
      if (!skipInvisible || n.visible && !n.transitionOut) {
        const bbox = n.getBBox();
        if (bbox)
          yield bbox;
      }
    }
  }
  /**
   * Some arbitrary data bound to the node.
   */
  get datum() {
    return this._datum ?? this.parentNode?.datum;
  }
  set datum(datum) {
    if (this._datum !== datum) {
      this._previousDatum = this._datum;
      this._datum = datum;
    }
  }
  get previousDatum() {
    return this._previousDatum;
  }
  get layerManager() {
    return this._layerManager;
  }
  get dirty() {
    return this._dirty;
  }
  /** Perform any pre-rendering initialization. */
  preRender() {
    this.childNodeCounts.groups = 0;
    this.childNodeCounts.nonGroups = 1;
    for (const child of this.children()) {
      const childCounts = child.preRender();
      this.childNodeCounts.groups += childCounts.groups;
      this.childNodeCounts.nonGroups += childCounts.nonGroups;
    }
    return this.childNodeCounts;
  }
  render(renderCtx) {
    const { stats } = renderCtx;
    this._dirty = 0 /* NONE */;
    if (renderCtx.debugNodeSearch) {
      const idOrName = this.name ?? this.id;
      if (renderCtx.debugNodeSearch.some((v) => typeof v === "string" ? v === idOrName : v.test(idOrName))) {
        renderCtx.debugNodes[this.name ?? this.id] = this;
      }
    }
    if (stats) {
      stats.nodesRendered++;
    }
  }
  _setLayerManager(value) {
    this._layerManager = value;
    this._debug = value?.debug;
    for (const child of this.children(false)) {
      child._setLayerManager(value);
    }
  }
  sortChildren(compareFn) {
    this.dirtyZIndex = false;
    if (!this.childNodes)
      return;
    if (this.hasVirtualChildren())
      return;
    const sortedChildren = [...this.childNodes].sort(compareFn);
    this.childNodes.clear();
    for (const child of sortedChildren) {
      this.childNodes.add(child);
    }
  }
  *traverseUp(includeSelf) {
    let node = this;
    if (includeSelf) {
      yield node;
    }
    while (node = node.parentNode) {
      yield node;
    }
  }
  *children(flattenVirtual = true) {
    if (!this.childNodes)
      return;
    const virtualChildren = [];
    for (const child of this.childNodes) {
      if (flattenVirtual && child.isVirtual) {
        virtualChildren.push(child.children());
      } else {
        yield child;
      }
    }
    for (const vChildren of virtualChildren) {
      yield* vChildren;
    }
  }
  *virtualChildren() {
    if (!this.childNodes || !this.virtualChildrenCount)
      return;
    for (const child of this.childNodes) {
      if (child.isVirtual) {
        yield child;
      }
    }
  }
  hasVirtualChildren() {
    return this.virtualChildrenCount > 0;
  }
  /**
   * Checks if the node is a leaf (has no children).
   */
  isLeaf() {
    return !this.childNodes?.size;
  }
  /**
   * Checks if the node is the root (has no parent).
   */
  isRoot() {
    return !this.parentNode;
  }
  /**
   * Appends one or more new node instances to this parent.
   * If one needs to:
   * - move a child to the end of the list of children
   * - move a child from one parent to another (including parents in other scenes)
   * one should use the {@link insertBefore} method instead.
   * @param nodes A node or nodes to append.
   */
  append(nodes) {
    this.childNodes ?? (this.childNodes = /* @__PURE__ */ new Set());
    for (const node of toIterable(nodes)) {
      node.parentNode?.removeChild(node);
      this.childNodes.add(node);
      node.parentNode = this;
      node._setLayerManager(this.layerManager);
      if (node.isVirtual) {
        this.virtualChildrenCount++;
      }
    }
    this.invalidateCachedBBox();
    this.dirtyZIndex = true;
    this.markDirty(3 /* MAJOR */);
  }
  appendChild(node) {
    this.append(node);
    return node;
  }
  removeChild(node) {
    if (!this.childNodes?.delete(node)) {
      return false;
    }
    delete node.parentNode;
    node._setLayerManager();
    if (node.isVirtual) {
      this.virtualChildrenCount--;
    }
    this.invalidateCachedBBox();
    this.dirtyZIndex = true;
    this.markDirty(3 /* MAJOR */);
    return true;
  }
  remove() {
    return this.parentNode?.removeChild(this) ?? false;
  }
  clear() {
    for (const child of this.children(false)) {
      delete child.parentNode;
      child._setLayerManager();
    }
    this.childNodes?.clear();
    this.invalidateCachedBBox();
    this.virtualChildrenCount = 0;
  }
  destroy() {
    this.parentNode?.removeChild(this);
  }
  setProperties(styles, pickKeys) {
    if (pickKeys) {
      for (const key of pickKeys) {
        this[key] = styles[key];
      }
    } else {
      Object.assign(this, styles);
    }
    return this;
  }
  containsPoint(_x, _y) {
    return false;
  }
  /**
   * Hit testing method.
   * Recursively checks if the given point is inside this node or any of its children.
   * Returns the first matching node or `undefined`.
   * Nodes that render later (show on top) are hit tested first.
   */
  pickNode(x, y, _localCoords = false) {
    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {
      return;
    }
    const children = [...this.children()];
    if (children.length > 1e3) {
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const containsPoint = child.containsPoint(x, y);
        const hit = containsPoint ? child.pickNode(x, y) : void 0;
        if (hit) {
          return hit;
        }
      }
    } else if (children.length) {
      for (let i = children.length - 1; i >= 0; i--) {
        const hit = children[i].pickNode(x, y);
        if (hit) {
          return hit;
        }
      }
    } else if (!this.isContainerNode) {
      return this;
    }
  }
  invalidateCachedBBox() {
    this.cachedBBox = void 0;
    this.parentNode?.invalidateCachedBBox();
  }
  getBBox() {
    if (this.cachedBBox == null) {
      this.cachedBBox = Object.freeze(this.computeBBox());
    }
    return this.cachedBBox;
  }
  computeBBox() {
    return;
  }
  markDirty(type = 1 /* TRIVIAL */, parentType = type) {
    const { _dirty } = this;
    const dirtyTypeBelowHighWatermark = _dirty > type || _dirty === type && type === parentType;
    const noParentCachedBBox = this.cachedBBox == null;
    if (noParentCachedBBox && dirtyTypeBelowHighWatermark)
      return;
    this.invalidateCachedBBox();
    this._dirty = Math.max(_dirty, type);
    if (this.parentNode) {
      this.parentNode.markDirty(parentType);
    } else if (this.layerManager) {
      this.layerManager.markDirty();
    }
  }
  markClean(opts) {
    const { force = false, recursive = true } = opts ?? {};
    if (this._dirty === 0 /* NONE */ && !force)
      return;
    this._dirty = 0 /* NONE */;
    for (const child of this.children(false)) {
      if (child.isVirtual ? recursive !== false : recursive === true) {
        child.markClean({ force });
      }
    }
  }
  onVisibleChange() {
  }
  onZIndexChange() {
    if (this.parentNode) {
      this.parentNode.dirtyZIndex = true;
    }
  }
  toSVG() {
    return;
  }
};
_Node._nextSerialNumber = 0;
__decorateClass([
  SceneChangeDetection({
    redraw: 3 /* MAJOR */,
    changeCb: (target) => target.onVisibleChange()
  })
], _Node.prototype, "visible", 2);
__decorateClass([
  SceneChangeDetection({
    redraw: 1 /* TRIVIAL */,
    changeCb: (target) => target.onZIndexChange()
  })
], _Node.prototype, "zIndex", 2);
__decorateClass([
  SceneChangeDetection({
    redraw: 1 /* TRIVIAL */,
    changeCb: (target) => target.onZIndexChange()
  })
], _Node.prototype, "zIndexSubOrder", 2);
var Node = _Node;

// packages/ag-charts-community/src/util/color.ts
var lerp = (x, y, t) => x * (1 - t) + y * t;
var srgbToLinear = (value) => {
  const sign = value < 0 ? -1 : 1;
  const abs = Math.abs(value);
  if (abs <= 0.04045)
    return value / 12.92;
  return sign * ((abs + 0.055) / 1.055) ** 2.4;
};
var srgbFromLinear = (value) => {
  const sign = value < 0 ? -1 : 1;
  const abs = Math.abs(value);
  if (abs > 31308e-7) {
    return sign * (1.055 * abs ** (1 / 2.4) - 0.055);
  }
  return 12.92 * value;
};
var _Color = class _Color {
  /**
   * Every color component should be in the [0, 1] range.
   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.
   * So, when animating colors, if the source or target color components are already near
   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color
   * component value to end up outside of that range mid-animation. For this reason the constructor
   * performs range checking/constraining.
   * @param r Red component.
   * @param g Green component.
   * @param b Blue component.
   * @param a Alpha (opacity) component.
   */
  constructor(r, g, b, a = 1) {
    this.r = clamp(0, r || 0, 1);
    this.g = clamp(0, g || 0, 1);
    this.b = clamp(0, b || 0, 1);
    this.a = clamp(0, a || 0, 1);
  }
  /**
   * A color string can be in one of the following formats to be valid:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   */
  static validColorString(str) {
    if (str.indexOf("#") >= 0) {
      return !!_Color.parseHex(str);
    }
    if (str.indexOf("rgb") >= 0) {
      return !!_Color.stringToRgba(str);
    }
    return !!_Color.nameToHex[str.toLowerCase()];
  }
  /**
   * The given string can be in one of the following formats:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   * @param str
   */
  static fromString(str) {
    if (str.indexOf("#") >= 0) {
      return _Color.fromHexString(str);
    }
    const hex = _Color.nameToHex[str.toLowerCase()];
    if (hex) {
      return _Color.fromHexString(hex);
    }
    if (str.indexOf("rgb") >= 0) {
      return _Color.fromRgbaString(str);
    }
    throw new Error(`Invalid color string: '${str}'`);
  }
  // See https://drafts.csswg.org/css-color/#hex-notation
  static parseHex(input) {
    input = input.replace(/ /g, "").slice(1);
    let parts;
    switch (input.length) {
      case 6:
      case 8:
        parts = [];
        for (let i = 0; i < input.length; i += 2) {
          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));
        }
        break;
      case 3:
      case 4:
        parts = input.split("").map((p) => parseInt(p, 16)).map((p) => p + p * 16);
        break;
    }
    if (parts?.length >= 3 && parts.every((p) => p >= 0)) {
      if (parts.length === 3) {
        parts.push(255);
      }
      return parts;
    }
  }
  static fromHexString(str) {
    const values = _Color.parseHex(str);
    if (values) {
      const [r, g, b, a] = values;
      return new _Color(r / 255, g / 255, b / 255, a / 255);
    }
    throw new Error(`Malformed hexadecimal color string: '${str}'`);
  }
  static stringToRgba(str) {
    let po = -1;
    let pc = -1;
    for (let i = 0; i < str.length; i++) {
      const c = str[i];
      if (po === -1 && c === "(") {
        po = i;
      } else if (c === ")") {
        pc = i;
        break;
      }
    }
    if (po === -1 || pc === -1)
      return;
    const contents = str.substring(po + 1, pc);
    const parts = contents.split(",");
    const rgba = [];
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      let value = parseFloat(part);
      if (!Number.isFinite(value)) {
        return;
      }
      if (part.indexOf("%") >= 0) {
        value = clamp(0, value, 100);
        value /= 100;
      } else if (i === 3) {
        value = clamp(0, value, 1);
      } else {
        value = clamp(0, value, 255);
        value /= 255;
      }
      rgba.push(value);
    }
    return rgba;
  }
  static fromRgbaString(str) {
    const rgba = _Color.stringToRgba(str);
    if (rgba) {
      if (rgba.length === 3) {
        return new _Color(rgba[0], rgba[1], rgba[2]);
      } else if (rgba.length === 4) {
        return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);
      }
    }
    throw new Error(`Malformed rgb/rgba color string: '${str}'`);
  }
  static fromArray(arr) {
    if (arr.length === 4) {
      return new _Color(arr[0], arr[1], arr[2], arr[3]);
    }
    if (arr.length === 3) {
      return new _Color(arr[0], arr[1], arr[2]);
    }
    throw new Error("The given array should contain 3 or 4 color components (numbers).");
  }
  static fromHSB(h, s, b, alpha = 1) {
    const rgb = _Color.HSBtoRGB(h, s, b);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static fromHSL(h, s, l, alpha = 1) {
    const rgb = _Color.HSLtoRGB(h, s, l);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static fromOKLCH(l, c, h, alpha = 1) {
    const rgb = _Color.OKLCHtoRGB(l, c, h);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static padHex(str) {
    return str.length === 1 ? "0" + str : str;
  }
  toHexString() {
    let hex = "#" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));
    if (this.a < 1) {
      hex += _Color.padHex(Math.round(this.a * 255).toString(16));
    }
    return hex;
  }
  toRgbaString(fractionDigits = 3) {
    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];
    const k = Math.pow(10, fractionDigits);
    if (this.a !== 1) {
      components.push(Math.round(this.a * k) / k);
      return `rgba(${components.join(", ")})`;
    }
    return `rgb(${components.join(", ")})`;
  }
  toString() {
    if (this.a === 1) {
      return this.toHexString();
    }
    return this.toRgbaString();
  }
  toHSB() {
    return _Color.RGBtoHSB(this.r, this.g, this.b);
  }
  static RGBtoOKLCH(r, g, b) {
    const LSRGB0 = srgbToLinear(r);
    const LSRGB1 = srgbToLinear(g);
    const LSRGB2 = srgbToLinear(b);
    const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);
    const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);
    const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);
    const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;
    const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;
    const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;
    const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;
    const OKLCH0 = OKLAB0;
    const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);
    const OKLCH2 = hue >= 0 ? hue : hue + 360;
    return [OKLCH0, OKLCH1, OKLCH2];
  }
  static OKLCHtoRGB(l, c, h) {
    const OKLAB0 = l;
    const OKLAB1 = c * Math.cos(h * Math.PI / 180);
    const OKLAB2 = c * Math.sin(h * Math.PI / 180);
    const LMS0 = (OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2) ** 3;
    const LMS1 = (OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2) ** 3;
    const LMS2 = (OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2) ** 3;
    const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;
    const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;
    const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;
    const SRGB0 = srgbFromLinear(LSRGB0);
    const SRGB1 = srgbFromLinear(LSRGB1);
    const SRGB2 = srgbFromLinear(LSRGB2);
    return [SRGB0, SRGB1, SRGB2];
  }
  static RGBtoHSL(r, g, b) {
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const l = (max + min) / 2;
    let h;
    let s;
    if (max === min) {
      h = 0;
      s = 0;
    } else {
      const delta3 = max - min;
      s = l > 0.5 ? delta3 / (2 - max - min) : delta3 / (max + min);
      if (max === r) {
        h = (g - b) / delta3 + (g < b ? 6 : 0);
      } else if (max === g) {
        h = (b - r) / delta3 + 2;
      } else {
        h = (r - g) / delta3 + 4;
      }
      h *= 360 / 6;
    }
    return [h, s, l];
  }
  static HSLtoRGB(h, s, l) {
    h = (h % 360 + 360) % 360;
    if (s === 0) {
      return [l, l, l];
    }
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    function hueToRgb(t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }
    const r = hueToRgb(h / 360 + 1 / 3);
    const g = hueToRgb(h / 360);
    const b = hueToRgb(h / 360 - 1 / 3);
    return [r, g, b];
  }
  /**
   * Converts the given RGB triple to an array of HSB (HSV) components.
   */
  static RGBtoHSB(r, g, b) {
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const S = max === 0 ? 0 : (max - min) / max;
    let H = 0;
    if (min !== max) {
      const delta3 = max - min;
      const rc = (max - r) / delta3;
      const gc = (max - g) / delta3;
      const bc = (max - b) / delta3;
      if (r === max) {
        H = bc - gc;
      } else if (g === max) {
        H = 2 + rc - bc;
      } else {
        H = 4 + gc - rc;
      }
      H /= 6;
      if (H < 0) {
        H = H + 1;
      }
    }
    return [H * 360, S, max];
  }
  /**
   * Converts the given HSB (HSV) triple to an array of RGB components.
   */
  static HSBtoRGB(H, S, B) {
    H = (H % 360 + 360) % 360 / 360;
    let r = 0;
    let g = 0;
    let b = 0;
    if (S === 0) {
      r = g = b = B;
    } else {
      const h = (H - Math.floor(H)) * 6;
      const f = h - Math.floor(h);
      const p = B * (1 - S);
      const q = B * (1 - S * f);
      const t = B * (1 - S * (1 - f));
      switch (h >> 0) {
        case 0:
          r = B;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = B;
          b = p;
          break;
        case 2:
          r = p;
          g = B;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = B;
          break;
        case 4:
          r = t;
          g = p;
          b = B;
          break;
        case 5:
          r = B;
          g = p;
          b = q;
          break;
      }
    }
    return [r, g, b];
  }
  static mix(c0, c1, t) {
    return new _Color(lerp(c0.r, c1.r, t), lerp(c0.g, c1.g, t), lerp(c0.b, c1.b, t), lerp(c0.a, c1.a, t));
  }
};
/**
 * CSS Color Module Level 4:
 * https://drafts.csswg.org/css-color/#named-colors
 */
_Color.nameToHex = {
  // @ts-expect-error
  __proto__: null,
  aliceblue: "#F0F8FF",
  antiquewhite: "#FAEBD7",
  aqua: "#00FFFF",
  aquamarine: "#7FFFD4",
  azure: "#F0FFFF",
  beige: "#F5F5DC",
  bisque: "#FFE4C4",
  black: "#000000",
  blanchedalmond: "#FFEBCD",
  blue: "#0000FF",
  blueviolet: "#8A2BE2",
  brown: "#A52A2A",
  burlywood: "#DEB887",
  cadetblue: "#5F9EA0",
  chartreuse: "#7FFF00",
  chocolate: "#D2691E",
  coral: "#FF7F50",
  cornflowerblue: "#6495ED",
  cornsilk: "#FFF8DC",
  crimson: "#DC143C",
  cyan: "#00FFFF",
  darkblue: "#00008B",
  darkcyan: "#008B8B",
  darkgoldenrod: "#B8860B",
  darkgray: "#A9A9A9",
  darkgreen: "#006400",
  darkgrey: "#A9A9A9",
  darkkhaki: "#BDB76B",
  darkmagenta: "#8B008B",
  darkolivegreen: "#556B2F",
  darkorange: "#FF8C00",
  darkorchid: "#9932CC",
  darkred: "#8B0000",
  darksalmon: "#E9967A",
  darkseagreen: "#8FBC8F",
  darkslateblue: "#483D8B",
  darkslategray: "#2F4F4F",
  darkslategrey: "#2F4F4F",
  darkturquoise: "#00CED1",
  darkviolet: "#9400D3",
  deeppink: "#FF1493",
  deepskyblue: "#00BFFF",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1E90FF",
  firebrick: "#B22222",
  floralwhite: "#FFFAF0",
  forestgreen: "#228B22",
  fuchsia: "#FF00FF",
  gainsboro: "#DCDCDC",
  ghostwhite: "#F8F8FF",
  gold: "#FFD700",
  goldenrod: "#DAA520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#ADFF2F",
  grey: "#808080",
  honeydew: "#F0FFF0",
  hotpink: "#FF69B4",
  indianred: "#CD5C5C",
  indigo: "#4B0082",
  ivory: "#FFFFF0",
  khaki: "#F0E68C",
  lavender: "#E6E6FA",
  lavenderblush: "#FFF0F5",
  lawngreen: "#7CFC00",
  lemonchiffon: "#FFFACD",
  lightblue: "#ADD8E6",
  lightcoral: "#F08080",
  lightcyan: "#E0FFFF",
  lightgoldenrodyellow: "#FAFAD2",
  lightgray: "#D3D3D3",
  lightgreen: "#90EE90",
  lightgrey: "#D3D3D3",
  lightpink: "#FFB6C1",
  lightsalmon: "#FFA07A",
  lightseagreen: "#20B2AA",
  lightskyblue: "#87CEFA",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#B0C4DE",
  lightyellow: "#FFFFE0",
  lime: "#00FF00",
  limegreen: "#32CD32",
  linen: "#FAF0E6",
  magenta: "#FF00FF",
  maroon: "#800000",
  mediumaquamarine: "#66CDAA",
  mediumblue: "#0000CD",
  mediumorchid: "#BA55D3",
  mediumpurple: "#9370DB",
  mediumseagreen: "#3CB371",
  mediumslateblue: "#7B68EE",
  mediumspringgreen: "#00FA9A",
  mediumturquoise: "#48D1CC",
  mediumvioletred: "#C71585",
  midnightblue: "#191970",
  mintcream: "#F5FFFA",
  mistyrose: "#FFE4E1",
  moccasin: "#FFE4B5",
  navajowhite: "#FFDEAD",
  navy: "#000080",
  oldlace: "#FDF5E6",
  olive: "#808000",
  olivedrab: "#6B8E23",
  orange: "#FFA500",
  orangered: "#FF4500",
  orchid: "#DA70D6",
  palegoldenrod: "#EEE8AA",
  palegreen: "#98FB98",
  paleturquoise: "#AFEEEE",
  palevioletred: "#DB7093",
  papayawhip: "#FFEFD5",
  peachpuff: "#FFDAB9",
  peru: "#CD853F",
  pink: "#FFC0CB",
  plum: "#DDA0DD",
  powderblue: "#B0E0E6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#FF0000",
  rosybrown: "#BC8F8F",
  royalblue: "#4169E1",
  saddlebrown: "#8B4513",
  salmon: "#FA8072",
  sandybrown: "#F4A460",
  seagreen: "#2E8B57",
  seashell: "#FFF5EE",
  sienna: "#A0522D",
  silver: "#C0C0C0",
  skyblue: "#87CEEB",
  slateblue: "#6A5ACD",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#FFFAFA",
  springgreen: "#00FF7F",
  steelblue: "#4682B4",
  tan: "#D2B48C",
  teal: "#008080",
  thistle: "#D8BFD8",
  tomato: "#FF6347",
  transparent: "#00000000",
  turquoise: "#40E0D0",
  violet: "#EE82EE",
  wheat: "#F5DEB3",
  white: "#FFFFFF",
  whitesmoke: "#F5F5F5",
  yellow: "#FFFF00",
  yellowgreen: "#9ACD32"
};
var Color = _Color;

// packages/ag-charts-community/src/util/interpolate.ts
function interpolateNumber(a, b) {
  return (d) => Number(a) * (1 - d) + Number(b) * d;
}
function interpolateColor(a, b) {
  if (typeof a === "string") {
    try {
      a = Color.fromString(a);
    } catch (e) {
      a = Color.fromArray([0, 0, 0]);
    }
  }
  if (typeof b === "string") {
    try {
      b = Color.fromString(b);
    } catch (e) {
      b = Color.fromArray([0, 0, 0]);
    }
  }
  return (d) => Color.mix(a, b, d).toRgbaString();
}

// packages/ag-charts-community/src/util/decorator.ts
var BREAK_TRANSFORM_CHAIN = Symbol("BREAK");
var CONFIG_KEY = "__decorator_config";
function initialiseConfig(target, propertyKeyOrSymbol) {
  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {
    Object.defineProperty(target, CONFIG_KEY, { value: {} });
  }
  const config = target[CONFIG_KEY];
  const propertyKey = propertyKeyOrSymbol.toString();
  if (typeof config[propertyKey] !== "undefined") {
    return config[propertyKey];
  }
  const valuesMap = /* @__PURE__ */ new WeakMap();
  config[propertyKey] = { setters: [], getters: [], observers: [], valuesMap };
  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);
  const prevSet = descriptor?.set;
  const prevGet = descriptor?.get;
  const getter = function() {
    let value = prevGet ? prevGet.call(this) : valuesMap.get(this);
    for (const transformFn of config[propertyKey].getters) {
      value = transformFn(this, propertyKeyOrSymbol, value);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return;
      }
    }
    return value;
  };
  const setter = function(value) {
    const { setters, observers } = config[propertyKey];
    let oldValue;
    if (setters.some((f) => f.length > 2)) {
      oldValue = prevGet ? prevGet.call(this) : valuesMap.get(this);
    }
    for (const transformFn of setters) {
      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return;
      }
    }
    if (prevSet) {
      prevSet.call(this, value);
    } else {
      valuesMap.set(this, value);
    }
    for (const observerFn of observers) {
      observerFn(this, value, oldValue);
    }
  };
  Object.defineProperty(target, propertyKeyOrSymbol, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: false
  });
  return config[propertyKey];
}
function addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {
  return (target, propertyKeyOrSymbol) => {
    const config = initialiseConfig(target, propertyKeyOrSymbol);
    config.setters.push(setTransform);
    if (getTransform) {
      config.getters.unshift(getTransform);
    }
    if (configMetadata) {
      Object.assign(config, configMetadata);
    }
  };
}
function addObserverToInstanceProperty(setObserver) {
  return (target, propertyKeyOrSymbol) => {
    initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);
  };
}
function isDecoratedObject(target) {
  return typeof target !== "undefined" && CONFIG_KEY in target;
}
function listDecoratedProperties(target) {
  const targets = /* @__PURE__ */ new Set();
  while (isDecoratedObject(target)) {
    targets.add(target?.[CONFIG_KEY]);
    target = Object.getPrototypeOf(target);
  }
  return Array.from(targets).flatMap((configMap) => Object.keys(configMap));
}
function extractDecoratedPropertyMetadata(target, propertyKeyOrSymbol) {
  const propertyKey = propertyKeyOrSymbol.toString();
  while (isDecoratedObject(target)) {
    const config = target[CONFIG_KEY];
    if (Object.hasOwn(config, propertyKey)) {
      return config[propertyKey];
    }
    target = Object.getPrototypeOf(target);
  }
}

// packages/ag-charts-community/src/util/type-guards.ts
function isDefined(val) {
  return val != null;
}
function isArray(value) {
  return Array.isArray(value);
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isDate(value) {
  return value instanceof Date;
}
function isValidDate(value) {
  return isDate(value) && !isNaN(Number(value));
}
function isRegExp(value) {
  return value instanceof RegExp;
}
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return typeof value === "object" && value !== null && !isArray(value);
}
function isPlainObject(value) {
  return typeof value === "object" && value !== null && Object.getPrototypeOf(value) === Object.prototype;
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isFiniteNumber(value) {
  return Number.isFinite(value);
}
function isHtmlElement(value) {
  return typeof window !== "undefined" && value instanceof HTMLElement;
}
function isEnumValue(enumObject, enumValue) {
  return Object.values(enumObject).includes(enumValue);
}
function isSymbol(value) {
  return typeof value === "symbol";
}
function excludesType(obj, excluded) {
  return obj.type !== excluded;
}

// packages/ag-charts-community/src/util/object.ts
function objectEqualWith(a, b, cmp) {
  for (const key in b) {
    if (!(key in a))
      return false;
  }
  for (const key in a) {
    if (!(key in b))
      return false;
    if (!cmp(a[key], b[key]))
      return false;
  }
  return true;
}
function mergeDefaults(...sources) {
  const target = {};
  for (const source of sources) {
    if (!isObject(source))
      continue;
    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);
    for (const key of keys) {
      if (isPlainObject(target[key]) && isPlainObject(source[key])) {
        target[key] = mergeDefaults(target[key], source[key]);
      } else {
        target[key] ?? (target[key] = source[key]);
      }
    }
  }
  return target;
}
function mergeArrayDefaults(dataArray, ...itemDefaults) {
  if (itemDefaults && isArray(dataArray)) {
    return dataArray.map((item) => mergeDefaults(item, ...itemDefaults));
  }
  return dataArray;
}
function mapValues(object2, mapper) {
  return Object.entries(object2).reduce(
    (result, [key, value]) => {
      result[key] = mapper(value, key, object2);
      return result;
    },
    {}
  );
}
function without(object2, keys) {
  const clone = { ...object2 };
  for (const key of keys) {
    delete clone[key];
  }
  return clone;
}
function getPath(object2, path) {
  const pathArray = isArray(path) ? path : path.split(".");
  return pathArray.reduce((value, pathKey) => value[pathKey], object2);
}
var SKIP_JS_BUILTINS = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function setPath(object2, path, newValue) {
  const pathArray = isArray(path) ? path.slice() : path.split(".");
  const lastKey = pathArray.pop();
  if (pathArray.some((p) => SKIP_JS_BUILTINS.has(p)))
    return;
  const lastObject = pathArray.reduce((value, pathKey) => value[pathKey], object2);
  lastObject[lastKey] = newValue;
  return lastObject[lastKey];
}
function partialAssign(keysToCopy, target, source) {
  if (source === void 0) {
    return target;
  }
  for (const key of keysToCopy) {
    const value = source[key];
    if (value !== void 0) {
      target[key] = value;
    }
  }
  return target;
}

// packages/ag-charts-community/src/motion/easing.ts
var linear = (n) => n;
var easeOut = (n) => Math.sin(n * Math.PI / 2);
var inverseEaseOut = (x) => 2 * Math.asin(x) / Math.PI;

// packages/ag-charts-community/src/motion/animation.ts
var QUICK_TRANSITION = 0.2;
var PHASE_ORDER = ["initial", "remove", "update", "add", "trailing", "end", "none"];
var PHASE_METADATA = {
  initial: {
    animationDuration: 1,
    animationDelay: 0
  },
  add: {
    animationDuration: 0.25,
    animationDelay: 0.75
  },
  remove: {
    animationDuration: 0.25,
    animationDelay: 0
  },
  update: {
    animationDuration: 0.5,
    animationDelay: 0.25
  },
  trailing: {
    animationDuration: QUICK_TRANSITION,
    animationDelay: 1,
    skipIfNoEarlierAnimations: true
  },
  end: {
    animationDelay: 1 + QUICK_TRANSITION,
    animationDuration: 0,
    skipIfNoEarlierAnimations: true
  },
  none: {
    animationDuration: 0,
    animationDelay: 0
  }
};
function isNodeArray(array2) {
  return array2.every((n) => n instanceof Node);
}
function deconstructSelectionsOrNodes(selectionsOrNodes) {
  return isNodeArray(selectionsOrNodes) ? { nodes: selectionsOrNodes, selections: [] } : { nodes: [], selections: selectionsOrNodes };
}
function animationValuesEqual(a, b) {
  if (a === b) {
    return true;
  } else if (Array.isArray(a) && Array.isArray(b)) {
    return a.length === b.length && a.every((v, i) => animationValuesEqual(v, b[i]));
  } else if (isInterpolating(a) && isInterpolating(b)) {
    return a.equals(b);
  } else if (isPlainObject(a) && isPlainObject(b)) {
    return objectEqualWith(a, b, animationValuesEqual);
  }
  return false;
}
var Animation = class {
  constructor(opts) {
    this.isComplete = false;
    this.elapsed = 0;
    this.iteration = 0;
    this.isPlaying = false;
    this.isReverse = false;
    this.id = opts.id;
    this.groupId = opts.groupId;
    this.autoplay = opts.autoplay ?? true;
    this.ease = opts.ease ?? linear;
    this.phase = opts.phase;
    const durationProportion = opts.duration ?? PHASE_METADATA[this.phase].animationDuration;
    this.duration = durationProportion * opts.defaultDuration;
    this.delay = (opts.delay ?? 0) * opts.defaultDuration;
    this.onComplete = opts.onComplete;
    this.onPlay = opts.onPlay;
    this.onStop = opts.onStop;
    this.onUpdate = opts.onUpdate;
    this.interpolate = this.createInterpolator(opts.from, opts.to);
    this.from = opts.from;
    if (opts.skip === true) {
      this.onUpdate?.(opts.to, false, this);
      this.onStop?.(this);
      this.onComplete?.(this);
      this.isComplete = true;
    }
    if (opts.collapsable !== false) {
      this.duration = this.checkCollapse(opts, this.duration);
    }
  }
  checkCollapse(opts, calculatedDuration) {
    return animationValuesEqual(opts.from, opts.to) ? 0 : calculatedDuration;
  }
  play(initialUpdate = false) {
    if (this.isPlaying || this.isComplete)
      return;
    this.isPlaying = true;
    this.onPlay?.(this);
    if (!this.autoplay)
      return;
    this.autoplay = false;
    if (!initialUpdate)
      return;
    this.onUpdate?.(this.from, true, this);
  }
  pause() {
    this.isPlaying = false;
  }
  stop() {
    this.isPlaying = false;
    if (!this.isComplete) {
      this.isComplete = true;
      this.onStop?.(this);
    }
  }
  update(time2) {
    if (this.isComplete)
      return time2;
    if (!this.isPlaying && this.autoplay) {
      this.play(true);
    }
    const previousElapsed = this.elapsed;
    this.elapsed += time2;
    if (this.delay > this.elapsed)
      return 0;
    const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);
    this.onUpdate?.(value, false, this);
    const totalDuration = this.delay + this.duration;
    if (this.elapsed >= totalDuration) {
      this.stop();
      this.isComplete = true;
      this.onComplete?.(this);
      return time2 - (totalDuration - previousElapsed);
    }
    return 0;
  }
  get delta() {
    return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));
  }
  createInterpolator(from2, to) {
    if (typeof to !== "object" || isInterpolating(to)) {
      return this.interpolateValue(from2, to);
    }
    const interpolatorEntries = [];
    for (const key in to) {
      const interpolator = this.interpolateValue(from2[key], to[key]);
      if (interpolator != null) {
        interpolatorEntries.push([key, interpolator]);
      }
    }
    return (d) => {
      const result = {};
      for (const [key, interpolator] of interpolatorEntries) {
        result[key] = interpolator(d);
      }
      return result;
    };
  }
  interpolateValue(a, b) {
    if (a == null || b == null) {
      return;
    } else if (isInterpolating(a)) {
      return (d) => a[interpolate](b, d);
    }
    try {
      switch (typeof a) {
        case "number":
          return interpolateNumber(a, b);
        case "string":
          return interpolateColor(a, b);
        case "boolean":
          if (a === b) {
            return () => a;
          }
          break;
      }
    } catch (e) {
    }
    throw new Error(`Unable to interpolate values: ${a}, ${b}`);
  }
};

// packages/ag-charts-community/src/motion/fromToMotion.ts
var NODE_UPDATE_STATE_TO_PHASE_MAPPING = {
  added: "add",
  updated: "update",
  removed: "remove",
  unknown: "initial",
  "no-op": "none"
};
function fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff2) {
  const { fromFn, toFn, applyFn = (node, props) => node.setProperties(props) } = fns;
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  const processNodes = (liveNodes, subNodes) => {
    let prevFromProps;
    let liveNodeIndex = 0;
    let nodeIndex = 0;
    for (const node of subNodes) {
      const isLive = liveNodes[liveNodeIndex] === node;
      const ctx = {
        last: nodeIndex >= subNodes.length - 1,
        lastLive: liveNodeIndex >= liveNodes.length - 1,
        prev: subNodes[nodeIndex - 1],
        prevFromProps,
        prevLive: liveNodes[liveNodeIndex - 1],
        next: subNodes[nodeIndex + 1],
        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]
      };
      const animationId = `${groupId}_${subId}_${node.id}`;
      animationManager.stopByAnimationId(animationId);
      let status = "unknown";
      if (!isLive) {
        status = "removed";
      } else if (getDatumId && diff2) {
        status = calculateStatus(node, node.datum, getDatumId, diff2);
      }
      node.transitionOut = status === "removed";
      const { phase, start, finish, delay, duration, ...from2 } = fromFn(node, node.datum, status, ctx);
      const {
        phase: toPhase,
        start: toStart,
        finish: toFinish,
        delay: toDelay,
        duration: toDuration,
        ...to
      } = toFn(node, node.datum, status, ctx);
      const collapsable = finish == null;
      animationManager.animate({
        id: animationId,
        groupId,
        phase: phase ?? toPhase ?? "update",
        duration: duration ?? toDuration,
        delay: delay ?? toDelay,
        from: from2,
        to,
        ease: easeOut,
        collapsable,
        onPlay: () => {
          applyFn(node, { ...start, ...toStart, ...from2 });
        },
        onUpdate(props) {
          applyFn(node, props);
        },
        onStop: () => {
          applyFn(node, {
            ...start,
            ...toStart,
            ...from2,
            ...to,
            ...finish,
            ...toFinish
          });
        }
      });
      if (isLive) {
        liveNodeIndex++;
      }
      nodeIndex++;
      prevFromProps = from2;
    }
  };
  let selectionIndex = 0;
  for (const selection of selections) {
    const selectionNodes = selection.nodes();
    const liveNodes = selectionNodes.filter((n) => !selection.isGarbage(n));
    processNodes(liveNodes, selectionNodes);
    animationManager.animate({
      id: `${groupId}_${subId}_selection_${selectionIndex}`,
      groupId,
      phase: "end",
      from: 0,
      to: 1,
      ease: easeOut,
      onStop() {
        selection.cleanup();
      }
    });
    selectionIndex++;
  }
  processNodes(nodes, nodes);
}
function staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from2, to, extraOpts) {
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  const { start, finish, phase } = extraOpts;
  animationManager.animate({
    id: `${groupId}_${subId}`,
    groupId,
    phase: phase ?? "update",
    from: from2,
    to,
    ease: easeOut,
    onPlay: () => {
      if (!start)
        return;
      for (const node of nodes) {
        node.setProperties(start);
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(start);
        }
      }
    },
    onUpdate(props) {
      for (const node of nodes) {
        node.setProperties(props);
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(props);
        }
      }
    },
    onStop: () => {
      for (const node of nodes) {
        node.setProperties({ ...to, ...finish });
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties({ ...to, ...finish });
        }
        selection.cleanup();
      }
    }
  });
}
function calculateStatus(node, datum, getDatumId, diff2) {
  const id = getDatumId(node, datum);
  if (diff2.added.has(id)) {
    return "added";
  }
  if (diff2.removed.has(id)) {
    return "removed";
  }
  return "updated";
}

// packages/ag-charts-community/src/util/function.ts
var doOnceState = /* @__PURE__ */ new Map();
function doOnce(func, key) {
  if (doOnceState.has(key))
    return;
  doOnceState.set(key, true);
  func();
}
doOnce.clear = () => doOnceState.clear();
function identity(x) {
  return x;
}
function throttle(callback2, waitMs = 0, options) {
  const { leading = true, trailing = true } = options ?? {};
  let timerId;
  let lastArgs;
  let shouldWait = false;
  function timeoutHandler() {
    if (trailing && lastArgs) {
      timerId = setTimeout(timeoutHandler, waitMs);
      callback2(...lastArgs);
    } else {
      shouldWait = false;
    }
    lastArgs = null;
  }
  function throttleCallback(...args) {
    if (shouldWait) {
      lastArgs = args;
    } else {
      shouldWait = true;
      timerId = setTimeout(timeoutHandler, waitMs);
      if (leading) {
        callback2(...args);
      } else {
        lastArgs = args;
      }
    }
  }
  return Object.assign(throttleCallback, {
    cancel() {
      clearTimeout(timerId);
      shouldWait = false;
      lastArgs = null;
    }
  });
}
function joinFunctions(...fns) {
  return () => {
    for (const fn of fns) {
      fn();
    }
  };
}

// packages/ag-charts-community/src/util/logger.ts
var Logger = {
  log(...logContent) {
    console.log(...logContent);
  },
  warn(message, ...logContent) {
    console.warn(`AG Charts - ${message}`, ...logContent);
  },
  error(message, ...logContent) {
    if (typeof message === "object") {
      console.error(`AG Charts error`, message, ...logContent);
    } else {
      console.error(`AG Charts - ${message}`, ...logContent);
    }
  },
  table(...logContent) {
    console.table(...logContent);
  },
  warnOnce(message, ...logContent) {
    doOnce(() => Logger.warn(message, ...logContent), `Logger.warn: ${message}`);
  },
  errorOnce(message, ...logContent) {
    doOnce(() => Logger.error(message, ...logContent), `Logger.error: ${message}`);
  }
};

// packages/ag-charts-community/src/scale/invalidating.ts
var Invalidating = (target, propertyKey) => {
  const mappedProperty = Symbol(String(propertyKey));
  target[mappedProperty] = void 0;
  Object.defineProperty(target, propertyKey, {
    get() {
      return this[mappedProperty];
    },
    set(newValue) {
      const oldValue = this[mappedProperty];
      if (oldValue !== newValue) {
        this[mappedProperty] = newValue;
        this.invalid = true;
      }
    },
    enumerable: true,
    configurable: false
  });
};

// packages/ag-charts-community/src/scale/continuousScale.ts
var _ContinuousScale = class _ContinuousScale {
  constructor(domain, range3) {
    this.invalid = true;
    this.nice = false;
    this.interval = void 0;
    this.tickCount = _ContinuousScale.defaultTickCount;
    this.minTickCount = 0;
    this.maxTickCount = Infinity;
    // TODO(olegat) should be of type D[]
    this.niceDomain = [];
    this.defaultClampMode = "raw";
    this.domain = domain;
    this.range = range3;
  }
  static is(value) {
    return value instanceof _ContinuousScale;
  }
  transform(x) {
    return x;
  }
  transformInvert(x) {
    return x;
  }
  calcBandwidth(smallestInterval = 1) {
    const domain = this.getDomain();
    const rangeDistance = this.getPixelRange();
    const intervals = Math.abs(domain[1] - domain[0]) / smallestInterval + 1;
    const maxBands = Math.floor(rangeDistance);
    const bands = Math.min(intervals, maxBands);
    return rangeDistance / Math.max(1, bands);
  }
  getDomain() {
    if (this.nice) {
      this.refresh();
      if (this.niceDomain.length) {
        return this.niceDomain;
      }
    }
    return this.domain;
  }
  convert(x, opts) {
    const clampMode = opts?.clampMode ?? this.defaultClampMode;
    if (!this.domain || this.domain.length < 2) {
      return NaN;
    }
    this.refresh();
    const domain = this.getDomain().map((d) => this.transform(d));
    const [d0, d1] = domain;
    const { range: range3 } = this;
    const [r0, r1] = range3;
    x = this.transform(x);
    if (clampMode === "clamped") {
      const [start, stop] = findMinMax(domain.map(Number));
      if (Number(x) < start) {
        return r0;
      } else if (Number(x) > stop) {
        return r1;
      }
    }
    if (d0 === d1) {
      return (r0 + r1) / 2;
    } else if (x === d0) {
      return r0;
    } else if (x === d1) {
      return r1;
    }
    return r0 + (Number(x) - Number(d0)) / (Number(d1) - Number(d0)) * (r1 - r0);
  }
  invert(x) {
    this.refresh();
    const domain = this.getDomain().map((d2) => this.transform(d2));
    const [d0, d1] = domain;
    const { range: range3 } = this;
    const [r0, r1] = range3;
    const isReversed = r0 > r1;
    const rMin = isReversed ? r1 : r0;
    const rMax = isReversed ? r0 : r1;
    let d;
    if (x < rMin) {
      return isReversed ? d1 : d0;
    } else if (x > rMax) {
      return isReversed ? d0 : d1;
    } else if (r0 === r1) {
      d = this.toDomain((Number(d0) + Number(d1)) / 2);
    } else {
      d = this.toDomain(Number(d0) + (x - r0) / (r1 - r0) * (Number(d1) - Number(d0)));
    }
    return this.transformInvert(d);
  }
  refresh() {
    if (!this.invalid)
      return;
    this.invalid = false;
    this.update();
    if (this.invalid) {
      Logger.warnOnce("Expected update to not invalidate scale");
    }
  }
  getPixelRange() {
    const [a, b] = this.range;
    return Math.abs(b - a);
  }
};
_ContinuousScale.defaultTickCount = 5;
_ContinuousScale.defaultMaxTickCount = 6;
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "domain", 2);
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "range", 2);
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "nice", 2);
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "interval", 2);
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "tickCount", 2);
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "minTickCount", 2);
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "maxTickCount", 2);
var ContinuousScale = _ContinuousScale;

// packages/ag-charts-community/src/util/array.ts
function extent(values) {
  if (values.length === 0) {
    return null;
  }
  let min = Infinity;
  let max = -Infinity;
  for (let n of values) {
    if (n instanceof Date) {
      n = n.getTime();
    }
    if (typeof n !== "number") {
      continue;
    }
    if (n < min) {
      min = n;
    }
    if (n > max) {
      max = n;
    }
  }
  const result = [min, max];
  return result.every(isFinite) ? result : null;
}
function normalisedExtentWithMetadata(d, min, max) {
  let clipped = false;
  if (d.length > 2) {
    d = extent(d) ?? [NaN, NaN];
  }
  if (!isNaN(min)) {
    clipped || (clipped = min > d[0]);
    d = [min, d[1]];
  }
  if (!isNaN(max)) {
    clipped || (clipped = max < d[1]);
    d = [d[0], max];
  }
  if (d[0] > d[1]) {
    d = [];
  }
  return { extent: d, clipped };
}
function arraysEqual(a, b) {
  if (a == null || b == null || a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (Array.isArray(a[i]) && Array.isArray(b[i])) {
      if (!arraysEqual(a[i], b[i])) {
        return false;
      }
    } else if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function toArray(value) {
  if (typeof value === "undefined") {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function unique(array2) {
  return Array.from(new Set(array2));
}
function groupBy(array2, iteratee) {
  return array2.reduce((result, item) => {
    const groupKey = iteratee(item);
    result[groupKey] ?? (result[groupKey] = []);
    result[groupKey].push(item);
    return result;
  }, {});
}
function circularSliceArray(data, size, offset4 = 0) {
  if (data.length === 0) {
    return [];
  }
  const result = [];
  for (let i = 0; i < size; i++) {
    result.push(data.at((i + offset4) % data.length));
  }
  return result;
}

// packages/ag-charts-community/src/util/time/duration.ts
var epochYear = (/* @__PURE__ */ new Date(0)).getFullYear();
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// packages/ag-charts-community/src/util/time/interval.ts
var TimeInterval = class {
  constructor(_encode, _decode, _rangeCallback) {
    this._encode = _encode;
    this._decode = _decode;
    this._rangeCallback = _rangeCallback;
  }
  /**
   * Returns a new date representing the latest interval boundary date before or equal to date.
   * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.
   * @param date
   */
  floor(date) {
    const d = new Date(date);
    const e = this._encode(d);
    return this._decode(e);
  }
  /**
   * Returns a new date representing the earliest interval boundary date after or equal to date.
   * @param date
   */
  ceil(date) {
    const d = new Date(Number(date) - 1);
    const e = this._encode(d);
    return this._decode(e + 1);
  }
  /**
   * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).
   * @param start Range start.
   * @param stop Range end.
   * @param extend If specified, the requested range will be extended to the closest "nice" values.
   */
  range(start, stop, extend) {
    const rangeCallback = this._rangeCallback?.(start, stop);
    const e0 = this._encode(extend ? this.floor(start) : this.ceil(start));
    const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));
    if (e1 < e0) {
      return [];
    }
    const range3 = [];
    for (let e = e0; e <= e1; e++) {
      const d = this._decode(e);
      range3.push(d);
    }
    rangeCallback?.();
    return range3;
  }
};
var CountableTimeInterval = class extends TimeInterval {
  getOffset(snapTo, step) {
    const s = typeof snapTo === "number" || snapTo instanceof Date ? this._encode(new Date(snapTo)) : 0;
    return Math.floor(s) % step;
  }
  /**
   * Returns a filtered view of this interval representing every step'th date.
   * It can be a number of minutes, hours, days etc.
   * Must be a positive integer.
   * @param step
   */
  every(step, options) {
    let offset4 = 0;
    let rangeCallback;
    const unsafeStep = step;
    step = Math.max(1, Math.round(step));
    if (unsafeStep !== step) {
      Logger.warnOnce(`interval step of [${unsafeStep}] rounded to [${step}].`);
    }
    const { snapTo = "start" } = options ?? {};
    if (typeof snapTo === "string") {
      const initialOffset = offset4;
      rangeCallback = (start, stop) => {
        const s = snapTo === "start" ? start : stop;
        offset4 = this.getOffset(s, step);
        return () => offset4 = initialOffset;
      };
    } else if (typeof snapTo === "number") {
      offset4 = this.getOffset(new Date(snapTo), step);
    } else if (snapTo instanceof Date) {
      offset4 = this.getOffset(snapTo, step);
    }
    const encode13 = (date) => {
      const e = this._encode(date);
      return Math.floor((e - offset4) / step);
    };
    const decode13 = (encoded) => {
      return this._decode(encoded * step + offset4);
    };
    return new TimeInterval(encode13, decode13, rangeCallback);
  }
};

// packages/ag-charts-community/src/util/time/day.ts
function encode(date) {
  const tzOffsetMs = date.getTimezoneOffset() * durationMinute;
  return Math.floor((date.getTime() - tzOffsetMs) / durationDay);
}
function decode(encoded) {
  const d = new Date(1970, 0, 1);
  d.setDate(d.getDate() + encoded);
  return d;
}
var day = new CountableTimeInterval(encode, decode);
var day_default = day;

// packages/ag-charts-community/src/util/time/hour.ts
var offset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
function encode2(date) {
  return Math.floor((date.getTime() - offset) / durationHour);
}
function decode2(encoded) {
  return new Date(offset + encoded * durationHour);
}
var hour = new CountableTimeInterval(encode2, decode2);
var hour_default = hour;

// packages/ag-charts-community/src/util/time/minute.ts
var offset2 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
function encode3(date) {
  return Math.floor((date.getTime() - offset2) / durationMinute);
}
function decode3(encoded) {
  return new Date(offset2 + encoded * durationMinute);
}
var minute = new CountableTimeInterval(encode3, decode3);
var minute_default = minute;

// packages/ag-charts-community/src/util/time/month.ts
function encode4(date) {
  return date.getFullYear() * 12 + date.getMonth();
}
function decode4(encoded) {
  const year2 = Math.floor(encoded / 12);
  const month2 = encoded - year2 * 12;
  return new Date(year2, month2, 1);
}
var month = new CountableTimeInterval(encode4, decode4);
var month_default = month;

// packages/ag-charts-community/src/util/time/second.ts
var offset3 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
function encode5(date) {
  return Math.floor((date.getTime() - offset3) / durationSecond);
}
function decode5(encoded) {
  return new Date(offset3 + encoded * durationSecond);
}
var second = new CountableTimeInterval(encode5, decode5);
var second_default = second;

// packages/ag-charts-community/src/util/time/week.ts
function weekday(weekStart) {
  const thursday2 = 4;
  const dayShift = (7 + weekStart - thursday2) % 7;
  function encode13(date) {
    const tzOffsetMs = date.getTimezoneOffset() * durationMinute;
    return Math.floor((date.getTime() - tzOffsetMs) / durationWeek - dayShift / 7);
  }
  function decode13(encoded) {
    const d = new Date(1970, 0, 1);
    d.setDate(d.getDate() + encoded * 7 + dayShift);
    return d;
  }
  return new CountableTimeInterval(encode13, decode13);
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var week_default = sunday;

// packages/ag-charts-community/src/util/time/year.ts
function encode6(date) {
  return date.getFullYear();
}
function decode6(encoded) {
  const d = /* @__PURE__ */ new Date();
  d.setFullYear(encoded);
  d.setMonth(0, 1);
  d.setHours(0, 0, 0, 0);
  return d;
}
var year = new CountableTimeInterval(encode6, decode6);
var year_default = year;

// packages/ag-charts-community/src/util/timeFormat.ts
var CONSTANTS = {
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
};
function dayOfYear(date, startOfYear = new Date(date.getFullYear(), 0, 1)) {
  const startOffset = date.getTimezoneOffset() - startOfYear.getTimezoneOffset();
  const timeDiff = date.getTime() - startOfYear.getTime() + startOffset * 6e4;
  const timeOneDay = 36e5 * 24;
  return Math.floor(timeDiff / timeOneDay);
}
function weekOfYear(date, startDay) {
  const startOfYear = new Date(date.getFullYear(), 0, 1);
  const startOfYearDay = startOfYear.getDay();
  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;
  const startOffset = new Date(date.getFullYear(), 0, firstWeekStartOffset + 1);
  if (startOffset <= date) {
    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;
  }
  return 0;
}
var SUNDAY = 0;
var MONDAY = 1;
var THURSDAY = 4;
function isoWeekOfYear(date, year2 = date.getFullYear()) {
  const firstOfYear = new Date(year2, 0, 1);
  const firstOfYearDay = firstOfYear.getDay();
  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;
  const startOffset = new Date(year2, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);
  if (startOffset <= date) {
    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;
  }
  return isoWeekOfYear(date, year2 - 1);
}
function timezone(date) {
  const offset4 = date.getTimezoneOffset();
  const unsignedOffset = Math.abs(offset4);
  const sign = offset4 > 0 ? "-" : "+";
  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, "0")}${pad(Math.floor(unsignedOffset % 60), 2, "0")}`;
}
var FORMATTERS = {
  a: (d) => CONSTANTS.shortDays[d.getDay()],
  A: (d) => CONSTANTS.days[d.getDay()],
  b: (d) => CONSTANTS.shortMonths[d.getMonth()],
  B: (d) => CONSTANTS.months[d.getMonth()],
  c: "%x, %X",
  d: (d, p) => pad(d.getDate(), 2, p ?? "0"),
  e: "%_d",
  f: (d, p) => pad(d.getMilliseconds() * 1e3, 6, p ?? "0"),
  H: (d, p) => pad(d.getHours(), 2, p ?? "0"),
  I: (d, p) => {
    const hours = d.getHours() % 12;
    return hours === 0 ? "12" : pad(hours, 2, p ?? "0");
  },
  j: (d, p) => pad(dayOfYear(d) + 1, 3, p ?? "0"),
  m: (d, p) => pad(d.getMonth() + 1, 2, p ?? "0"),
  M: (d, p) => pad(d.getMinutes(), 2, p ?? "0"),
  L: (d, p) => pad(d.getMilliseconds(), 3, p ?? "0"),
  p: (d) => d.getHours() < 12 ? "AM" : "PM",
  Q: (d) => String(d.getTime()),
  s: (d) => String(Math.floor(d.getTime() / 1e3)),
  S: (d, p) => pad(d.getSeconds(), 2, p ?? "0"),
  u: (d) => {
    let day2 = d.getDay();
    if (day2 < 1)
      day2 += 7;
    return String(day2 % 7);
  },
  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p ?? "0"),
  V: (d, p) => pad(isoWeekOfYear(d), 2, p ?? "0"),
  w: (d, p) => pad(d.getDay(), 2, p ?? "0"),
  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p ?? "0"),
  x: "%-m/%-d/%Y",
  X: "%-I:%M:%S %p",
  y: (d, p) => pad(d.getFullYear() % 100, 2, p ?? "0"),
  Y: (d, p) => pad(d.getFullYear(), 4, p ?? "0"),
  Z: (d) => timezone(d),
  "%": () => "%"
};
var PADS = {
  _: " ",
  "0": "0",
  "-": ""
};
function pad(value, size, padChar) {
  const output = String(Math.floor(value));
  if (output.length >= size) {
    return output;
  }
  return `${padChar.repeat(size - output.length)}${output}`;
}
function buildFormatter(formatString) {
  const formatParts = [];
  while (formatString.length > 0) {
    let nextEscapeIdx = formatString.indexOf("%");
    if (nextEscapeIdx !== 0) {
      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;
      formatParts.push(literalPart);
    }
    if (nextEscapeIdx < 0)
      break;
    const maybePadSpecifier = formatString[nextEscapeIdx + 1];
    const maybePad = PADS[maybePadSpecifier];
    if (maybePad != null) {
      nextEscapeIdx++;
    }
    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];
    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];
    if (typeof maybeFormatter === "function") {
      formatParts.push([maybeFormatter, maybePad]);
    } else if (typeof maybeFormatter === "string") {
      const formatter = buildFormatter(maybeFormatter);
      formatParts.push([formatter, maybePad]);
    } else {
      formatParts.push(`${maybePad ?? ""}${maybeFormatterSpecifier}`);
    }
    formatString = formatString.substring(nextEscapeIdx + 2);
  }
  return (dateTime) => {
    const dateTimeAsDate = typeof dateTime === "number" ? new Date(dateTime) : dateTime;
    return formatParts.map((c) => typeof c === "string" ? c : c[0](dateTimeAsDate, c[1])).join("");
  };
}

// packages/ag-charts-community/src/util/timeFormatDefaults.ts
function dateToNumber(value) {
  return value instanceof Date ? value.getTime() : value;
}
function defaultTimeTickFormat(ticks, domain, formatOffset) {
  const formatString = calculateDefaultTimeTickFormat(ticks, domain, formatOffset);
  const formatter = buildFormatter(formatString);
  return (date) => formatter(date);
}
function calculateDefaultTimeTickFormat(ticks = [], domain = ticks, formatOffset = 0) {
  let minInterval = Infinity;
  for (let i = 1; i < ticks.length; i++) {
    minInterval = Math.min(minInterval, Math.abs(ticks[i] - ticks[i - 1]));
  }
  const startYear = new Date(domain[0]).getFullYear();
  const stopYear = new Date(domain.at(-1)).getFullYear();
  const yearChange = stopYear - startYear > 0;
  const timeFormat = isFinite(minInterval) ? getIntervalLowestGranularityFormat(minInterval, ticks) : getLowestGranularityFormat(ticks[0]);
  return formatStringBuilder(Math.max(timeFormat - formatOffset, 0), yearChange, ticks);
}
function getIntervalLowestGranularityFormat(value, ticks) {
  if (value < durationSecond) {
    return 0 /* MILLISECOND */;
  } else if (value < durationMinute) {
    return 1 /* SECOND */;
  } else if (value < durationHour) {
    return 2 /* MINUTE */;
  } else if (value < durationDay) {
    return 3 /* HOUR */;
  } else if (value < durationWeek) {
    return 4 /* WEEK_DAY */;
  } else if (value < durationDay * 28 || value < durationDay * 31 && hasDuplicateMonth(ticks)) {
    return 5 /* SHORT_MONTH */;
  } else if (value < durationYear) {
    return 6 /* MONTH */;
  }
  return 7 /* YEAR */;
}
function getLowestGranularityFormat(value) {
  if (second_default.floor(value) < value) {
    return 0 /* MILLISECOND */;
  } else if (minute_default.floor(value) < value) {
    return 1 /* SECOND */;
  } else if (hour_default.floor(value) < value) {
    return 2 /* MINUTE */;
  } else if (day_default.floor(value) < value) {
    return 3 /* HOUR */;
  } else if (month_default.floor(value) < value) {
    if (week_default.floor(value) < value) {
      return 4 /* WEEK_DAY */;
    }
    return 5 /* SHORT_MONTH */;
  } else if (year_default.floor(value) < value) {
    return 6 /* MONTH */;
  }
  return 7 /* YEAR */;
}
function hasDuplicateMonth(ticks) {
  let prevMonth = new Date(ticks[0]).getMonth();
  for (let i = 1; i < ticks.length; i++) {
    const tickMonth = new Date(ticks[i]).getMonth();
    if (prevMonth === tickMonth) {
      return true;
    }
    prevMonth = tickMonth;
  }
  return false;
}
function formatStringBuilder(defaultTimeFormat, yearChange, ticks) {
  const firstTick = dateToNumber(ticks[0]);
  const lastTick = dateToNumber(ticks.at(-1));
  const extent2 = Math.abs(lastTick - firstTick);
  const activeYear = yearChange || defaultTimeFormat === 7 /* YEAR */;
  const activeDate = extent2 === 0;
  const parts = [
    ["hour", 6 * durationHour, 14 * durationDay, 3 /* HOUR */, "%I %p"],
    ["hour", durationMinute, 6 * durationHour, 3 /* HOUR */, "%I:%M"],
    ["second", 1e3, 6 * durationHour, 1 /* SECOND */, ":%S"],
    ["ms", 0, 6 * durationHour, 0 /* MILLISECOND */, ".%L"],
    ["am/pm", durationMinute, 6 * durationHour, 3 /* HOUR */, "%p"],
    " ",
    ["day", durationDay, durationWeek, 4 /* WEEK_DAY */, "%a"],
    ["month", activeDate ? 0 : durationWeek, 52 * durationWeek, 5 /* SHORT_MONTH */, "%b %d"],
    ["month", 5 * durationWeek, 10 * durationYear, 6 /* MONTH */, "%B"],
    " ",
    ["year", activeYear ? 0 : durationYear, Infinity, 7 /* YEAR */, "%Y"]
  ];
  const formatParts = parts.filter((v) => {
    if (typeof v === "string") {
      return true;
    }
    const [_, min, max, format] = v;
    return format >= defaultTimeFormat && min <= extent2 && extent2 < max;
  }).reduce(
    (r, next) => {
      if (typeof next === "string") {
        r.result.push(next);
      } else if (!r.used.has(next[0])) {
        r.result.push(next);
        r.used.add(next[0]);
      }
      return r;
    },
    { result: [], used: /* @__PURE__ */ new Set() }
  ).result;
  const firstFormat = formatParts.findIndex((v) => typeof v !== "string");
  const lastFormat = formatParts.findLastIndex((v) => typeof v !== "string");
  return formatParts.slice(firstFormat, lastFormat + 1).map((v) => typeof v === "string" ? v : v[4]).join("").replaceAll(/\s+/g, " ").trim();
}

// packages/ag-charts-community/src/scale/bandScale.ts
var _BandScale = class _BandScale {
  constructor() {
    this.type = "band";
    this.invalid = true;
    this.range = [0, 1];
    this.round = false;
    this.interval = void 0;
    /**
     * Maps datum to its index in the {@link domain} array.
     * Used to check for duplicate data (not allowed).
     */
    this.index = /* @__PURE__ */ new Map();
    /**
     * The output range values for datum at each index.
     */
    this.ordinalRange = [];
    /**
     * Contains unique data only.
     */
    this._domain = [];
    this._bandwidth = 1;
    this._step = 1;
    this._inset = 1;
    this._rawBandwidth = 1;
    /**
     * The ratio of the range that is reserved for space between bands.
     */
    this._paddingInner = 0;
    /**
     * The ratio of the range that is reserved for space before the first
     * and after the last band.
     */
    this._paddingOuter = 0;
  }
  static is(value) {
    return value instanceof _BandScale;
  }
  refresh() {
    if (!this.invalid)
      return;
    this.invalid = false;
    this.update();
    if (this.invalid) {
      Logger.warnOnce("Expected update to not invalidate scale");
    }
  }
  set domain(values) {
    this.index = /* @__PURE__ */ new Map();
    this.invalid = true;
    this._domain = [];
    for (const value of values) {
      const key = dateToNumber(value);
      if (this.getIndex(key) === void 0) {
        this.index.set(key, this._domain.push(value) - 1);
      }
    }
  }
  get domain() {
    return this._domain;
  }
  getDomain() {
    return this._domain;
  }
  ticks() {
    this.refresh();
    return this._domain;
  }
  convert(d) {
    this.refresh();
    const i = this.getIndex(d);
    if (i == null) {
      return NaN;
    }
    return this.ordinalRange[i] ?? NaN;
  }
  invert(position) {
    this.refresh();
    const index = this.ordinalRange.findIndex((p) => p === position);
    return this.domain[index];
  }
  invertNearest(position) {
    this.refresh();
    let nearest = -1;
    let minDistance = Infinity;
    const index = this.ordinalRange.findIndex((p, i) => {
      if (p === position)
        return true;
      const distance3 = Math.abs(position - p);
      if (distance3 < minDistance) {
        minDistance = distance3;
        nearest = i;
      }
      return false;
    });
    return this.domain[index] ?? this.domain[nearest];
  }
  get bandwidth() {
    this.refresh();
    return this._bandwidth;
  }
  get step() {
    this.refresh();
    return this._step;
  }
  get inset() {
    this.refresh();
    return this._inset;
  }
  get rawBandwidth() {
    this.refresh();
    return this._rawBandwidth;
  }
  set padding(value) {
    value = clamp(0, value, 1);
    this._paddingInner = value;
    this._paddingOuter = value;
  }
  get padding() {
    return this._paddingInner;
  }
  set paddingInner(value) {
    this._paddingInner = clamp(0, value, 1);
  }
  get paddingInner() {
    return this._paddingInner;
  }
  set paddingOuter(value) {
    this._paddingOuter = clamp(0, value, 1);
  }
  get paddingOuter() {
    return this._paddingOuter;
  }
  update() {
    const count = this._domain.length;
    if (count === 0)
      return;
    const [r0, r1] = this.range;
    let { _paddingInner: paddingInner } = this;
    const { _paddingOuter: paddingOuter, round: round4 } = this;
    const rangeDistance = r1 - r0;
    let rawStep;
    if (count === 1) {
      paddingInner = 0;
      rawStep = rangeDistance * (1 - paddingOuter * 2);
    } else {
      rawStep = rangeDistance / Math.max(1, count - paddingInner + paddingOuter * 2);
    }
    const step = round4 ? Math.floor(rawStep) : rawStep;
    let inset = r0 + (rangeDistance - step * (count - paddingInner)) / 2;
    let bandwidth = step * (1 - paddingInner);
    if (round4) {
      inset = Math.round(inset);
      bandwidth = Math.round(bandwidth);
    }
    this._step = step;
    this._inset = inset;
    this._bandwidth = bandwidth;
    this._rawBandwidth = rawStep * (1 - paddingInner);
    this.ordinalRange = this._domain.map((_, i) => inset + step * i);
  }
  getIndex(value) {
    return this.index.get(value instanceof Date ? value.getTime() : value);
  }
};
__decorateClass([
  Invalidating
], _BandScale.prototype, "range", 2);
__decorateClass([
  Invalidating
], _BandScale.prototype, "round", 2);
__decorateClass([
  Invalidating
], _BandScale.prototype, "interval", 2);
var BandScale = _BandScale;

// packages/ag-charts-community/src/util/properties.ts
var BaseProperties = class {
  set(properties) {
    const { className = this.constructor.name } = this.constructor;
    if (typeof properties !== "object") {
      Logger.warn(`unable to set ${className} - expecting a properties object`);
      return this;
    }
    const keys = new Set(Object.keys(properties));
    for (const propertyKey of listDecoratedProperties(this)) {
      if (keys.has(propertyKey)) {
        const value = properties[propertyKey];
        const self = this;
        if (isProperties(self[propertyKey])) {
          if (self[propertyKey] instanceof PropertiesArray) {
            const array2 = self[propertyKey].reset(value);
            if (array2 != null) {
              self[propertyKey] = array2;
            } else {
              Logger.warn(`unable to set [${propertyKey}] - expecting a properties array`);
            }
          } else {
            self[propertyKey].set(value);
          }
        } else {
          self[propertyKey] = value;
        }
        keys.delete(propertyKey);
      }
    }
    for (const unknownKey of keys) {
      Logger.warn(`unable to set [${unknownKey}] in ${className} - property is unknown`);
    }
    return this;
  }
  isValid(warningPrefix) {
    return listDecoratedProperties(this).every((propertyKey) => {
      const { optional } = extractDecoratedPropertyMetadata(this, propertyKey);
      const valid = optional === true || typeof this[propertyKey] !== "undefined";
      if (!valid) {
        Logger.warnOnce(`${warningPrefix ?? ""}[${propertyKey}] is required.`);
      }
      return valid;
    });
  }
  toJson() {
    return listDecoratedProperties(this).reduce((object2, propertyKey) => {
      const propertyValue = this[propertyKey];
      object2[propertyKey] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;
      return object2;
    }, {});
  }
};
var PropertiesArray = class _PropertiesArray extends Array {
  constructor(itemFactory, ...properties) {
    super(properties.length);
    const isConstructor = (value2) => Boolean(value2?.prototype?.constructor?.name);
    const value = isConstructor(itemFactory) ? (params) => new itemFactory().set(params) : itemFactory;
    Object.defineProperty(this, "itemFactory", { value, enumerable: false, configurable: false });
    this.set(properties);
  }
  set(properties) {
    if (isArray(properties)) {
      this.length = properties.length;
      for (let i = 0; i < properties.length; i++) {
        this[i] = this.itemFactory(properties[i]);
      }
    }
    return this;
  }
  reset(properties) {
    if (Array.isArray(properties)) {
      return new _PropertiesArray(this.itemFactory, ...properties);
    }
  }
  toJson() {
    return this.map((value) => value?.toJson?.() ?? value);
  }
};
function isProperties(value) {
  return value instanceof BaseProperties || value instanceof PropertiesArray;
}

// packages/ag-charts-community/src/util/validation.ts
function Validate(predicate, options = {}) {
  const { optional = false, property: overrideProperty } = options;
  return addTransformToInstanceProperty(
    (target, property, value) => {
      const context = { ...options, target, property };
      if (optional && typeof value === "undefined" || predicate(value, context)) {
        if (isProperties(target[property]) && !isProperties(value)) {
          target[property].set(value);
          return target[property];
        }
        return value;
      }
      const cleanKey = overrideProperty ?? String(property).replace(/^_*/, "");
      const targetName = target.constructor.className ?? target.constructor.name.replace(/Properties$/, "");
      let valueString = stringify(value);
      const maxLength = 50;
      if (valueString != null && valueString.length > maxLength) {
        const excessCharacters = valueString.length - maxLength;
        valueString = valueString.slice(0, maxLength) + `... (+${excessCharacters} characters)`;
      }
      Logger.warn(
        `Property [${cleanKey}] of [${targetName}] cannot be set to [${valueString}]${predicate.message ? `; expecting ${getPredicateMessage(predicate, context)}` : ""}, ignoring.`
      );
      return BREAK_TRANSFORM_CHAIN;
    },
    void 0,
    { optional }
  );
}
var AND = (...predicates) => {
  const messages = [];
  return predicateWithMessage(
    (value, ctx) => {
      messages.length = 0;
      return predicates.every((predicate) => {
        const isValid2 = predicate(value, ctx);
        if (!isValid2) {
          messages.push(getPredicateMessage(predicate, ctx));
        }
        return isValid2;
      });
    },
    () => messages.filter(Boolean).join(" AND ")
  );
};
var OR = (...predicates) => predicateWithMessage(
  (value, ctx) => predicates.some((predicate) => predicate(value, ctx)),
  (ctx) => predicates.map(getPredicateMessageMapper(ctx)).filter(Boolean).join(" OR ")
);
var OBJECT = attachObjectRestrictions(
  predicateWithMessage(
    (value, ctx) => isProperties(value) || isObject(value) && isProperties(ctx.target[ctx.property]),
    "a properties object"
  )
);
var PLAIN_OBJECT = attachObjectRestrictions(predicateWithMessage((value) => isObject(value), "an object"));
var BOOLEAN = predicateWithMessage(isBoolean, "a boolean");
var FUNCTION = predicateWithMessage(isFunction, "a function");
var STRING = predicateWithMessage(isString, "a string");
var NUMBER = attachNumberRestrictions(predicateWithMessage(isFiniteNumber, "a number"));
var REAL_NUMBER = predicateWithMessage((value) => isNumber(value) && !isNaN(value), "a real number");
var NAN = predicateWithMessage((value) => isNumber(value) && isNaN(value), "NaN");
var POSITIVE_NUMBER = NUMBER.restrict({ min: 0 });
var RATIO = NUMBER.restrict({ min: 0, max: 1 });
var DEGREE = NUMBER.restrict({ min: -360, max: 360 });
var NUMBER_OR_NAN = OR(NUMBER, NAN);
var ARRAY = attachArrayRestrictions(predicateWithMessage(isArray, "an array"));
var ARRAY_OF = (predicate, message) => predicateWithMessage(
  (value, ctx) => isArray(value) && value.every((item) => predicate(item, ctx)),
  (ctx) => {
    const arrayMessage = getPredicateMessage(ARRAY, ctx) ?? "";
    return message ? `${arrayMessage} of ${message}` : arrayMessage;
  }
);
var isComparable = (value) => isFiniteNumber(value) || isValidDate(value);
var LESS_THAN = (otherField) => predicateWithMessage(
  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v < ctx.target[otherField],
  `to be less than ${otherField}`
);
var GREATER_THAN = (otherField) => predicateWithMessage(
  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v > ctx.target[otherField],
  `to be greater than ${otherField}`
);
var DATE = predicateWithMessage(isValidDate, "Date object");
var DATE_OR_DATETIME_MS = OR(DATE, POSITIVE_NUMBER);
var colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;
var COLOR_STRING = predicateWithMessage(
  (v) => isString(v) && Color.validColorString(v),
  `color String. ${colorMessage}`
);
var COLOR_STRING_ARRAY = predicateWithMessage(ARRAY_OF(COLOR_STRING), `color strings. ${colorMessage}`);
var BOOLEAN_ARRAY = ARRAY_OF(BOOLEAN, "boolean values");
var NUMBER_ARRAY = ARRAY_OF(NUMBER, "numbers");
var STRING_ARRAY = ARRAY_OF(STRING, "strings");
var DATE_ARRAY = predicateWithMessage(ARRAY_OF(DATE), "Date objects");
var OBJECT_ARRAY = predicateWithMessage(ARRAY_OF(OBJECT), "objects");
var LINE_CAP = UNION(["butt", "round", "square"], "a line cap");
var LINE_JOIN = UNION(["round", "bevel", "miter"], "a line join");
var LINE_STYLE = UNION(["solid", "dashed", "dotted"], "a line style");
var LINE_DASH = predicateWithMessage(
  ARRAY_OF(POSITIVE_NUMBER),
  "numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels."
);
var POSITION = UNION(["top", "right", "bottom", "left"], "a position");
var FONT_STYLE = UNION(["normal", "italic", "oblique"], "a font style");
var FONT_WEIGHT = OR(
  UNION(["normal", "bold", "bolder", "lighter"], "a font weight"),
  NUMBER.restrict({ min: 1, max: 1e3 })
);
var TEXT_WRAP = UNION(["never", "always", "hyphenate", "on-space"], "a text wrap strategy");
var TEXT_ALIGN = UNION(["left", "center", "right"], "a text align");
var VERTICAL_ALIGN = UNION(["top", "middle", "bottom"], "a vertical align");
var OVERFLOW_STRATEGY = UNION(["ellipsis", "hide"], "an overflow strategy");
var DIRECTION = UNION(["horizontal", "vertical"], "a direction");
var PLACEMENT = UNION(["inside", "outside"], "a placement");
var INTERACTION_RANGE = OR(UNION(["exact", "nearest"], "interaction range"), NUMBER);
var LABEL_PLACEMENT = UNION(["top", "bottom", "left", "right"]);
function UNION(options, message = "a") {
  return predicateWithMessage(
    (v, ctx) => {
      const option = options.find((o) => {
        const value = typeof o === "string" ? o : o.value;
        return v === value;
      });
      if (option == null)
        return false;
      if (typeof option !== "string" && (option.deprecated === true || option.deprecatedTo != null)) {
        const messages = [`Property [%s] with value '${option.value}' is deprecated.`];
        if (option.deprecatedTo) {
          messages.push(`Use ${option.deprecatedTo} instead.`);
        }
        Logger.warnOnce(messages.join(" "), ctx.property);
      }
      return true;
    },
    `${message} keyword such as ${joinUnionOptions(options)}`
  );
}
var MIN_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), LESS_THAN("maxSpacing")), NAN);
var MAX_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), GREATER_THAN("minSpacing")), NAN);
function predicateWithMessage(predicate, message) {
  predicate.message = message;
  return predicate;
}
function joinUnionOptions(options) {
  const values = options.filter((option) => typeof option === "string" || option.undocumented !== true).map((option) => `'${typeof option === "string" ? option : option.value}'`);
  if (values.length === 1) {
    return values[0];
  }
  const lastValue = values.pop();
  return `${values.join(", ")} or ${lastValue}`;
}
function getPredicateMessage(predicate, ctx) {
  return isFunction(predicate.message) ? predicate.message(ctx) : predicate.message;
}
function getPredicateMessageMapper(ctx) {
  return (predicate) => getPredicateMessage(predicate, ctx);
}
function attachArrayRestrictions(predicate) {
  return Object.assign(predicate, {
    restrict({ length: length2, minLength } = {}) {
      let message = "an array";
      if (isNumber(minLength) && minLength > 0) {
        message = "a non-empty array";
      } else if (isNumber(length2)) {
        message = `an array of length ${length2}`;
      }
      return predicateWithMessage(
        (value) => isArray(value) && (isNumber(length2) ? value.length === length2 : true) && (isNumber(minLength) ? value.length >= minLength : true),
        message
      );
    }
  });
}
function attachNumberRestrictions(predicate) {
  return Object.assign(predicate, {
    restrict({ min, max } = {}) {
      const message = ["a number"];
      const hasMin = isNumber(min);
      const hasMax = isNumber(max);
      if (hasMin && hasMax) {
        message.push(`between ${min} and ${max} inclusive`);
      } else if (hasMin) {
        message.push(`greater than or equal to ${min}`);
      } else if (hasMax) {
        message.push(`less than or equal to ${max}`);
      }
      return predicateWithMessage(
        (value) => isFiniteNumber(value) && (hasMin ? value >= min : true) && (hasMax ? value <= max : true),
        message.join(" ")
      );
    }
  });
}
function attachObjectRestrictions(predicate) {
  return Object.assign(predicate, {
    restrict(objectType) {
      return predicateWithMessage(
        (value) => value instanceof objectType,
        (ctx) => getPredicateMessage(predicate, ctx) ?? `an instance of ${objectType.name}`
      );
    }
  });
}
function stringify(value) {
  if (typeof value === "number") {
    if (isNaN(value))
      return "NaN";
    if (value === Infinity)
      return "Infinity";
    if (value === -Infinity)
      return "-Infinity";
  }
  return JSON.stringify(value);
}

// packages/ag-charts-community/src/chart/chartAxisDirection.ts
var ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection2) => {
  ChartAxisDirection2["X"] = "x";
  ChartAxisDirection2["Y"] = "y";
  return ChartAxisDirection2;
})(ChartAxisDirection || {});

// packages/ag-charts-community/src/module/moduleMap.ts
var ModuleMap = class {
  constructor() {
    this.moduleMap = /* @__PURE__ */ new Map();
  }
  *modules() {
    for (const m of this.moduleMap.values()) {
      yield m.moduleInstance;
    }
  }
  addModule(module2, moduleFactory) {
    if (this.moduleMap.has(module2.optionsKey)) {
      throw new Error(`AG Charts - module already initialised: ${module2.optionsKey}`);
    }
    this.moduleMap.set(module2.optionsKey, { module: module2, moduleInstance: moduleFactory(module2) });
  }
  removeModule(module2) {
    const moduleKey = isString(module2) ? module2 : module2.optionsKey;
    this.moduleMap.get(moduleKey)?.moduleInstance.destroy();
    this.moduleMap.delete(moduleKey);
  }
  getModule(module2) {
    return this.moduleMap.get(isString(module2) ? module2 : module2.optionsKey)?.moduleInstance;
  }
  isEnabled(module2) {
    return this.moduleMap.has(isString(module2) ? module2 : module2.optionsKey);
  }
  mapModules(callback2) {
    return Array.from(this.moduleMap.values(), (m, i) => callback2(m.moduleInstance, i));
  }
  destroy() {
    for (const moduleKey of this.moduleMap.keys()) {
      this.moduleMap.get(moduleKey)?.moduleInstance.destroy();
    }
    this.moduleMap.clear();
  }
};

// packages/ag-charts-community/src/motion/resetMotion.ts
function resetMotion(selectionsOrNodes, propsFn) {
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  for (const selection of selections) {
    for (const node of selection.nodes()) {
      const from2 = propsFn(node, node.datum);
      node.setProperties(from2);
    }
    selection.cleanup();
  }
  for (const node of nodes) {
    const from2 = propsFn(node, node.datum);
    node.setProperties(from2);
  }
}

// packages/ag-charts-community/src/util/numberFormat.ts
function parseFormat(format) {
  let prefix;
  let suffix;
  const surrounded = surroundedRegEx.exec(format);
  if (surrounded) {
    [, prefix, format, suffix] = surrounded;
  }
  const match = formatRegEx.exec(format);
  if (!match) {
    throw new Error(`The number formatter is invalid: ${format}`);
  }
  const [, fill, align, sign, symbol, zero, width, comma, precision, trim, type] = match;
  return {
    fill,
    align,
    sign,
    symbol,
    zero,
    width: parseInt(width),
    comma,
    precision: parseInt(precision),
    trim: Boolean(trim),
    type,
    prefix,
    suffix
  };
}
function numberFormat(format) {
  const options = typeof format === "string" ? parseFormat(format) : format;
  const { fill, align, sign = "-", symbol, zero, width, comma, type, prefix = "", suffix = "", precision } = options;
  let { trim } = options;
  const precisionIsNaN = precision == null || isNaN(precision);
  let formatBody;
  if (!type) {
    formatBody = decimalTypes["g"];
    trim = true;
  } else if (type in decimalTypes && type in integerTypes) {
    formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];
  } else if (type in decimalTypes) {
    formatBody = decimalTypes[type];
  } else if (type in integerTypes) {
    formatBody = integerTypes[type];
  } else {
    throw new Error(`The number formatter type is invalid: ${type}`);
  }
  let formatterPrecision;
  if (precision == null || precisionIsNaN) {
    formatterPrecision = type ? 6 : 12;
  } else {
    formatterPrecision = precision;
  }
  return (n) => {
    let result = formatBody(n, formatterPrecision);
    if (trim) {
      result = removeTrailingZeros(result);
    }
    if (comma) {
      result = insertSeparator(result, comma);
    }
    result = addSign(n, result, sign);
    if (symbol && symbol !== "#") {
      result = `${symbol}${result}`;
    }
    if (symbol === "#" && type === "x") {
      result = `0x${result}`;
    }
    if (type === "s") {
      result = `${result}${getSIPrefix(n)}`;
    }
    if (type === "%" || type === "p") {
      result = `${result}%`;
    }
    if (width != null && !isNaN(width)) {
      result = addPadding(result, width, fill ?? zero, align);
    }
    result = `${prefix}${result}${suffix}`;
    return result;
  };
}
var formatRegEx = /^(?:(.)?([<>=^]))?([+\-( ])?([$€£¥₣₹#])?(0)?(\d+)?(,)?(?:\.(\d+))?(~)?([%a-z])?$/i;
var surroundedRegEx = /^((?:[^#]|#[^{])*)#{([^}]+)}(.*)$/;
var integerTypes = {
  b: (n) => absFloor(n).toString(2),
  c: (n) => String.fromCharCode(n),
  d: (n) => Math.round(Math.abs(n)).toFixed(0),
  o: (n) => absFloor(n).toString(8),
  x: (n) => absFloor(n).toString(16),
  X: (n) => integerTypes.x(n).toUpperCase(),
  n: (n) => integerTypes.d(n),
  "%": (n) => `${absFloor(n * 100).toFixed(0)}`
};
var decimalTypes = {
  e: (n, f) => Math.abs(n).toExponential(f),
  E: (n, f) => decimalTypes.e(n, f).toUpperCase(),
  f: (n, f) => Math.abs(n).toFixed(f),
  F: (n, f) => decimalTypes.f(n, f).toUpperCase(),
  g: (n, f) => {
    if (n === 0) {
      return "0";
    }
    const a = Math.abs(n);
    const p = Math.floor(Math.log10(a));
    if (p >= -4 && p < f) {
      return a.toFixed(f - 1 - p);
    }
    return a.toExponential(f - 1);
  },
  G: (n, f) => decimalTypes.g(n, f).toUpperCase(),
  n: (n, f) => decimalTypes.g(n, f),
  p: (n, f) => decimalTypes.r(n * 100, f),
  r: (n, f) => {
    if (n === 0) {
      return "0";
    }
    const a = Math.abs(n);
    const p = Math.floor(Math.log10(a));
    const q = p - (f - 1);
    if (q <= 0) {
      return a.toFixed(-q);
    }
    const x = 10 ** q;
    return (Math.round(a / x) * x).toFixed();
  },
  s: (n, f) => {
    const p = getSIPrefixPower(n);
    return decimalTypes.r(n / 10 ** p, f);
  },
  "%": (n, f) => decimalTypes.f(n * 100, f)
};
var minSIPrefix = -24;
var maxSIPrefix = 24;
var siPrefixes = {
  [minSIPrefix]: "y",
  [-21]: "z",
  [-18]: "a",
  [-15]: "f",
  [-12]: "p",
  [-9]: "n",
  [-6]: "\xB5",
  [-3]: "m",
  [0]: "",
  [3]: "k",
  [6]: "M",
  [9]: "G",
  [12]: "T",
  [15]: "P",
  [18]: "E",
  [21]: "Z",
  [maxSIPrefix]: "Y"
};
var minusSign = "\u2212";
function absFloor(n) {
  return Math.floor(Math.abs(n));
}
function removeTrailingZeros(numString) {
  return numString.replace(/\.0+$/, "").replace(/(\.[1-9])0+$/, "$1");
}
function insertSeparator(numString, separator) {
  let dotIndex = numString.indexOf(".");
  if (dotIndex < 0) {
    dotIndex = numString.length;
  }
  const integerChars = numString.substring(0, dotIndex).split("");
  const fractionalPart = numString.substring(dotIndex);
  for (let i = integerChars.length - 3; i > 0; i -= 3) {
    integerChars.splice(i, 0, separator);
  }
  return `${integerChars.join("")}${fractionalPart}`;
}
function getSIPrefix(n) {
  return siPrefixes[getSIPrefixPower(n)];
}
function getSIPrefixPower(n) {
  return clamp(minSIPrefix, n ? Math.floor(Math.log10(Math.abs(n)) / 3) * 3 : 0, maxSIPrefix);
}
function addSign(num, numString, signType = "") {
  if (signType === "(") {
    return num >= 0 ? numString : `(${numString})`;
  }
  const plusSign = signType === "+" ? "+" : "";
  return `${num >= 0 ? plusSign : minusSign}${numString}`;
}
function addPadding(numString, width, fill = " ", align = ">") {
  let result = numString;
  if (align === ">" || !align) {
    result = result.padStart(width, fill);
  } else if (align === "<") {
    result = result.padEnd(width, fill);
  } else if (align === "^") {
    const padWidth = Math.max(0, width - result.length);
    const padLeft = Math.ceil(padWidth / 2);
    const padRight = Math.floor(padWidth / 2);
    result = result.padStart(padLeft + result.length, fill);
    result = result.padEnd(padRight + result.length, fill);
  }
  return result;
}

// packages/ag-charts-community/src/util/time/millisecond.ts
function encode7(date) {
  return date.getTime();
}
function decode7(encoded) {
  return new Date(encoded);
}
var millisecond = new CountableTimeInterval(encode7, decode7);
var millisecond_default = millisecond;

// packages/ag-charts-community/src/util/ticks.ts
var tInterval = (timeInterval, baseDuration, step) => ({
  duration: baseDuration * step,
  timeInterval,
  step
});
var TickIntervals = [
  tInterval(second_default, durationSecond, 1),
  tInterval(second_default, durationSecond, 5),
  tInterval(second_default, durationSecond, 15),
  tInterval(second_default, durationSecond, 30),
  tInterval(minute_default, durationMinute, 1),
  tInterval(minute_default, durationMinute, 5),
  tInterval(minute_default, durationMinute, 15),
  tInterval(minute_default, durationMinute, 30),
  tInterval(hour_default, durationHour, 1),
  tInterval(hour_default, durationHour, 3),
  tInterval(hour_default, durationHour, 6),
  tInterval(hour_default, durationHour, 12),
  tInterval(day_default, durationDay, 1),
  tInterval(day_default, durationDay, 2),
  tInterval(week_default, durationWeek, 1),
  tInterval(week_default, durationWeek, 2),
  tInterval(week_default, durationWeek, 3),
  tInterval(month_default, durationMonth, 1),
  tInterval(month_default, durationMonth, 2),
  tInterval(month_default, durationMonth, 3),
  tInterval(month_default, durationMonth, 4),
  tInterval(month_default, durationMonth, 6),
  tInterval(year_default, durationYear, 1)
];
var TickMultipliers = [1, 2, 5, 10];
function isCloseToInteger(n, delta3) {
  return Math.abs(Math.round(n) - n) < delta3;
}
function createTicks(start, stop, count, minCount, maxCount) {
  if (count < 2) {
    return [start, stop];
  }
  const step = tickStep(start, stop, count, minCount, maxCount);
  if (!Number.isFinite(step)) {
    return [];
  }
  if (!isCloseToInteger(start / step, 1e-12)) {
    start = Math.ceil(start / step) * step;
  }
  if (!isCloseToInteger(stop / step, 1e-12)) {
    stop = Math.floor(stop / step) * step;
  }
  return range(start, stop, step);
}
function getTickInterval(start, stop, count, minCount, maxCount, targetInterval) {
  const target = targetInterval ?? Math.abs(stop - start) / Math.max(count, 1);
  let i = 0;
  for (const tickInterval of TickIntervals) {
    if (target <= tickInterval.duration)
      break;
    i++;
  }
  if (i === 0) {
    const step2 = Math.max(tickStep(start, stop, count, minCount, maxCount), 1);
    return millisecond_default.every(step2);
  } else if (i === TickIntervals.length) {
    const step2 = targetInterval == null ? tickStep(start / durationYear, stop / durationYear, count, minCount, maxCount) : 1;
    return year_default.every(step2);
  }
  const i0 = TickIntervals[i - 1];
  const i1 = TickIntervals[i];
  const { timeInterval, step } = target - i0.duration < i1.duration - target ? i0 : i1;
  return timeInterval.every(step);
}
function tickStep(start, end, count, minCount = 0, maxCount = Infinity) {
  if (start === end) {
    return clamp(1, minCount, maxCount);
  } else if (count < 1) {
    return NaN;
  }
  const extent2 = Math.abs(end - start);
  const step = 10 ** Math.floor(Math.log10(extent2 / count));
  let m = NaN, minDiff = Infinity, isInBounds = false;
  for (const multiplier of TickMultipliers) {
    const c = Math.ceil(extent2 / (multiplier * step));
    const validBounds = c >= minCount && c <= maxCount;
    if (isInBounds && !validBounds)
      continue;
    const diffCount = Math.abs(c - count);
    if (minDiff > diffCount || isInBounds !== validBounds) {
      isInBounds || (isInBounds = validBounds);
      minDiff = diffCount;
      m = multiplier;
    }
  }
  return m * step;
}
function decimalPlaces(decimal) {
  for (let i = decimal.length - 1; i >= 0; i -= 1) {
    if (decimal[i] !== "0") {
      return i + 1;
    }
  }
  return 0;
}
function tickFormat(ticks, format) {
  const options = parseFormat(format ?? ",f");
  if (options.precision == null || isNaN(options.precision)) {
    if (!options.type || "eEFgGnprs".includes(options.type)) {
      options.precision = Math.max(
        ...ticks.map((x) => {
          if (!Number.isFinite(x))
            return 0;
          const [integer, decimal] = x.toExponential((options.type ? 6 : 12) - 1).split(/\.|e/g);
          return (integer !== "1" && integer !== "-1" ? 1 : 0) + decimalPlaces(decimal) + 1;
        })
      );
    } else if ("f%".includes(options.type)) {
      options.precision = Math.max(
        ...ticks.map((x) => {
          if (!Number.isFinite(x) || x === 0)
            return 0;
          const l = Math.floor(Math.log10(Math.abs(x)));
          const digits = options.type ? 6 : 12;
          const decimal = x.toExponential(digits - 1).split(/\.|e/g)[1];
          const decimalLength = decimalPlaces(decimal);
          return Math.max(0, decimalLength - l);
        })
      );
    }
  }
  const formatter = numberFormat(options);
  return (n) => formatter(Number(n));
}
function range(start, end, step) {
  if (!Number.isFinite(step) || step <= 0)
    return [];
  const f = 10 ** countFractionDigits(step);
  const d0 = Math.min(start, end);
  const d1 = Math.max(start, end);
  const out = [];
  for (let i = 0; ; i += 1) {
    const p = Math.round((d0 + step * i) * f) / f;
    if (p <= d1) {
      out.push(p);
    } else {
      break;
    }
  }
  return out;
}
function isDenseInterval(count, availableRange) {
  if (count >= availableRange) {
    Logger.warnOnce(
      `the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration`
    );
    return true;
  }
  return false;
}
function niceTicksDomain(start, end) {
  const extent2 = Math.abs(end - start);
  const step = 10 ** Math.floor(Math.log10(extent2));
  let minError = Infinity, ticks = [start, end];
  for (const multiplier of TickMultipliers) {
    const m = multiplier * step;
    const d0 = Math.floor(start / m) * m;
    const d1 = Math.ceil(end / m) * m;
    const error = 1 - extent2 / Math.abs(d1 - d0);
    if (minError > error) {
      minError = error;
      ticks = [d0, d1];
    }
  }
  return ticks;
}

// packages/ag-charts-community/src/scale/logScale.ts
var _LogScale = class _LogScale extends ContinuousScale {
  constructor() {
    super([1, 10], [0, 1]);
    this.type = "log";
    this.base = 10;
    this.baseLog = identity;
    this.basePow = identity;
    this.log = (x) => {
      const start = Math.min(...this.domain);
      return start >= 0 ? this.baseLog(x) : -this.baseLog(-x);
    };
    this.pow = (x) => {
      const start = Math.min(...this.domain);
      return start >= 0 ? this.basePow(x) : -this.basePow(-x);
    };
    this.defaultClampMode = "clamped";
  }
  toDomain(d) {
    return d;
  }
  transform(x) {
    const start = Math.min(...this.domain);
    return start >= 0 ? Math.log(x) : -Math.log(-x);
  }
  transformInvert(x) {
    const start = Math.min(...this.domain);
    return start >= 0 ? Math.exp(x) : -Math.exp(-x);
  }
  refresh() {
    if (this.base <= 0) {
      this.base = 0;
      Logger.warnOnce("expecting a finite Number greater than to 0");
    }
    super.refresh();
  }
  update() {
    if (!this.domain || this.domain.length < 2) {
      return;
    }
    this.baseLog = _LogScale.getBaseLogMethod(this.base);
    this.basePow = _LogScale.getBasePowerMethod(this.base);
    if (this.nice) {
      this.updateNiceDomain();
    }
  }
  updateNiceDomain() {
    const [d0, d1] = this.domain;
    const roundStart = d0 > d1 ? Math.ceil : Math.floor;
    const roundStop = d0 > d1 ? Math.floor : Math.ceil;
    const n0 = this.pow(roundStart(this.log(d0)));
    const n1 = this.pow(roundStop(this.log(d1)));
    this.niceDomain = [n0, n1];
  }
  ticks() {
    const count = this.tickCount ?? 10;
    if (!this.domain || this.domain.length < 2 || count < 1) {
      return [];
    }
    this.refresh();
    const base = this.base;
    const [d0, d1] = this.getDomain();
    const start = Math.min(d0, d1);
    const stop = Math.max(d0, d1);
    let p0 = this.log(start);
    let p1 = this.log(stop);
    if (this.interval) {
      const inBounds = (tick) => tick >= start && tick <= stop;
      const step = Math.min(Math.abs(this.interval), Math.abs(p1 - p0));
      const ticks2 = range(p0, p1, step).map(this.pow).filter(inBounds);
      if (!isDenseInterval(ticks2.length, this.getPixelRange())) {
        return ticks2;
      }
    }
    const isBaseInteger = base % 1 === 0;
    const isDiffLarge = p1 - p0 >= count;
    if (!isBaseInteger || isDiffLarge) {
      return createTicks(p0, p1, Math.min(p1 - p0, count)).map(this.pow);
    }
    const ticks = [];
    const isPositive = start > 0;
    p0 = Math.floor(p0) - 1;
    p1 = Math.round(p1) + 1;
    const availableSpacing = findRangeExtent(this.range) / count;
    let lastTickPosition = Infinity;
    for (let p = p0; p <= p1; p++) {
      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));
      for (let k = 1; k < base; k++) {
        const q = isPositive ? k : base - k + 1;
        const t = this.pow(p) * q;
        const tickPosition = this.convert(t);
        const prevSpacing = Math.abs(lastTickPosition - tickPosition);
        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);
        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;
        if (t >= start && t <= stop && (k === 1 || fits || ticks.length === 0)) {
          ticks.push(t);
          lastTickPosition = tickPosition;
        }
      }
    }
    return ticks;
  }
  tickFormat({
    count,
    ticks,
    specifier
  }) {
    if (count !== Infinity && ticks == null) {
      this.ticks();
    }
    specifier ?? (specifier = this.base === 10 ? ".0e" : ",");
    return isString(specifier) ? numberFormat(specifier) : specifier;
  }
  static getBaseLogMethod(base) {
    switch (base) {
      case 10:
        return Math.log10;
      case Math.E:
        return Math.log;
      case 2:
        return Math.log2;
      default:
        return (x) => Math.log(x) / Math.log(base);
    }
  }
  static getBasePowerMethod(base) {
    switch (base) {
      case 10:
        return (x) => x >= 0 ? 10 ** x : 1 / 10 ** -x;
      case Math.E:
        return Math.exp;
      default:
        return (x) => base ** x;
    }
  }
};
__decorateClass([
  Invalidating
], _LogScale.prototype, "base", 2);
var LogScale = _LogScale;

// packages/ag-charts-community/src/scale/timeScale.ts
var TimeScale = class _TimeScale extends ContinuousScale {
  constructor() {
    super([], [0, 1]);
    this.type = "time";
  }
  toDomain(d) {
    return new Date(d);
  }
  convert(x, opts) {
    return super.convert(new Date(x), opts);
  }
  invert(y) {
    return new Date(super.invert(y));
  }
  /**
   * Returns uniformly-spaced dates that represent the scale's domain.
   */
  ticks() {
    if (!this.domain || this.domain.length < 2) {
      return [];
    }
    this.refresh();
    const { interval, nice, tickCount, minTickCount, maxTickCount } = this;
    const [start, stop] = findMinMax(this.getDomain().map(dateToNumber));
    if (interval != null) {
      return _TimeScale.getTicksForInterval({ start, stop, interval, availableRange: this.getPixelRange() }) ?? _TimeScale.getDefaultTicks({ start, stop, tickCount, minTickCount, maxTickCount });
    } else if (nice && tickCount === 2) {
      return this.niceDomain;
    } else if (nice && tickCount === 1) {
      return this.niceDomain.slice(0, 1);
    }
    return _TimeScale.getDefaultTicks({ start, stop, tickCount, minTickCount, maxTickCount });
  }
  static getDefaultTicks({
    start,
    stop,
    tickCount,
    minTickCount,
    maxTickCount
  }) {
    const t = getTickInterval(start, stop, tickCount, minTickCount, maxTickCount);
    return t ? t.range(new Date(start), new Date(stop)) : [];
  }
  static getTicksForInterval({
    start,
    stop,
    interval,
    availableRange
  }) {
    if (!interval) {
      return [];
    }
    if (interval instanceof TimeInterval) {
      const ticks2 = interval.range(new Date(start), new Date(stop));
      if (isDenseInterval(ticks2.length, availableRange)) {
        return;
      }
      return ticks2;
    }
    const absInterval = Math.abs(interval);
    if (isDenseInterval((stop - start) / absInterval, availableRange))
      return;
    const timeInterval = TickIntervals.findLast((tickInterval) => absInterval % tickInterval.duration === 0);
    if (timeInterval) {
      const i = timeInterval.timeInterval.every(absInterval / (timeInterval.duration / timeInterval.step));
      return i.range(new Date(start), new Date(stop));
    }
    let date = new Date(start);
    const stopDate = new Date(stop);
    const ticks = [];
    while (date <= stopDate) {
      ticks.push(date);
      date = new Date(date);
      date.setMilliseconds(date.getMilliseconds() + absInterval);
    }
    return ticks;
  }
  /**
   * Returns a time format function suitable for displaying tick values.
   *
   * @param ticks Optional array of tick values for custom formatting.
   * @param domain Optional array representing the [min, max] values of the time axis.
   * @param specifier Optional format specifier string for custom date formatting (e.g., `%Y`, `%m`, `%d`).
   * @param formatOffset Optional number for applying an offset to the format (e.g., timezone shifts).
   * @returns A function that formats a `Date` object into a string based on the provided specifier or default format.
   */
  tickFormat({
    ticks,
    domain,
    specifier,
    formatOffset
  }) {
    return specifier == null ? defaultTimeTickFormat(ticks, domain, formatOffset) : buildFormatter(specifier);
  }
  update() {
    if (!this.domain || this.domain.length < 2) {
      return;
    }
    if (this.nice) {
      this.updateNiceDomain();
    }
  }
  /**
   * Extends the domain so that it starts and ends on nice round values.
   * This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value.
   */
  updateNiceDomain() {
    const maxAttempts = 4;
    let [d0, d1] = this.domain;
    for (let i = 0; i < maxAttempts; i++) {
      this.updateNiceDomainIteration(d0, d1);
      const [n0, n1] = this.niceDomain;
      if (dateToNumber(d0) === dateToNumber(n0) && dateToNumber(d1) === dateToNumber(n1)) {
        break;
      }
      d0 = n0;
      d1 = n1;
    }
  }
  updateNiceDomainIteration(d0, d1) {
    const start = Math.min(dateToNumber(d0), dateToNumber(d1));
    const stop = Math.max(dateToNumber(d0), dateToNumber(d1));
    const isReversed = d0 > d1;
    const { interval } = this;
    let i;
    if (interval instanceof TimeInterval) {
      i = interval;
    } else {
      const tickCount = typeof interval === "number" ? (stop - start) / Math.max(interval, 1) : this.tickCount;
      i = getTickInterval(start, stop, tickCount, this.minTickCount, this.maxTickCount);
    }
    if (i) {
      const intervalRange = i.range(new Date(start), new Date(stop), true);
      const domain = isReversed ? [...intervalRange].reverse() : intervalRange;
      const n0 = domain[0];
      const n1 = domain.at(-1);
      this.niceDomain = [n0, n1];
    }
  }
};

// packages/ag-charts-community/src/scale/ordinalTimeScale.ts
function compareNumbers(a, b) {
  return a - b;
}
var _OrdinalTimeScale = class _OrdinalTimeScale extends BandScale {
  constructor() {
    super(...arguments);
    this.type = "ordinal-time";
    this.tickCount = ContinuousScale.defaultTickCount;
    this.minTickCount = 0;
    this.maxTickCount = Infinity;
    this.interval = void 0;
    this._domain = [];
    this.timestamps = [];
    this.sortedTimestamps = [];
    this.visibleRange = [0, 1];
  }
  static is(value) {
    return value instanceof _OrdinalTimeScale;
  }
  setVisibleRange(visibleRange) {
    this.visibleRange = visibleRange;
  }
  set domain(values) {
    this.invalid = true;
    if (values.length === 0) {
      this._domain = [];
      return;
    }
    this._domain = values;
    this.timestamps = unique(values.map(dateToNumber));
    this.sortedTimestamps = this.timestamps.slice().sort(compareNumbers);
  }
  get domain() {
    return this._domain;
  }
  ticks() {
    this.refresh();
    const [t0, t1] = [this.timestamps[0], this.timestamps.at(-1)];
    const start = Math.min(t0, t1);
    const stop = Math.max(t0, t1);
    const isReversed = t0 > t1;
    let ticks;
    if (this.interval == null) {
      ticks = this.getDefaultTicks(this.maxTickCount, isReversed);
    } else {
      const [r0, r1] = this.range;
      const availableRange = Math.abs(r1 - r0);
      ticks = TimeScale.getTicksForInterval({ start, stop, interval: this.interval, availableRange }) ?? [];
    }
    const tickPositions = /* @__PURE__ */ new Set();
    return ticks.filter((tick) => {
      const position = this.convert(tick);
      if (isNaN(position) || tickPositions.has(position)) {
        return false;
      }
      tickPositions.add(position);
      return true;
    });
  }
  getDefaultTicks(maxTickCount, isReversed) {
    const ticks = [];
    const count = this.timestamps.length;
    const tickEvery = Math.ceil(count * (this.visibleRange[1] - this.visibleRange[0]) / maxTickCount);
    const tickOffset = Math.floor(tickEvery / 2);
    for (const [index, value] of this.timestamps.entries()) {
      if (tickEvery > 0 && (index + tickOffset) % tickEvery)
        continue;
      if (isReversed) {
        ticks.push(new Date(this.timestamps[count - index - 1]));
      } else {
        ticks.push(new Date(value));
      }
    }
    return ticks;
  }
  convert(d) {
    this.refresh();
    const n = Number(d);
    if (n < this.sortedTimestamps[0]) {
      return NaN;
    }
    let i = this.findInterval(n);
    if (this.timestamps[0] !== this.sortedTimestamps[0]) {
      i = this.timestamps.length - i - 1;
    }
    return this.ordinalRange[i] ?? NaN;
  }
  findInterval(target) {
    const { sortedTimestamps } = this;
    let low = 0;
    let high = sortedTimestamps.length - 1;
    while (low <= high) {
      const mid = Math.floor((low + high) / 2);
      if (sortedTimestamps[mid] === target) {
        return mid;
      } else if (sortedTimestamps[mid] < target) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return low;
  }
  /**
   * Returns a time format function suitable for displaying tick values.
   * @param specifier If the specifier string is provided, this method is equivalent to
   * the {@link TimeLocaleObject.format} method.
   * If no specifier is provided, this method returns the default time format function.
   */
  tickFormat({
    ticks,
    domain,
    specifier
  }) {
    return specifier == null ? defaultTimeTickFormat(ticks, domain) : buildFormatter(specifier);
  }
  invert(position) {
    this.refresh();
    const index = this.ordinalRange.findIndex((p) => position <= p);
    return this.domain[index];
  }
  invertNearest(y) {
    return new Date(super.invertNearest(y));
  }
};
__decorateClass([
  Invalidating
], _OrdinalTimeScale.prototype, "tickCount", 2);
__decorateClass([
  Invalidating
], _OrdinalTimeScale.prototype, "minTickCount", 2);
__decorateClass([
  Invalidating
], _OrdinalTimeScale.prototype, "maxTickCount", 2);
__decorateClass([
  Invalidating
], _OrdinalTimeScale.prototype, "interval", 2);
var OrdinalTimeScale = _OrdinalTimeScale;

// packages/ag-charts-community/src/util/compare.ts
function ascendingStringNumberUndefined(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return a - b;
  } else if (typeof a === "string" && typeof b === "string") {
    return a.localeCompare(b);
  } else if (a == null && b == null) {
    return 0;
  } else if (a == null) {
    return -1;
  } else if (b == null) {
    return 1;
  }
  return String(a).localeCompare(String(b));
}
function toLiteral(v) {
  return typeof v === "function" ? v() : v;
}
function compoundAscending(a, b, comparator) {
  for (const idx in a) {
    const diff2 = comparator(toLiteral(a[idx]), toLiteral(b[idx]));
    if (diff2 !== 0) {
      return diff2;
    }
  }
  return 0;
}

// packages/ag-charts-community/src/scene/debug.util.ts
function nodeCount(node) {
  let count = 1;
  let visibleCount = node.visible ? 1 : 0;
  let dirtyCount = node.dirty > 0 /* NONE */ ? 1 : 0;
  for (const child of node.children(false)) {
    const c = nodeCount(child);
    count += c.count;
    dirtyCount += c.dirtyCount;
    visibleCount += c.visibleCount;
  }
  return { count, visibleCount, dirtyCount };
}

// packages/ag-charts-community/src/scene/matrix.ts
var IDENTITY_MATRIX_ELEMENTS = Object.freeze([1, 0, 0, 1, 0, 0]);
function closeValue(val, ref, errorMargin = 1e-8) {
  return val === ref || Math.abs(ref - val) < errorMargin;
}
var _Matrix = class _Matrix {
  get e() {
    return [...this.elements];
  }
  constructor(elements2 = [...IDENTITY_MATRIX_ELEMENTS]) {
    this.elements = elements2;
  }
  setElements(elements2) {
    const e = this.elements;
    e[0] = elements2[0];
    e[1] = elements2[1];
    e[2] = elements2[2];
    e[3] = elements2[3];
    e[4] = elements2[4];
    e[5] = elements2[5];
    return this;
  }
  get identity() {
    const e = this.elements;
    return closeValue(e[0], 1) && closeValue(e[1], 0) && closeValue(e[2], 0) && closeValue(e[3], 1) && closeValue(e[4], 0) && closeValue(e[5], 0);
  }
  /**
   * Performs the AxB matrix multiplication and saves the result
   * to `C`, if given, or to `A` otherwise.
   */
  AxB(A, B, C) {
    const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];
    C = C ?? A;
    C[0] = a;
    C[1] = b;
    C[2] = c;
    C[3] = d;
    C[4] = e;
    C[5] = f;
  }
  /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns the current matrix.
   * @param other
   */
  multiplySelf(other) {
    this.AxB(this.elements, other.elements);
    return this;
  }
  /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns a new matrix.
   * @param other
   */
  multiply(other) {
    const elements2 = new Array(6);
    if (other instanceof _Matrix) {
      this.AxB(this.elements, other.elements, elements2);
    } else {
      this.AxB(this.elements, [other.a, other.b, other.c, other.d, other.e, other.f], elements2);
    }
    return new _Matrix(elements2);
  }
  preMultiplySelf(other) {
    this.AxB(other.elements, this.elements, this.elements);
    return this;
  }
  /**
   * Returns the inverse of this matrix as a new matrix.
   */
  inverse() {
    const el = this.elements;
    let a = el[0], b = el[1], c = el[2], d = el[3];
    const e = el[4], f = el[5];
    const rD = 1 / (a * d - b * c);
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    return new _Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);
  }
  /**
   * Save the inverse of this matrix to the given matrix.
   */
  inverseTo(other) {
    const el = this.elements;
    let a = el[0], b = el[1], c = el[2], d = el[3];
    const e = el[4], f = el[5];
    const rD = 1 / (a * d - b * c);
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);
    return this;
  }
  invertSelf() {
    const el = this.elements;
    let a = el[0], b = el[1], c = el[2], d = el[3];
    const e = el[4], f = el[5];
    const rD = 1 / (a * d - b * c);
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    el[0] = d;
    el[1] = -b;
    el[2] = -c;
    el[3] = a;
    el[4] = c * f - d * e;
    el[5] = b * e - a * f;
    return this;
  }
  transformPoint(x, y) {
    const e = this.elements;
    return {
      x: x * e[0] + y * e[2] + e[4],
      y: x * e[1] + y * e[3] + e[5]
    };
  }
  transformBBox(bbox, target) {
    const el = this.elements;
    const xx = el[0];
    const xy = el[1];
    const yx = el[2];
    const yy = el[3];
    const h_w = bbox.width * 0.5;
    const h_h = bbox.height * 0.5;
    const cx = bbox.x + h_w;
    const cy = bbox.y + h_h;
    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);
    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);
    target ?? (target = new BBox(0, 0, 0, 0));
    target.x = cx * xx + cy * yx + el[4] - w;
    target.y = cx * xy + cy * yy + el[5] - h;
    target.width = w + w;
    target.height = h + h;
    return target;
  }
  toContext(ctx) {
    if (this.identity) {
      return;
    }
    const e = this.elements;
    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);
  }
  static flyweight(sourceMatrix) {
    return _Matrix.instance.setElements(sourceMatrix.elements);
  }
  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {
    const sx = scalingX;
    const sy = scalingY;
    let scx;
    let scy;
    if (sx === 1 && sy === 1) {
      scx = 0;
      scy = 0;
    } else {
      scx = opts?.scalingCenterX ?? 0;
      scy = opts?.scalingCenterY ?? 0;
    }
    const r = rotation;
    const cos = Math.cos(r);
    const sin = Math.sin(r);
    let rcx;
    let rcy;
    if (r === 0) {
      rcx = 0;
      rcy = 0;
    } else {
      rcx = opts?.rotationCenterX ?? 0;
      rcy = opts?.rotationCenterY ?? 0;
    }
    const tx = translationX;
    const ty = translationY;
    const tx4 = scx * (1 - sx) - rcx;
    const ty4 = scy * (1 - sy) - rcy;
    matrix.setElements([
      cos * sx,
      sin * sx,
      -sin * sy,
      cos * sy,
      cos * tx4 - sin * ty4 + rcx + tx,
      sin * tx4 + cos * ty4 + rcy + ty
    ]);
    return matrix;
  }
  static fromContext(ctx) {
    const domMatrix = ctx.getTransform();
    return new _Matrix([domMatrix.a, domMatrix.b, domMatrix.c, domMatrix.d, domMatrix.e, domMatrix.f]);
  }
};
_Matrix.instance = new _Matrix();
var Matrix = _Matrix;

// packages/ag-charts-community/src/scene/transformable.ts
function isMatrixTransform(node) {
  return isMatrixTransformType(node.constructor);
}
var MATRIX_TRANSFORM_TYPE = Symbol("isMatrixTransform");
function isMatrixTransformType(cstr) {
  return cstr[MATRIX_TRANSFORM_TYPE] === true;
}
function MatrixTransform(Parent) {
  var _a, _b;
  const ParentNode = Parent;
  if (isMatrixTransformType(Parent)) {
    return Parent;
  }
  const TRANSFORM_MATRIX = Symbol("matrix_combined_transform");
  class MatrixTransformInternal extends ParentNode {
    constructor() {
      super(...arguments);
      this[_b] = new Matrix();
      this._dirtyTransform = true;
    }
    markDirtyTransform() {
      this._dirtyTransform = true;
      super.markDirty(3 /* MAJOR */);
    }
    updateMatrix(_matrix) {
    }
    computeTransformMatrix() {
      if (!this._dirtyTransform)
        return;
      this[TRANSFORM_MATRIX].setElements(IDENTITY_MATRIX_ELEMENTS);
      this.updateMatrix(this[TRANSFORM_MATRIX]);
      this._dirtyTransform = false;
    }
    toParent(bbox) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return bbox.clone();
      return this[TRANSFORM_MATRIX].transformBBox(bbox);
    }
    toParentPoint(x, y) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return { x, y };
      return this[TRANSFORM_MATRIX].transformPoint(x, y);
    }
    fromParent(bbox) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return bbox.clone();
      return this[TRANSFORM_MATRIX].inverse().transformBBox(bbox);
    }
    fromParentPoint(x, y) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return { x, y };
      return this[TRANSFORM_MATRIX].inverse().transformPoint(x, y);
    }
    computeBBox() {
      const bbox = super.computeBBox();
      if (!bbox)
        return bbox;
      return this.toParent(bbox);
    }
    computeBBoxWithoutTransforms() {
      return super.computeBBox();
    }
    pickNode(x, y, localCoords = false) {
      if (!localCoords) {
        ({ x, y } = this.fromParentPoint(x, y));
      }
      return super.pickNode(x, y);
    }
    render(renderCtx) {
      if (this._dirtyTransform) {
        this.computeTransformMatrix();
        if (!renderCtx.forceRender) {
          renderCtx = { ...renderCtx, forceRender: "dirtyTransform" };
        }
      }
      const matrix = this[TRANSFORM_MATRIX];
      let performRestore = false;
      if (!matrix.identity) {
        renderCtx.ctx.save();
        performRestore = true;
        matrix.toContext(renderCtx.ctx);
      }
      super.render(renderCtx);
      if (performRestore) {
        renderCtx.ctx.restore();
      }
    }
    toSVG() {
      const svg = super.toSVG();
      const matrix = this[TRANSFORM_MATRIX];
      if (matrix.identity || svg == null)
        return svg;
      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g.append(...svg.elements);
      const [a, b, c, d, e, f] = matrix.e;
      g.setAttribute("transform", `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
      return {
        elements: [g],
        defs: svg.defs
      };
    }
  }
  _a = MATRIX_TRANSFORM_TYPE, _b = TRANSFORM_MATRIX;
  MatrixTransformInternal[_a] = true;
  return MatrixTransformInternal;
}
function Rotatable(Parent) {
  var _a;
  const ParentNode = Parent;
  const ROTATABLE_MATRIX = Symbol("matrix_rotation");
  class RotatableInternal extends MatrixTransform(ParentNode) {
    constructor() {
      super(...arguments);
      this[_a] = new Matrix();
      this.rotationCenterX = null;
      this.rotationCenterY = null;
      this.rotation = 0;
    }
    updateMatrix(matrix) {
      super.updateMatrix(matrix);
      const { rotation, rotationCenterX, rotationCenterY } = this;
      if (rotation === 0)
        return;
      Matrix.updateTransformMatrix(this[ROTATABLE_MATRIX], 1, 1, rotation, 0, 0, {
        rotationCenterX,
        rotationCenterY
      });
      matrix.multiplySelf(this[ROTATABLE_MATRIX]);
    }
  }
  _a = ROTATABLE_MATRIX;
  __decorateClass([
    SceneChangeDetection({ type: "transform" })
  ], RotatableInternal.prototype, "rotationCenterX", 2);
  __decorateClass([
    SceneChangeDetection({ type: "transform" })
  ], RotatableInternal.prototype, "rotationCenterY", 2);
  __decorateClass([
    SceneChangeDetection({ type: "transform" })
  ], RotatableInternal.prototype, "rotation", 2);
  return RotatableInternal;
}
function Scalable(Parent) {
  var _a;
  const ParentNode = Parent;
  const SCALABLE_MATRIX = Symbol("matrix_scale");
  class ScalableInternal extends MatrixTransform(ParentNode) {
    constructor() {
      super(...arguments);
      this[_a] = new Matrix();
      this.scalingX = 1;
      this.scalingY = 1;
      this.scalingCenterX = null;
      this.scalingCenterY = null;
    }
    updateMatrix(matrix) {
      super.updateMatrix(matrix);
      const { scalingX, scalingY, scalingCenterX, scalingCenterY } = this;
      if (scalingX === 1 && scalingY === 1)
        return;
      Matrix.updateTransformMatrix(this[SCALABLE_MATRIX], scalingX, scalingY, 0, 0, 0, {
        scalingCenterX,
        scalingCenterY
      });
      matrix.multiplySelf(this[SCALABLE_MATRIX]);
    }
  }
  _a = SCALABLE_MATRIX;
  __decorateClass([
    SceneChangeDetection({ type: "transform" })
  ], ScalableInternal.prototype, "scalingX", 2);
  __decorateClass([
    SceneChangeDetection({ type: "transform" })
  ], ScalableInternal.prototype, "scalingY", 2);
  __decorateClass([
    SceneChangeDetection({ type: "transform" })
  ], ScalableInternal.prototype, "scalingCenterX", 2);
  __decorateClass([
    SceneChangeDetection({ type: "transform" })
  ], ScalableInternal.prototype, "scalingCenterY", 2);
  return ScalableInternal;
}
function Translatable(Parent) {
  var _a;
  const ParentNode = Parent;
  const TRANSLATABLE_MATRIX = Symbol("matrix_translation");
  class TranslatableInternal extends MatrixTransform(ParentNode) {
    constructor() {
      super(...arguments);
      this[_a] = new Matrix();
      this.translationX = 0;
      this.translationY = 0;
    }
    updateMatrix(matrix) {
      super.updateMatrix(matrix);
      const { translationX, translationY } = this;
      if (translationX === 0 && translationY === 0)
        return;
      Matrix.updateTransformMatrix(this[TRANSLATABLE_MATRIX], 1, 1, 0, translationX, translationY);
      matrix.multiplySelf(this[TRANSLATABLE_MATRIX]);
    }
  }
  _a = TRANSLATABLE_MATRIX;
  __decorateClass([
    SceneChangeDetection({ type: "transform" })
  ], TranslatableInternal.prototype, "translationX", 2);
  __decorateClass([
    SceneChangeDetection({ type: "transform" })
  ], TranslatableInternal.prototype, "translationY", 2);
  return TranslatableInternal;
}
var Transformable = class {
  /**
   * Converts a BBox from canvas coordinate space into the coordinate space of the given Node.
   */
  static fromCanvas(node, bbox) {
    const parents = [];
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        parents.unshift(parent);
      }
    }
    for (const parent of parents) {
      bbox = parent.fromParent(bbox);
    }
    if (isMatrixTransform(node)) {
      bbox = node.fromParent(bbox);
    }
    return bbox;
  }
  /**
   * Converts a Nodes BBox (or an arbitrary BBox if supplied) from local Node coordinate space
   * into the Canvas coordinate space.
   */
  static toCanvas(node, bbox) {
    if (bbox == null) {
      bbox = node.getBBox();
    } else if (isMatrixTransform(node)) {
      bbox = node.toParent(bbox);
    }
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        bbox = parent.toParent(bbox);
      }
    }
    return bbox;
  }
  /**
   * Converts a point from canvas coordinate space into the coordinate space of the given Node.
   */
  static fromCanvasPoint(node, x, y) {
    const parents = [];
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        parents.unshift(parent);
      }
    }
    for (const parent of parents) {
      ({ x, y } = parent.fromParentPoint(x, y));
    }
    if (isMatrixTransform(node)) {
      ({ x, y } = node.fromParentPoint(x, y));
    }
    return { x, y };
  }
  /**
   * Converts a point from a Nodes local coordinate space into the Canvas coordinate space.
   */
  static toCanvasPoint(node, x, y) {
    if (isMatrixTransform(node)) {
      ({ x, y } = node.toParentPoint(x, y));
    }
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        ({ x, y } = parent.toParentPoint(x, y));
      }
    }
    return { x, y };
  }
};

// packages/ag-charts-community/src/scene/group.ts
var _Group = class _Group extends Node {
  constructor(opts) {
    super(opts);
    this.opts = opts;
    this.opacity = 1;
    this.isContainerNode = true;
    this.zIndexSubOrder = opts?.zIndexSubOrder;
  }
  static is(value) {
    return value instanceof _Group;
  }
  static computeChildrenBBox(nodes, skipInvisible = true) {
    return BBox.merge(Node.extractBBoxes(nodes, skipInvisible));
  }
  static compareChildren(a, b) {
    return compoundAscending(
      [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.serialNumber],
      [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.serialNumber],
      ascendingStringNumberUndefined
    );
  }
  // We consider a group to be boundless, thus any point belongs to it.
  containsPoint(_x, _y) {
    return true;
  }
  computeBBox() {
    return _Group.computeChildrenBBox(this.children());
  }
  preRender() {
    const counts = super.preRender();
    counts.groups += 1;
    counts.nonGroups -= 1;
    return counts;
  }
  isDirty(renderCtx) {
    const { resized } = renderCtx;
    const { dirty, dirtyZIndex } = this;
    const isDirty = dirty >= 2 /* MINOR */ || dirtyZIndex || resized;
    let isChildDirty = isDirty;
    let isChildLayerDirty = false;
    for (const child of this.children()) {
      isChildDirty || (isChildDirty = child.layerManager == null && child.dirty >= 1 /* TRIVIAL */);
      isChildLayerDirty || (isChildLayerDirty = child.layerManager != null && child.dirty >= 1 /* TRIVIAL */);
      if (isChildDirty)
        break;
    }
    if (this.opts?.name) {
      this._debug?.({ name: this.opts.name, group: this, isDirty, isChildDirty, renderCtx });
    }
    return { isDirty, isChildDirty, isChildLayerDirty };
  }
  debugSkip(renderCtx) {
    if (renderCtx.stats && this.opts?.name) {
      this._debug?.({
        name: this.opts.name,
        group: this,
        result: "skipping",
        counts: nodeCount(this),
        renderCtx
      });
    }
  }
  render(renderCtx, skip) {
    if (skip) {
      return super.render(renderCtx);
    }
    const { opts: { name } = {}, _debug: debug3 } = this;
    const { isDirty, isChildDirty, isChildLayerDirty } = this.isDirty(renderCtx);
    const { ctx, stats } = renderCtx;
    let { forceRender } = renderCtx;
    if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {
      this.debugSkip(renderCtx);
      this.markClean({ recursive: false });
      return;
    }
    if (forceRender !== "dirtyTransform") {
      forceRender || (forceRender = this.dirtyZIndex);
    }
    ctx.globalAlpha *= this.opacity;
    if (this.dirtyZIndex) {
      this.sortChildren(_Group.compareChildren);
    }
    const children = this.sortedChildren();
    const clipBBox = this.renderClip(renderCtx) ?? renderCtx.clipBBox;
    const renderCtxChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox;
    this.renderChildren(children, renderCtxChanged ? { ...renderCtx, forceRender, clipBBox } : renderCtx);
    super.render(renderCtx);
    if (this.clipRect) {
      ctx.restore();
    }
    for (const child of this.virtualChildren()) {
      child.markClean({ recursive: "virtual" });
    }
    if (name && stats) {
      debug3?.({
        name,
        renderCtx,
        result: "rendered",
        skipped: stats.nodesSkipped,
        counts: nodeCount(this),
        group: this
      });
    }
  }
  sortedChildren() {
    let children = this.children();
    if (this.hasVirtualChildren()) {
      children = [...children].sort(_Group.compareChildren);
    }
    return children;
  }
  renderClip(renderCtx) {
    if (!this.clipRect)
      return;
    const { x, y, width, height } = this.clipRect;
    const { ctx } = renderCtx;
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, width, height);
    ctx.clip();
    this._debug?.(() => ({
      name: this.opts?.name,
      clipRect: this.clipRect,
      ctxTransform: ctx.getTransform(),
      renderCtx,
      group: this
    }));
    return Transformable.toCanvas(this, this.clipRect);
  }
  renderChildren(children, renderCtx) {
    const { ctx, forceRender, stats } = renderCtx;
    for (const child of children) {
      if (!child.visible || !this.visible) {
        child.markClean();
        if (stats) {
          stats.nodesSkipped += nodeCount(child).count;
        }
        continue;
      }
      if (!forceRender && child.dirty === 0 /* NONE */) {
        if (stats) {
          stats.nodesSkipped += nodeCount(child).count;
        }
        continue;
      }
      ctx.save();
      child.render(renderCtx);
      ctx.restore();
    }
  }
  /**
   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and
   * sets this group's clipRect to the transformed bbox.
   * @param bbox clipRect bbox in the canvas coordinate space.
   */
  setClipRect(bbox) {
    this.clipRect = bbox ? Transformable.fromCanvas(this, bbox) : void 0;
  }
  /**
   * Set the clip rect within the canvas coordinate space.
   * @param bbox clipRect bbox in the canvas coordinate space.
   */
  setClipRectCanvasSpace(bbox) {
    this.clipRect = bbox;
  }
  toSVG() {
    if (!this.visible)
      return;
    const defs = [];
    const elements2 = [];
    for (const child of this.sortedChildren()) {
      const svg = child.toSVG();
      if (svg != null) {
        elements2.push(...svg.elements);
        if (svg.defs != null) {
          defs.push(...svg.defs);
        }
      }
    }
    return { elements: elements2, defs };
  }
};
_Group.className = "Group";
__decorateClass([
  SceneChangeDetection({
    redraw: 3 /* MAJOR */,
    convertor: (v) => clamp(0, v, 1)
  })
], _Group.prototype, "opacity", 2);
var Group = _Group;
var ScalableGroup = class extends Scalable(Group) {
};
var RotatableGroup = class extends Rotatable(Group) {
};
var TranslatableGroup = class extends Translatable(Group) {
};
var TransformableGroup = class extends Rotatable(Translatable(Group)) {
};

// packages/ag-charts-community/src/util/debug.ts
var LONG_TIME_PERIOD_THRESHOLD = 2e3;
var timeOfLastLog = Date.now();
var logTimeGap = () => {
  const timeSinceLastLog = Date.now() - timeOfLastLog;
  if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {
    const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);
    Logger.log(`**** ${prettyDuration}s since last log message ****`);
  }
  timeOfLastLog = Date.now();
};
var Debug = {
  create(...debugSelectors) {
    const resultFn = (...logContent) => {
      if (Debug.check(...debugSelectors)) {
        if (typeof logContent[0] === "function") {
          logContent = toArray(logContent[0]());
        }
        logTimeGap();
        Logger.log(...logContent);
      }
    };
    return Object.assign(resultFn, { check: () => Debug.check(...debugSelectors) });
  },
  check(...debugSelectors) {
    if (debugSelectors.length === 0) {
      debugSelectors.push(true);
    }
    const chartDebug = toArray(getWindow("agChartsDebug"));
    return chartDebug.some((selector) => debugSelectors.includes(selector));
  }
};

// packages/ag-charts-community/src/scene/selection.ts
var Selection = class _Selection {
  constructor(parentNode, classOrFactory, autoCleanup = true) {
    this.parentNode = parentNode;
    this.autoCleanup = autoCleanup;
    this.garbageBin = /* @__PURE__ */ new Set();
    this._nodesMap = /* @__PURE__ */ new Map();
    this._nodes = [];
    this.data = [];
    this.debug = Debug.create(true, "scene", "scene:selections");
    this.nodeFactory = Object.prototype.isPrototypeOf.call(Node, classOrFactory) ? () => new classOrFactory() : classOrFactory;
  }
  static select(parent, classOrFactory, garbageCollection = true) {
    return new _Selection(parent, classOrFactory, garbageCollection);
  }
  static selectAll(parent, predicate) {
    const results = [];
    const traverse = (node) => {
      if (predicate(node)) {
        results.push(node);
      }
      for (const child of node.children()) {
        traverse(child);
      }
    };
    traverse(parent);
    return results;
  }
  static selectByClass(node, ...Classes) {
    return _Selection.selectAll(node, (n) => Classes.some((C) => n instanceof C));
  }
  static selectByTag(node, tag) {
    return _Selection.selectAll(node, (n) => n.tag === tag);
  }
  createNode(datum, initializer, idx) {
    const node = this.nodeFactory(datum);
    node.datum = datum;
    initializer?.(node);
    if (idx == null) {
      this._nodes.push(node);
    } else {
      this._nodes.splice(idx, 0, node);
    }
    this.parentNode.appendChild(node);
    return node;
  }
  /**
   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to
   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end
   * of the array.
   */
  update(data, initializer, getDatumId) {
    if (this.garbageBin.size > 0) {
      this.debug(`Selection - update() called with pending garbage: ${data}`);
    }
    if (getDatumId) {
      const dataMap = new Map(
        data.map((datum, idx) => [getDatumId(datum), [datum, idx]])
      );
      for (const [node, datumId] of this._nodesMap.entries()) {
        if (dataMap.has(datumId)) {
          const [newDatum] = dataMap.get(datumId);
          node.datum = newDatum;
          this.garbageBin.delete(node);
          dataMap.delete(datumId);
        } else {
          this.garbageBin.add(node);
        }
      }
      for (const [datumId, [datum, idx]] of dataMap.entries()) {
        this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);
      }
    } else {
      const maxLength = Math.max(data.length, this.data.length);
      for (let i = 0; i < maxLength; i++) {
        if (i >= data.length) {
          this.garbageBin.add(this._nodes[i]);
        } else if (i >= this._nodes.length) {
          this.createNode(data[i], initializer);
        } else {
          this._nodes[i].datum = data[i];
          this.garbageBin.delete(this._nodes[i]);
        }
      }
    }
    this.data = data.slice();
    if (this.autoCleanup) {
      this.cleanup();
    }
    return this;
  }
  cleanup() {
    if (this.garbageBin.size === 0) {
      return this;
    }
    this._nodes = this._nodes.filter((node) => {
      if (this.garbageBin.has(node)) {
        this._nodesMap.delete(node);
        this.garbageBin.delete(node);
        node.destroy();
        return false;
      }
      return true;
    });
    return this;
  }
  clear() {
    this.update([]);
    return this;
  }
  isGarbage(node) {
    return this.garbageBin.has(node);
  }
  hasGarbage() {
    return this.garbageBin.size > 0;
  }
  each(iterate2) {
    for (const entry of this._nodes.entries()) {
      iterate2(entry[1], entry[1].datum, entry[0]);
    }
    return this;
  }
  *[Symbol.iterator]() {
    for (let index = 0; index < this._nodes.length; index++) {
      const node = this._nodes[index];
      yield { node, datum: node.datum, index };
    }
  }
  select(predicate) {
    return _Selection.selectAll(this.parentNode, predicate);
  }
  selectByClass(Class) {
    return _Selection.selectByClass(this.parentNode, Class);
  }
  selectByTag(tag) {
    return _Selection.selectByTag(this.parentNode, tag);
  }
  nodes() {
    return this._nodes;
  }
  at(index) {
    return this._nodes.at(index);
  }
};

// packages/ag-charts-community/src/util/angle.ts
var twoPi = Math.PI * 2;
function normalizeAngle360(radians) {
  radians %= twoPi;
  radians += twoPi;
  radians %= twoPi;
  return radians;
}
function normalizeAngle360Inclusive(radians) {
  radians %= twoPi;
  radians += twoPi;
  if (radians !== twoPi) {
    radians %= twoPi;
  }
  return radians;
}
function normalizeAngle180(radians) {
  radians %= twoPi;
  if (radians < -Math.PI) {
    radians += twoPi;
  } else if (radians >= Math.PI) {
    radians -= twoPi;
  }
  return radians;
}
function isBetweenAngles(targetAngle, startAngle, endAngle) {
  const t = normalizeAngle360(targetAngle);
  const a0 = normalizeAngle360(startAngle);
  const a1 = normalizeAngle360(endAngle);
  if (a0 < a1) {
    return a0 <= t && t <= a1;
  } else if (a0 > a1) {
    return a0 <= t || t <= a1;
  } else {
    return true;
  }
}
function toRadians(degrees) {
  return degrees / 180 * Math.PI;
}
function angleBetween(angle0, angle1) {
  angle0 = normalizeAngle360(angle0);
  angle1 = normalizeAngle360(angle1);
  return angle1 - angle0 + (angle0 > angle1 ? 2 * Math.PI : 0);
}

// packages/ag-charts-community/src/util/distance.ts
function pointsDistanceSquared(x1, y1, x2, y2) {
  const dx = x1 - x2;
  const dy = y1 - y2;
  return dx * dx + dy * dy;
}
function lineDistanceSquared(x, y, x1, y1, x2, y2, best) {
  if (x1 === x2 && y1 === y2) {
    return Math.min(best, pointsDistanceSquared(x, y, x1, y1));
  }
  const dx = x2 - x1;
  const dy = y2 - y1;
  const t = Math.max(0, Math.min(1, ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy)));
  const ix = x1 + t * dx;
  const iy = y1 + t * dy;
  return Math.min(best, pointsDistanceSquared(x, y, ix, iy));
}
function arcDistanceSquared(x, y, cx, cy, radius, startAngle, endAngle, counterClockwise, best) {
  if (counterClockwise) {
    [endAngle, startAngle] = [startAngle, endAngle];
  }
  const angle2 = Math.atan2(y - cy, x - cx);
  if (!isBetweenAngles(angle2, startAngle, endAngle)) {
    const startX = cx + Math.cos(startAngle) * radius;
    const startY = cy + Math.sin(startAngle) * radius;
    const endX = cx + Math.cos(startAngle) * radius;
    const endY = cy + Math.sin(startAngle) * radius;
    return Math.min(best, pointsDistanceSquared(x, y, startX, startY), pointsDistanceSquared(x, y, endX, endY));
  }
  const distToArc = radius - Math.sqrt(pointsDistanceSquared(x, y, cx, cy));
  return Math.min(best, distToArc * distToArc);
}

// packages/ag-charts-community/src/scale/colorScale.ts
var convertColorStringToOklcha = (v) => {
  const color = Color.fromString(v);
  const [l, c, h] = Color.RGBtoOKLCH(color.r, color.g, color.b);
  return { l, c, h, a: color.a };
};
var delta = 1e-6;
var isAchromatic = (x) => x.c < delta || x.l < delta || x.l > 1 - delta;
var interpolateOklch = (x, y, d) => {
  d = clamp(0, d, 1);
  let h;
  if (isAchromatic(x)) {
    h = y.h;
  } else if (isAchromatic(y)) {
    h = x.h;
  } else {
    const xH = x.h;
    let yH = y.h;
    const deltaH = y.h - x.h;
    if (deltaH > 180) {
      yH -= 360;
    } else if (deltaH < -180) {
      yH += 360;
    }
    h = xH * (1 - d) + yH * d;
  }
  const c = x.c * (1 - d) + y.c * d;
  const l = x.l * (1 - d) + y.l * d;
  const a = x.a * (1 - d) + y.a * d;
  return Color.fromOKLCH(l, c, h, a);
};
var ColorScale = class {
  constructor() {
    this.type = "color";
    this.invalid = true;
    this.domain = [0, 1];
    this.range = ["red", "blue"];
    this.parsedRange = this.range.map(convertColorStringToOklcha);
  }
  update() {
    const { domain, range: range3 } = this;
    if (domain.length < 2) {
      Logger.warnOnce("`colorDomain` should have at least 2 values.");
      if (domain.length === 0) {
        domain.push(0, 1);
      } else if (domain.length === 1) {
        domain.push(domain[0] + 1);
      }
    }
    for (let i = 1; i < domain.length; i++) {
      const a = domain[i - 1];
      const b = domain[i];
      if (a >= b) {
        Logger.warnOnce("`colorDomain` values should be supplied in ascending order.");
        domain.sort((a2, b2) => a2 - b2);
        break;
      }
    }
    if (range3.length < domain.length) {
      for (let i = range3.length; i < domain.length; i++) {
        range3.push(range3.length > 0 ? range3[0] : "black");
      }
    }
    this.parsedRange = this.range.map(convertColorStringToOklcha);
  }
  convert(x) {
    this.refresh();
    const { domain, range: range3, parsedRange } = this;
    const d0 = domain[0];
    const d1 = domain.at(-1);
    const r0 = range3[0];
    const r1 = range3[range3.length - 1];
    if (x <= d0) {
      return r0;
    }
    if (x >= d1) {
      return r1;
    }
    let index;
    let q;
    if (domain.length === 2) {
      const t = (x - d0) / (d1 - d0);
      const step = 1 / (range3.length - 1);
      index = range3.length <= 2 ? 0 : Math.min(Math.floor(t * (range3.length - 1)), range3.length - 2);
      q = (t - index * step) / step;
    } else {
      for (index = 0; index < domain.length - 2; index++) {
        if (x < domain[index + 1]) {
          break;
        }
      }
      const a = domain[index];
      const b = domain[index + 1];
      q = (x - a) / (b - a);
    }
    const c0 = parsedRange[index];
    const c1 = parsedRange[index + 1];
    return interpolateOklch(c0, c1, q).toRgbaString();
  }
  refresh() {
    if (!this.invalid)
      return;
    this.invalid = false;
    this.update();
    if (this.invalid) {
      Logger.warnOnce("Expected update to not invalidate scale");
    }
  }
};
__decorateClass([
  Invalidating
], ColorScale.prototype, "domain", 2);
__decorateClass([
  Invalidating
], ColorScale.prototype, "range", 2);

// packages/ag-charts-community/src/scene/gradient/gradient.ts
var Gradient = class {
  constructor(colorSpace, stops = [], bbox) {
    this.colorSpace = colorSpace;
    this.stops = stops;
    this.bbox = bbox;
    this._cache = void 0;
  }
  createGradient(ctx, shapeBbox) {
    const bbox = this.bbox ?? shapeBbox;
    if (this._cache != null && this._cache.ctx === ctx && this._cache.bbox.equals(bbox)) {
      return this._cache.gradient;
    }
    const { stops, colorSpace } = this;
    if (stops.length === 0)
      return;
    if (stops.length === 1)
      return stops[0].color;
    let gradient2 = this.createCanvasGradient(ctx, bbox);
    if (gradient2 == null)
      return;
    const isOkLch = colorSpace === "oklch";
    const step = 0.05;
    let c0 = stops[0];
    gradient2.addColorStop(c0.offset, c0.color);
    for (let i = 1; i < stops.length; i += 1) {
      const c1 = stops[i];
      if (isOkLch) {
        const scale2 = new ColorScale();
        scale2.domain = [c0.offset, c1.offset];
        scale2.range = [c0.color, c1.color];
        for (let offset4 = c0.offset + step; offset4 < c1.offset; offset4 += step) {
          gradient2.addColorStop(offset4, scale2.convert(offset4));
        }
      }
      gradient2.addColorStop(c1.offset, c1.color);
      c0 = c1;
    }
    if ("createPattern" in gradient2) {
      gradient2 = gradient2.createPattern();
    }
    this._cache = { ctx, bbox, gradient: gradient2 };
    return gradient2;
  }
};

// packages/ag-charts-community/src/scene/gradient/linearGradient.ts
var LinearGradient = class extends Gradient {
  constructor(colorSpace, stops, angle2 = 0, bbox) {
    super(colorSpace, stops, bbox);
    this.angle = angle2;
  }
  createCanvasGradient(ctx, bbox) {
    const angleOffset = 90;
    const { angle: angle2 } = this;
    const radians = normalizeAngle360(toRadians(angle2 + angleOffset));
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const w = bbox.width;
    const h = bbox.height;
    const cx = bbox.x + w * 0.5;
    const cy = bbox.y + h * 0.5;
    const diagonal = Math.sqrt(h * h + w * w) / 2;
    const diagonalAngle = Math.atan2(h, w);
    let quarteredAngle;
    if (radians < Math.PI / 2) {
      quarteredAngle = radians;
    } else if (radians < Math.PI) {
      quarteredAngle = Math.PI - radians;
    } else if (radians < 1.5 * Math.PI) {
      quarteredAngle = radians - Math.PI;
    } else {
      quarteredAngle = 2 * Math.PI - radians;
    }
    const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));
    return ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);
  }
};

// packages/ag-charts-community/src/scene/shape/shape.ts
var LINEAR_GRADIENT_REGEXP = /^linear-gradient\((-?[\d.]+)deg,(.*?)\)$/i;
var _Shape = class _Shape extends Node {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.fill = _Shape.defaultStyles.fill;
    this.stroke = _Shape.defaultStyles.stroke;
    this.strokeWidth = _Shape.defaultStyles.strokeWidth;
    this.lineDash = _Shape.defaultStyles.lineDash;
    this.lineDashOffset = _Shape.defaultStyles.lineDashOffset;
    this.lineCap = _Shape.defaultStyles.lineCap;
    this.lineJoin = _Shape.defaultStyles.lineJoin;
    this.miterLimit = void 0;
    this.opacity = _Shape.defaultStyles.opacity;
    this.fillShadow = _Shape.defaultStyles.fillShadow;
  }
  /**
   * Restores the default styles introduced by this subclass.
   */
  restoreOwnStyles() {
    const { defaultStyles } = this.constructor;
    Object.assign(this, defaultStyles);
  }
  onFillChange() {
    const { fill } = this;
    let linearGradientMatch;
    if (fill instanceof Gradient) {
      this.gradient = fill;
    } else if (fill?.startsWith("linear-gradient") && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(fill))) {
      const angle2 = parseFloat(linearGradientMatch[1]);
      const colors = [];
      const colorsPart = linearGradientMatch[2];
      const colorRegex = /(#[0-9a-f]+)|(rgba?\(.+?\))|([a-z]+)/gi;
      let c;
      while (c = colorRegex.exec(colorsPart)) {
        colors.push(c[0]);
      }
      this.gradient = new LinearGradient(
        "rgb",
        colors.map((color, index) => ({ color, offset: index / (colors.length - 1) })),
        angle2
      );
    } else {
      this.gradient = void 0;
    }
  }
  /**
   * Returns a device-pixel aligned coordinate (or length if length is supplied).
   *
   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle
   * of a device pixel.
   */
  align(start, length2) {
    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;
    const alignedStart = Math.round(start * pixelRatio) / pixelRatio;
    if (length2 == null) {
      return alignedStart;
    } else if (length2 === 0) {
      return 0;
    } else if (length2 < 1) {
      return Math.ceil(length2 * pixelRatio) / pixelRatio;
    }
    return Math.round((length2 + start) * pixelRatio) / pixelRatio - alignedStart;
  }
  fillStroke(ctx, path) {
    this.renderFill(ctx, path);
    this.renderStroke(ctx, path);
  }
  renderFill(ctx, path) {
    if (this.fill) {
      const { globalAlpha } = ctx;
      this.applyFill(ctx);
      this.applyFillAlpha(ctx);
      this.applyShadow(ctx);
      this.executeFill(ctx, path);
      ctx.globalAlpha = globalAlpha;
    }
    ctx.shadowColor = "rgba(0, 0, 0, 0)";
  }
  executeFill(ctx, path) {
    path ? ctx.fill(path) : ctx.fill();
  }
  applyFill(ctx) {
    ctx.fillStyle = this.gradient?.createGradient(ctx, this.getBBox()) ?? (typeof this.fill === "string" ? this.fill : void 0) ?? "black";
  }
  applyFillAlpha(ctx) {
    ctx.globalAlpha *= this.opacity * this.fillOpacity;
  }
  applyShadow(ctx) {
    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;
    const fillShadow = this.fillShadow;
    if (fillShadow?.enabled) {
      ctx.shadowColor = fillShadow.color;
      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;
      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;
      ctx.shadowBlur = fillShadow.blur * pixelRatio;
    }
  }
  renderStroke(ctx, path) {
    if (this.stroke && this.strokeWidth) {
      const { globalAlpha } = ctx;
      ctx.strokeStyle = this.stroke;
      ctx.globalAlpha *= this.opacity * this.strokeOpacity;
      ctx.lineWidth = this.strokeWidth;
      if (this.lineDash) {
        ctx.setLineDash(this.lineDash);
      }
      if (this.lineDashOffset) {
        ctx.lineDashOffset = this.lineDashOffset;
      }
      if (this.lineCap) {
        ctx.lineCap = this.lineCap;
      }
      if (this.lineJoin) {
        ctx.lineJoin = this.lineJoin;
      }
      if (this.miterLimit != null) {
        ctx.miterLimit = this.miterLimit;
      }
      this.executeStroke(ctx, path);
      ctx.globalAlpha = globalAlpha;
    }
  }
  executeStroke(ctx, path) {
    path ? ctx.stroke(path) : ctx.stroke();
  }
  containsPoint(x, y) {
    return this.isPointInPath(x, y);
  }
};
/**
 * Defaults for style properties. Note that properties that affect the position
 * and shape of the node are not considered style properties, for example:
 * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.
 * Can be used to reset to the original styling after some custom styling
 * has been applied (using the `restoreOwnStyles` method).
 * These static defaults are meant to be inherited by subclasses.
 */
_Shape.defaultStyles = {
  fill: "black",
  stroke: void 0,
  strokeWidth: 0,
  lineDash: void 0,
  lineDashOffset: 0,
  lineCap: void 0,
  lineJoin: void 0,
  opacity: 1,
  fillShadow: void 0
};
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "fillOpacity", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "strokeOpacity", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */, changeCb: (s) => s.onFillChange() })
], _Shape.prototype, "fill", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "stroke", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "strokeWidth", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "lineDash", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "lineDashOffset", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "lineCap", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "lineJoin", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "miterLimit", 2);
__decorateClass([
  SceneChangeDetection({
    redraw: 2 /* MINOR */,
    convertor: (v) => clamp(0, v, 1)
  })
], _Shape.prototype, "opacity", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */, checkDirtyOnAssignment: true })
], _Shape.prototype, "fillShadow", 2);
var Shape = _Shape;

// packages/ag-charts-community/src/scene/shape/line.ts
var Line = class extends Shape {
  constructor(opts = {}) {
    super(opts);
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.restoreOwnStyles();
  }
  set x(value) {
    this.x1 = value;
    this.x2 = value;
  }
  set y(value) {
    this.y1 = value;
    this.y2 = value;
  }
  get midPoint() {
    return { x: (this.x1 + this.x2) / 2, y: (this.y1 + this.y2) / 2 };
  }
  computeBBox() {
    return new BBox(
      Math.min(this.x1, this.x2),
      Math.min(this.y1, this.y2),
      Math.abs(this.x2 - this.x1),
      Math.abs(this.y2 - this.y1)
    );
  }
  isPointInPath(x, y) {
    if (this.x1 === this.x2 || this.y1 === this.y2) {
      return this.getBBox().clone().grow(this.strokeWidth / 2).containsPoint(x, y);
    }
    return false;
  }
  distanceSquared(px, py) {
    const { x1, y1, x2, y2 } = this;
    return lineDistanceSquared(px, py, x1, y1, x2, y2, Infinity);
  }
  render(renderCtx) {
    const { ctx, forceRender, stats, devicePixelRatio } = renderCtx;
    if (this.dirty === 0 /* NONE */ && !forceRender) {
      if (stats)
        stats.nodesSkipped += nodeCount(this).count;
      return;
    }
    let { x1, y1, x2, y2 } = this;
    if (x1 === x2) {
      const { strokeWidth } = this;
      const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
      x1 = x;
      x2 = x;
    } else if (y1 === y2) {
      const { strokeWidth } = this;
      const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
      y1 = y;
      y2 = y;
    }
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    this.fillStroke(ctx);
    this.fillShadow?.markClean();
    super.render(renderCtx);
  }
  toSVG() {
    if (!this.visible)
      return;
    const element2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
    element2.setAttribute("x1", String(this.x1));
    element2.setAttribute("y1", String(this.y1));
    element2.setAttribute("x2", String(this.x2));
    element2.setAttribute("y2", String(this.y2));
    element2.setAttribute("stroke", this.stroke ?? "none");
    element2.setAttribute("stroke-opacity", String(this.strokeOpacity));
    element2.setAttribute("stroke-width", String(this.strokeWidth));
    return {
      elements: [element2]
    };
  }
};
Line.className = "Line";
Line.defaultStyles = { ...Shape.defaultStyles, fill: void 0, strokeWidth: 1 };
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Line.prototype, "x1", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Line.prototype, "y1", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Line.prototype, "x2", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Line.prototype, "y2", 2);

// packages/ag-charts-community/src/util/canvas.util.ts
function createCanvasContext(width = 0, height = 0) {
  return new OffscreenCanvas(width, height).getContext("2d");
}

// packages/ag-charts-community/src/util/lruCache.ts
var LRUCache = class {
  constructor(maxCacheSize = 5) {
    this.maxCacheSize = maxCacheSize;
    this.store = /* @__PURE__ */ new Map();
  }
  get(key) {
    if (!this.store.has(key))
      return void 0;
    const hit = this.store.get(key);
    this.store.delete(key);
    this.store.set(key, hit);
    return hit;
  }
  has(key) {
    return this.store.has(key);
  }
  set(key, value) {
    this.store.set(key, value);
    if (this.store.size > this.maxCacheSize) {
      const iterator = this.store.keys();
      let evictCount = this.store.size - this.maxCacheSize;
      while (evictCount > 0) {
        const evictKeyIterator = iterator.next();
        if (!evictKeyIterator.done) {
          this.store.delete(evictKeyIterator.value);
        }
        evictCount--;
      }
    }
    return value;
  }
  clear() {
    this.store.clear();
  }
};

// packages/ag-charts-community/src/util/textMeasurer.ts
var CachedTextMeasurerPool = class {
  // Measures the dimensions of the provided text, handling multiline if needed.
  static measureText(text, options) {
    const textMeasurer = this.getMeasurer(options);
    return textMeasurer.measureText(text);
  }
  static measureLines(text, options) {
    const textMeasurer = this.getMeasurer(options);
    return textMeasurer.measureLines(text);
  }
  // Gets a TextMeasurer instance, configuring text alignment and baseline if provided.
  static getMeasurer(options) {
    const font = typeof options.font === "string" ? options.font : TextUtils.toFontString(options.font);
    const key = `${font}-${options.textAlign ?? "start"}-${options.textBaseline ?? "alphabetic"}`;
    return this.instanceMap.get(key) ?? this.createFontMeasurer(font, options, key);
  }
  // Creates or retrieves a TextMeasurer instance for a specific font.
  static createFontMeasurer(font, options, key) {
    const ctx = createCanvasContext();
    ctx.font = font;
    ctx.textAlign = options.textAlign ?? "start";
    ctx.textBaseline = options.textBaseline ?? "alphabetic";
    const measurer = new CachedTextMeasurer(ctx, options);
    this.instanceMap.set(key, measurer);
    return measurer;
  }
};
CachedTextMeasurerPool.instanceMap = new LRUCache(10);
var CachedTextMeasurer = class {
  constructor(ctx, options) {
    this.ctx = ctx;
    // cached text measurements
    this.measureMap = new LRUCache(100);
    if (options.textAlign) {
      ctx.textAlign = options.textAlign;
    }
    if (options.textBaseline) {
      ctx.textBaseline = options.textBaseline;
    }
    ctx.font = typeof options.font === "string" ? options.font : TextUtils.toFontString(options.font);
    this.textMeasurer = new SimpleTextMeasurer(
      (t) => this.cachedCtxMeasureText(t),
      options.textBaseline ?? "alphabetic"
    );
  }
  textWidth(text, estimate) {
    return this.textMeasurer.textWidth(text, estimate);
  }
  measureText(text) {
    return this.textMeasurer.measureText(text);
  }
  measureLines(text) {
    return this.textMeasurer.measureLines(text);
  }
  cachedCtxMeasureText(text) {
    if (!this.measureMap.has(text)) {
      const rawResult = this.ctx.measureText(text);
      this.measureMap.set(text, {
        actualBoundingBoxAscent: rawResult.actualBoundingBoxAscent,
        emHeightAscent: rawResult.emHeightAscent,
        emHeightDescent: rawResult.emHeightDescent,
        actualBoundingBoxDescent: rawResult.actualBoundingBoxDescent,
        actualBoundingBoxLeft: rawResult.actualBoundingBoxLeft,
        actualBoundingBoxRight: rawResult.actualBoundingBoxRight,
        alphabeticBaseline: rawResult.alphabeticBaseline,
        fontBoundingBoxAscent: rawResult.fontBoundingBoxAscent,
        fontBoundingBoxDescent: rawResult.fontBoundingBoxDescent,
        hangingBaseline: rawResult.hangingBaseline,
        ideographicBaseline: rawResult.ideographicBaseline,
        width: rawResult.width
      });
    }
    return this.measureMap.get(text);
  }
};
var TextUtils = class {
  static toFontString({ fontSize = 10, fontStyle, fontWeight, fontFamily, lineHeight }) {
    let fontString = "";
    if (fontStyle) {
      fontString += `${fontStyle} `;
    }
    if (fontWeight) {
      fontString += `${fontWeight} `;
    }
    fontString += `${fontSize}px`;
    if (lineHeight) {
      fontString += `/${lineHeight}px`;
    }
    fontString += ` ${fontFamily}`;
    return fontString.trim();
  }
  static getLineHeight(fontSize) {
    return Math.ceil(fontSize * this.defaultLineHeight);
  }
  // Determines vertical offset modifier based on text baseline.
  static getVerticalModifier(textBaseline) {
    switch (textBaseline) {
      case "hanging":
      case "top":
        return 0;
      case "middle":
        return 0.5;
      case "alphabetic":
      case "bottom":
      case "ideographic":
      default:
        return 1;
    }
  }
};
TextUtils.EllipsisChar = "\u2026";
// Representation for text clipping.
TextUtils.defaultLineHeight = 1.15;
// Normally between 1.1 and 1.2
TextUtils.lineSplitter = /\r?\n/g;
var SimpleTextMeasurer = class {
  constructor(measureTextFn, textBaseline = "alphabetic") {
    this.measureTextFn = measureTextFn;
    this.textBaseline = textBaseline;
    // local chars width cache per TextMeasurer
    this.charMap = /* @__PURE__ */ new Map();
  }
  // Measures metrics for a single line of text.
  getMetrics(text) {
    const m = this.measureTextFn(text);
    m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);
    m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);
    return {
      width: m.width,
      height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,
      lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,
      offsetTop: m.actualBoundingBoxAscent,
      offsetLeft: m.actualBoundingBoxLeft
    };
  }
  // Calculates aggregated metrics for multiline text.
  getMultilineMetrics(lines) {
    let width = 0;
    let height = 0;
    let offsetTop = 0;
    let offsetLeft = 0;
    let baselineDistance = 0;
    const verticalModifier = TextUtils.getVerticalModifier(this.textBaseline);
    const lineMetrics = [];
    let index = 0;
    const length2 = lines.length;
    for (const line of lines) {
      const m = this.measureTextFn(line);
      m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);
      m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);
      if (width < m.width) {
        width = m.width;
      }
      if (offsetLeft < m.actualBoundingBoxLeft) {
        offsetLeft = m.actualBoundingBoxLeft;
      }
      if (index === 0) {
        height += m.actualBoundingBoxAscent;
        offsetTop += m.actualBoundingBoxAscent;
      } else {
        baselineDistance += m.fontBoundingBoxAscent;
      }
      if (index === length2 - 1) {
        height += m.actualBoundingBoxDescent;
      } else {
        baselineDistance += m.fontBoundingBoxDescent;
      }
      lineMetrics.push({
        text: line,
        width: m.width,
        height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,
        lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,
        offsetTop: m.actualBoundingBoxAscent,
        offsetLeft: m.actualBoundingBoxLeft
      });
      index++;
    }
    height += baselineDistance;
    offsetTop += baselineDistance * verticalModifier;
    return { width, height, offsetTop, offsetLeft, lineMetrics };
  }
  textWidth(text, estimate) {
    if (estimate) {
      let estimatedWidth = 0;
      for (let i = 0; i < text.length; i++) {
        estimatedWidth += this.textWidth(text.charAt(i));
      }
      return estimatedWidth;
    }
    if (text.length > 1) {
      return this.measureTextFn(text).width;
    }
    return this.charMap.get(text) ?? this.charWidth(text);
  }
  measureText(text) {
    return this.getMetrics(text);
  }
  // Measures the dimensions of the provided text, handling multiline if needed.
  measureLines(text) {
    const lines = typeof text === "string" ? text.split(TextUtils.lineSplitter) : text;
    return this.getMultilineMetrics(lines);
  }
  charWidth(char) {
    const { width } = this.measureTextFn(char);
    this.charMap.set(char, width);
    return width;
  }
};

// packages/ag-charts-community/src/scene/shape/text.ts
var _Text = class _Text extends Shape {
  constructor() {
    super(...arguments);
    this.x = 0;
    this.y = 0;
    this.lines = [];
    this.text = void 0;
    this.fontSize = 10;
    this.fontFamily = "sans-serif";
    this.textAlign = _Text.defaultStyles.textAlign;
    this.textBaseline = _Text.defaultStyles.textBaseline;
  }
  onTextChange() {
    this.lines = this.text?.split("\n").map((s) => s.trim()) ?? [];
  }
  static computeBBox(lines, x, y, opts) {
    const { offsetTop, offsetLeft, width, height } = CachedTextMeasurerPool.measureLines(lines, opts);
    return new BBox(x - offsetLeft, y - offsetTop, width, height);
  }
  computeBBox() {
    const { x, y, lines, textBaseline, textAlign } = this;
    return _Text.computeBBox(lines, x, y, { font: this, textBaseline, textAlign });
  }
  isPointInPath(x, y) {
    const bbox = this.getBBox();
    return bbox ? bbox.containsPoint(x, y) : false;
  }
  render(renderCtx) {
    const { ctx, forceRender, stats } = renderCtx;
    if (this.dirty === 0 /* NONE */ && !forceRender) {
      if (stats)
        stats.nodesSkipped += nodeCount(this).count;
      return;
    }
    if (!this.lines.length || !this.layerManager) {
      if (stats)
        stats.nodesSkipped += nodeCount(this).count;
      return;
    }
    const { fill, stroke, strokeWidth } = this;
    const { pixelRatio } = this.layerManager.canvas;
    ctx.font = TextUtils.toFontString(this);
    ctx.textAlign = this.textAlign;
    ctx.textBaseline = this.textBaseline;
    if (fill) {
      this.applyFill(ctx);
      ctx.globalAlpha *= this.opacity * this.fillOpacity;
      const { fillShadow } = this;
      if (fillShadow?.enabled) {
        ctx.shadowColor = fillShadow.color;
        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;
        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;
        ctx.shadowBlur = fillShadow.blur * pixelRatio;
      }
      this.renderLines((line, x, y) => ctx.fillText(line, x, y));
    }
    if (stroke && strokeWidth) {
      ctx.strokeStyle = stroke;
      ctx.lineWidth = strokeWidth;
      ctx.globalAlpha *= this.opacity * this.strokeOpacity;
      const { lineDash, lineDashOffset, lineCap, lineJoin } = this;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      this.renderLines((line, x, y) => ctx.strokeText(line, x, y));
    }
    super.render(renderCtx);
  }
  renderLines(renderCallback) {
    const { lines, x, y } = this;
    const lineHeight = this.lineHeight ?? TextUtils.getLineHeight(this.fontSize);
    let offsetY = (lineHeight - lineHeight * lines.length) * TextUtils.getVerticalModifier(this.textBaseline);
    for (const line of lines) {
      renderCallback(line, x, y + offsetY);
      offsetY += lineHeight;
    }
  }
  setFont(props) {
    this.fontFamily = props.fontFamily;
    this.fontSize = props.fontSize;
    this.fontStyle = props.fontStyle;
    this.fontWeight = props.fontWeight;
  }
  setAlign(props) {
    this.textAlign = props.textAlign;
    this.textBaseline = props.textBaseline;
  }
  toSVG() {
    if (!this.visible || !this.text)
      return;
    const element2 = document.createElementNS("http://www.w3.org/2000/svg", "text");
    element2.setAttribute("font-family", this.fontFamily?.split(",")[0] ?? "");
    element2.setAttribute("font-size", String(this.fontSize));
    element2.setAttribute("font-style", this.fontStyle ?? "");
    element2.setAttribute("font-weight", String(this.fontWeight ?? ""));
    element2.setAttribute(
      "text-anchor",
      {
        center: "middle",
        left: "start",
        right: "end",
        start: "start",
        end: "end"
      }[this.textAlign ?? "start"]
    );
    element2.setAttribute(
      "alignment-baseline",
      {
        alphabetic: "alphabetic",
        top: "top",
        bottom: "bottom",
        hanging: "hanging",
        middle: "middle",
        ideographic: "ideographic"
      }[this.textBaseline ?? "alphabetic"]
    );
    element2.setAttribute("x", String(this.x));
    element2.setAttribute("y", String(this.y));
    element2.textContent = this.text ?? "";
    return { elements: [element2] };
  }
};
_Text.className = "Text";
_Text.defaultStyles = {
  ...Shape.defaultStyles,
  textAlign: "start",
  fontStyle: void 0,
  fontWeight: void 0,
  fontSize: 10,
  fontFamily: "sans-serif",
  textBaseline: "alphabetic"
};
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], _Text.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], _Text.prototype, "y", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */, changeCb: (o) => o.onTextChange() })
], _Text.prototype, "text", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontStyle", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontWeight", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontSize", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontFamily", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], _Text.prototype, "textAlign", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], _Text.prototype, "textBaseline", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], _Text.prototype, "lineHeight", 2);
var Text = _Text;
var RotatableText = class extends Rotatable(Text) {
};
var TransformableText = class extends Rotatable(Translatable(Text)) {
};

// packages/ag-charts-community/src/scene/util/labelPlacement.ts
function circleRectOverlap(c, unitCenter, x, y, w, h) {
  if (c.size === 0) {
    return false;
  }
  let cx = c.x;
  let cy = c.y;
  if (unitCenter != null) {
    cx -= (unitCenter.x - 0.5) * c.size;
    cy -= (unitCenter.y - 0.5) * c.size;
  }
  let edgeX = cx;
  if (cx < x) {
    edgeX = x;
  } else if (cx > x + w) {
    edgeX = x + w;
  }
  let edgeY = cy;
  if (cy < y) {
    edgeY = y;
  } else if (cy > y + h) {
    edgeY = y + h;
  }
  const dx = cx - edgeX;
  const dy = cy - edgeY;
  const d = Math.sqrt(dx * dx + dy * dy);
  return d <= c.size * 0.5;
}
function rectRectOverlap(r1, x2, y2, w2, h2) {
  const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;
  const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;
  return xOverlap && yOverlap;
}
function rectContainsRect(r1, r2x, r2y, r2w, r2h) {
  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;
}
function isPointLabelDatum(x) {
  return x != null && typeof x.point === "object" && typeof x.label === "object";
}
var labelPlacements = {
  top: { x: 0, y: -1 },
  bottom: { x: 0, y: 1 },
  left: { x: -1, y: 0 },
  right: { x: 1, y: 0 },
  "top-left": { x: -1, y: -1 },
  "top-right": { x: 1, y: -1 },
  "bottom-left": { x: -1, y: 1 },
  "bottom-right": { x: 1, y: 1 }
};
function placeLabels(data, bounds, padding = 5) {
  const result = [];
  data = data.map((d) => d.slice().sort((a, b) => b.point.size - a.point.size));
  for (let j = 0; j < data.length; j++) {
    const labels = result[j] = [];
    const datum = data[j];
    if (!(datum?.length && datum[0].label)) {
      continue;
    }
    for (let index = 0, ln = datum.length; index < ln; index++) {
      const d = datum[index];
      const { point, label, marker } = d;
      const { text, width, height } = label;
      const r = point.size * 0.5;
      let dx = 0;
      let dy = 0;
      if (r > 0 && d.placement != null) {
        const placement = labelPlacements[d.placement];
        dx = (width * 0.5 + r + padding) * placement.x;
        dy = (height * 0.5 + r + padding) * placement.y;
      }
      const x = point.x - width * 0.5 + dx - ((marker?.center.x ?? 0.5) - 0.5) * point.size;
      const y = point.y - height * 0.5 + dy - ((marker?.center.y ?? 0.5) - 0.5) * point.size;
      const withinBounds = !bounds || rectContainsRect(bounds, x, y, width, height);
      if (!withinBounds) {
        continue;
      }
      const overlapPoints = data.some(
        (dataDatums) => dataDatums.some(
          (dataDatum) => circleRectOverlap(dataDatum.point, dataDatum.marker?.center, x, y, width, height)
        )
      );
      if (overlapPoints) {
        continue;
      }
      const overlapLabels = result.some((l2) => l2.some((l3) => rectRectOverlap(l3, x, y, width, height)));
      if (overlapLabels) {
        continue;
      }
      labels.push({ index, text, x, y, width, height, datum: d });
    }
  }
  return result;
}
function axisLabelsOverlap(data, padding = 0) {
  const result = [];
  for (let index = 0; index < data.length; index++) {
    const datum = data[index];
    const {
      point: { x, y },
      label: { text }
    } = datum;
    let { width, height } = datum.label;
    width += padding;
    height += padding;
    if (result.some((l) => rectRectOverlap(l, x, y, width, height))) {
      return true;
    }
    result.push({ index, text, x, y, width, height, datum });
  }
  return false;
}

// packages/ag-charts-community/src/util/equal.ts
function areArrayNumbersEqual(arrA, arrB) {
  return arrA.length === arrB.length && arrA.every((item, i) => Number(item) === Number(arrB[i]));
}

// packages/ag-charts-community/src/util/json.ts
var CLASS_INSTANCE_TYPE = "class-instance";
function jsonDiff(source, target, skip) {
  if (isArray(target)) {
    if (!isArray(source) || source.length !== target.length || target.some((v, i) => jsonDiff(source[i], v) != null)) {
      return target;
    }
  } else if (isPlainObject(target)) {
    if (!isPlainObject(source)) {
      return target;
    }
    const result = {};
    const allKeys = /* @__PURE__ */ new Set([
      ...Object.keys(source),
      ...Object.keys(target)
    ]);
    for (const key of allKeys) {
      if (source[key] === target[key] || skip?.includes(key)) {
        continue;
      }
      if (typeof source[key] === typeof target[key]) {
        const diff2 = jsonDiff(source[key], target[key]);
        if (diff2 !== null) {
          result[key] = diff2;
        }
      } else {
        result[key] = target[key];
      }
    }
    return Object.keys(result).length ? result : null;
  } else if (source !== target) {
    return target;
  }
  return null;
}
function deepClone(source, options) {
  if (isArray(source)) {
    return source.map((item) => deepClone(item, options));
  }
  if (isPlainObject(source)) {
    return mapValues(
      source,
      (value, key) => options?.shallow?.includes(key) ? shallowClone(value) : deepClone(value, options)
    );
  }
  if (source instanceof Map) {
    return new Map(deepClone(Array.from(source)));
  }
  return shallowClone(source);
}
function shallowClone(source) {
  if (isArray(source)) {
    return [...source];
  }
  if (isPlainObject(source)) {
    return { ...source };
  }
  if (isDate(source)) {
    return new Date(source);
  }
  if (isRegExp(source)) {
    return new RegExp(source.source, source.flags);
  }
  return source;
}
function jsonWalk(json, visit, opts, ...jsons) {
  if (isArray(json)) {
    visit(json, ...jsons);
    json.forEach((node, index) => {
      jsonWalk(node, visit, opts, ...keyMapper(jsons, index));
    });
  } else if (isPlainObject(json)) {
    visit(json, ...jsons);
    for (const key of Object.keys(json)) {
      if (opts?.skip?.includes(key)) {
        continue;
      }
      const value = json[key];
      if (isArray(value) || isPlainObject(value)) {
        jsonWalk(value, visit, opts, ...keyMapper(jsons, key));
      }
    }
  }
}
function jsonApply(target, source, params = {}) {
  const { path, matcherPath = path?.replace(/(\[[0-9+]+])/i, "[]"), skip = [] } = params;
  if (target == null) {
    throw new Error(`AG Charts - target is uninitialised: ${path ?? "<root>"}`);
  }
  if (source == null) {
    return target;
  }
  if (isProperties(target)) {
    return target.set(source);
  }
  const targetAny = target;
  const targetType = classify(target);
  for (const property in source) {
    if (SKIP_JS_BUILTINS.has(property))
      continue;
    const propertyMatcherPath = `${matcherPath ? matcherPath + "." : ""}${property}`;
    if (skip.includes(propertyMatcherPath))
      continue;
    const newValue = source[property];
    const propertyPath = `${path ? path + "." : ""}${property}`;
    const targetClass = targetAny.constructor;
    const currentValue = targetAny[property];
    try {
      const currentValueType = classify(currentValue);
      const newValueType = classify(newValue);
      if (targetType === CLASS_INSTANCE_TYPE && !(property in target)) {
        Logger.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);
        continue;
      }
      if (currentValueType != null && newValueType != null && newValueType !== currentValueType && (currentValueType !== CLASS_INSTANCE_TYPE || newValueType !== "object")) {
        Logger.warn(
          `unable to set [${propertyPath}] in ${targetClass?.name} - can't apply type of [${newValueType}], allowed types are: [${currentValueType}]`
        );
        continue;
      }
      if (isProperties(currentValue)) {
        targetAny[property].set(newValue);
      } else if (newValueType === "object") {
        if (currentValue == null) {
          targetAny[property] = {};
        }
        jsonApply(currentValue ?? targetAny[property], newValue, {
          ...params,
          path: propertyPath,
          matcherPath: propertyMatcherPath
        });
      } else {
        targetAny[property] = newValue;
      }
    } catch (error) {
      Logger.warn(`unable to set [${propertyPath}] in [${targetClass?.name}]; nested error is: ${error.message}`);
    }
  }
  return target;
}
function keyMapper(data, key) {
  return data.map((dataObject) => dataObject?.[key]);
}
function classify(value) {
  if (value == null) {
    return null;
  }
  if (isHtmlElement(value) || isDate(value)) {
    return "primitive";
  }
  if (isArray(value)) {
    return "array";
  }
  if (isObject(value)) {
    return isPlainObject(value) ? "object" : CLASS_INSTANCE_TYPE;
  }
  if (isFunction(value)) {
    return "function";
  }
  return "primitive";
}

// packages/ag-charts-community/src/util/proxy.ts
function ProxyProperty(proxyPath, configMetadata) {
  const pathArray = isArray(proxyPath) ? proxyPath : proxyPath.split(".");
  if (pathArray.length === 1) {
    const [property] = pathArray;
    return addTransformToInstanceProperty(
      (target, _, value) => target[property] = value,
      (target) => target[property],
      configMetadata
    );
  }
  return addTransformToInstanceProperty(
    (target, _, value) => setPath(target, pathArray, value),
    (target) => getPath(target, pathArray),
    configMetadata
  );
}
function ProxyPropertyOnWrite(childName, childProperty) {
  return addTransformToInstanceProperty((target, key, value) => target[childName][childProperty ?? key] = value);
}
function ActionOnSet(opts) {
  const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;
  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {
    if (newValue !== oldValue) {
      if (oldValue !== void 0) {
        oldValueFn?.call(target, oldValue);
      }
      if (newValue !== void 0) {
        newValueFn?.call(target, newValue);
      }
      changeValueFn?.call(target, newValue, oldValue);
    }
    return newValue;
  });
}
function ObserveChanges(observerFn) {
  return addObserverToInstanceProperty(observerFn);
}

// packages/ag-charts-community/src/util/stateMachine.ts
var debugColor = "color: green";
var debugQuietColor = "color: grey";
var _StateMachine = class _StateMachine {
  constructor(defaultState, states, enterEach) {
    this.defaultState = defaultState;
    this.states = states;
    this.enterEach = enterEach;
    this.debug = Debug.create(true, "animation");
    this.state = defaultState;
    this.debug(`%c${this.constructor.name} | init -> ${defaultState}`, debugColor);
  }
  transition(event, data) {
    const shouldTransitionSelf = this.transitionChild(event, data);
    if (!shouldTransitionSelf || this.state === _StateMachine.child || this.state === _StateMachine.parent) {
      return;
    }
    const currentState = this.state;
    const currentStateConfig = this.states[this.state];
    let destination = currentStateConfig[event];
    const debugPrefix = `%c${this.constructor.name} | ${this.state} -> ${event} ->`;
    if (Array.isArray(destination)) {
      destination = destination.find((transition) => {
        if (!transition.guard)
          return true;
        const valid = transition.guard(data);
        if (!valid) {
          this.debug(`${debugPrefix} ${transition.target} (guarded)`, debugQuietColor);
        }
        return valid;
      });
    } else if (typeof destination === "object" && !(destination instanceof _StateMachine) && destination.guard && !destination.guard(data)) {
      this.debug(`${debugPrefix} ${destination.target} (guarded)`, debugQuietColor);
      return;
    }
    if (!destination) {
      this.debug(`${debugPrefix} ${this.state}`, debugQuietColor);
      return;
    }
    const destinationState = this.getDestinationState(destination);
    const exitFn = destinationState === this.state ? void 0 : currentStateConfig.onExit;
    this.debug(`${debugPrefix} ${destinationState}`, debugColor);
    this.state = destinationState;
    if (typeof destination === "function") {
      destination(data);
    } else if (typeof destination === "object" && !(destination instanceof _StateMachine)) {
      destination.action?.(data);
    }
    exitFn?.();
    this.enterEach?.(currentState, destinationState);
    if (destinationState !== currentState && destinationState !== _StateMachine.child && destinationState !== _StateMachine.parent) {
      this.states[destinationState].onEnter?.(currentState, data);
    }
  }
  transitionAsync(event, data) {
    setTimeout(() => {
      this.transition(event, data);
    }, 0);
  }
  is(value) {
    if (this.state === _StateMachine.child && this.childState) {
      return this.childState.is(value);
    }
    return this.state === value;
  }
  resetHierarchy() {
    this.debug(
      `%c${this.constructor.name} | ${this.state} -> [resetHierarchy] -> ${this.defaultState}`,
      "color: green"
    );
    this.state = this.defaultState;
  }
  transitionChild(event, data) {
    if (this.state !== _StateMachine.child || !this.childState)
      return true;
    this.childState.transition(event, data);
    if (!this.childState.is(_StateMachine.parent))
      return true;
    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.defaultState}`, debugColor);
    this.state = this.defaultState;
    this.states[this.state].onEnter?.();
    this.childState.resetHierarchy();
    return false;
  }
  getDestinationState(destination) {
    let state = this.state;
    if (typeof destination === "string") {
      state = destination;
    } else if (destination instanceof _StateMachine) {
      this.childState = destination;
      state = _StateMachine.child;
    } else if (typeof destination === "object") {
      if (destination.target instanceof _StateMachine) {
        this.childState = destination.target;
        state = _StateMachine.child;
      } else if (destination.target != null) {
        state = destination.target;
      }
    }
    return state;
  }
};
_StateMachine.child = "__child";
_StateMachine.parent = "__parent";
var StateMachine = _StateMachine;

// packages/ag-charts-community/src/util/textWrapper.ts
var TextWrapper = class {
  static wrapText(text, options) {
    return this.wrapLines(text, options).join("\n");
  }
  static wrapLines(text, options) {
    const clippedResult = this.textWrap(text, options);
    if (options.overflow === "hide" && clippedResult.some((l) => l.endsWith(TextUtils.EllipsisChar))) {
      return [];
    }
    return clippedResult;
  }
  static appendEllipsis(text) {
    return text.replace(/[.,]{1,5}$/, "") + TextUtils.EllipsisChar;
  }
  static truncateLine(text, measurer, maxWidth, ellipsisForce) {
    const ellipsisWidth = measurer.textWidth(TextUtils.EllipsisChar);
    let estimatedWidth = 0;
    let i = 0;
    for (; i < text.length; i++) {
      const charWidth = measurer.textWidth(text.charAt(i));
      if (estimatedWidth + charWidth > maxWidth)
        break;
      estimatedWidth += charWidth;
    }
    if (text.length === i && (!ellipsisForce || estimatedWidth + ellipsisWidth <= maxWidth)) {
      return ellipsisForce ? text + TextUtils.EllipsisChar : text;
    }
    text = text.slice(0, i).trimEnd();
    while (text.length && measurer.textWidth(text) + ellipsisWidth > maxWidth) {
      text = text.slice(0, -1).trimEnd();
    }
    return text + TextUtils.EllipsisChar;
  }
  static textWrap(text, options) {
    const lines = text.split(TextUtils.lineSplitter);
    const measurer = CachedTextMeasurerPool.getMeasurer(options);
    if (options.textWrap === "never") {
      return lines.map((line) => this.truncateLine(line.trimEnd(), measurer, options.maxWidth));
    }
    const result = [];
    const wrapHyphenate = options.textWrap === "hyphenate";
    const wrapOnSpace = options.textWrap == null || options.textWrap === "on-space";
    for (let line of lines) {
      line = line.trimEnd();
      if (line === "") {
        result.push(line);
        continue;
      }
      for (let i = 0, estimatedWidth = 0, lastSpaceIndex = 0; i < line.length; i++) {
        const char = line.charAt(i);
        estimatedWidth += measurer.textWidth(char);
        if (char === " ") {
          lastSpaceIndex = i;
        }
        if (estimatedWidth > options.maxWidth) {
          if (i === 0)
            break;
          const actualWidth = measurer.textWidth(line.slice(0, i + 1));
          if (actualWidth <= options.maxWidth) {
            estimatedWidth = actualWidth;
            continue;
          }
          if (lastSpaceIndex) {
            const nextWord = this.getWordAt(line, lastSpaceIndex + 1);
            const textWidth = measurer.textWidth(nextWord);
            if (textWidth <= options.maxWidth) {
              result.push(line.slice(0, lastSpaceIndex).trimEnd());
              line = line.slice(lastSpaceIndex).trimStart();
              i = -1;
              estimatedWidth = 0;
              lastSpaceIndex = 0;
              continue;
            } else if (wrapOnSpace && textWidth > options.maxWidth) {
              result.push(
                line.slice(0, lastSpaceIndex).trimEnd(),
                this.truncateLine(
                  line.slice(lastSpaceIndex).trimStart(),
                  measurer,
                  options.maxWidth,
                  true
                )
              );
            }
          } else if (wrapOnSpace) {
            result.push(this.truncateLine(line, measurer, options.maxWidth, true));
          }
          if (wrapOnSpace) {
            line = "";
            break;
          }
          const postfix = wrapHyphenate ? "-" : "";
          let newLine = line.slice(0, i).trim();
          while (newLine.length && measurer.textWidth(newLine + postfix) > options.maxWidth) {
            newLine = newLine.slice(0, -1).trimEnd();
          }
          result.push(newLine + postfix);
          if (!newLine.length) {
            line = "";
            break;
          }
          line = line.slice(newLine.length).trimStart();
          i = -1;
          estimatedWidth = 0;
          lastSpaceIndex = 0;
        }
      }
      if (line) {
        result.push(line);
      }
    }
    this.avoidOrphans(result, measurer, options);
    return this.clipLines(result, measurer, options);
  }
  static getWordAt(text, position) {
    const nextSpaceIndex = text.indexOf(" ", position);
    return nextSpaceIndex === -1 ? text.slice(position) : text.slice(position, nextSpaceIndex);
  }
  static clipLines(lines, measurer, options) {
    if (!options.maxHeight) {
      return lines;
    }
    const { height, lineMetrics } = measurer.measureLines(lines);
    if (height <= options.maxHeight) {
      return lines;
    }
    for (let i = 0, cumulativeHeight = 0; i < lineMetrics.length; i++) {
      const { lineHeight } = lineMetrics[i];
      cumulativeHeight += lineHeight;
      if (cumulativeHeight > options.maxHeight) {
        if (options.overflow === "hide") {
          return [];
        }
        const clippedResults = lines.slice(0, i || 1);
        const lastLine = clippedResults.pop();
        return clippedResults.concat(this.truncateLine(lastLine, measurer, options.maxWidth, true));
      }
    }
    return lines;
  }
  static avoidOrphans(lines, measurer, options) {
    if (options.avoidOrphans === false || lines.length < 2)
      return;
    const { length: length2 } = lines;
    const lastLine = lines[length2 - 1];
    const beforeLast = lines[length2 - 2];
    if (beforeLast.length < lastLine.length)
      return;
    const lastSpaceIndex = beforeLast.lastIndexOf(" ");
    if (lastSpaceIndex === -1 || lastSpaceIndex === beforeLast.indexOf(" ") || lastLine.includes(" "))
      return;
    const lastWord = beforeLast.slice(lastSpaceIndex + 1);
    if (measurer.textWidth(lastLine + lastWord) <= options.maxWidth) {
      lines[length2 - 2] = beforeLast.slice(0, lastSpaceIndex);
      lines[length2 - 1] = lastWord + " " + lastLine;
    }
  }
};

// packages/ag-charts-community/src/module/enterpriseModule.ts
var enterpriseModule = {
  isEnterprise: false
};

// packages/ag-charts-community/src/util/attributeUtil.ts
function setAttribute(e, qualifiedName, value) {
  if (value === void 0 || value === "") {
    e?.removeAttribute(qualifiedName);
  } else {
    e?.setAttribute(qualifiedName, value.toString());
  }
}
function setAttributes(e, attrs) {
  if (attrs == null)
    return;
  let key;
  for (key in attrs) {
    if (key === "class")
      continue;
    setAttribute(e, key, attrs[key]);
  }
}
function getAttribute(e, qualifiedName, defaultValue) {
  if (!(e instanceof HTMLElement))
    return void 0;
  const value = e.getAttribute(qualifiedName);
  if (value === null)
    return defaultValue;
  const type = typeof {}[qualifiedName];
  if (type === "boolean")
    return value === "true";
  if (type === "number")
    return Number(value);
  if (type === "string")
    return value;
  return void 0;
}
function setElementStyle(e, property, value) {
  if (e == null)
    return;
  if (value == null) {
    e.style.removeProperty(property);
  } else {
    e.style.setProperty(property, value);
  }
}

// packages/ag-charts-community/src/util/placement.ts
function calculatePlacement(naturalWidth, naturalHeight, container, bounds) {
  let { top, right, bottom, left, width, height } = bounds;
  if (left != null) {
    if (width != null) {
      right = container.width - left + width;
    } else if (right != null) {
      width = container.width - left - right;
    }
  } else if (right != null && width != null) {
    left = container.width - right - width;
  }
  if (top != null) {
    if (height != null) {
      bottom = container.height - top - height;
    } else if (bottom != null) {
      height = container.height - bottom - top;
    }
  } else if (bottom != null && height != null) {
    top = container.height - bottom - height;
  }
  if (width == null) {
    if (height == null) {
      width = naturalWidth;
      height = naturalHeight;
    } else {
      width = Math.ceil(naturalWidth * height / naturalHeight);
    }
  } else if (height == null) {
    height = Math.ceil(naturalHeight * width / naturalWidth);
  }
  if (left == null) {
    if (right == null) {
      left = Math.floor((container.width - width) / 2);
    } else {
      left = container.width - right - width;
    }
  }
  if (top == null) {
    if (bottom == null) {
      top = Math.floor((container.height - height) / 2);
    } else {
      top = container.height - height - bottom;
    }
  }
  return { x: left, y: top, width, height };
}

// packages/ag-charts-community/src/chart/tooltip/tooltip.ts
var DEFAULT_TOOLTIP_CLASS = "ag-chart-tooltip";
var DEFAULT_TOOLTIP_DARK_CLASS = "ag-chart-dark-tooltip";
var EMPTY_TOOLTIP_CONTENT = { html: "", ariaLabel: "" };
function toAccessibleText(inputHtml) {
  const lineConverter = (_match, offset4, str) => {
    if (offset4 === 0 || str[offset4 - 1] !== ".") {
      return ". ";
    }
    return " ";
  };
  return inputHtml.replace(/<br\s*\/?>/g, lineConverter).replace(/<\/p\s+>/g, lineConverter).replace(/<\/li\s*>/g, lineConverter).replace(/<[^<>]+>/g, "").replace(/\n+/g, " ").replace(/\s+/g, " ");
}
function toTooltipHtml(input, defaults) {
  if (typeof input === "string") {
    return { html: input, ariaLabel: input };
  }
  const {
    content = defaults?.content ?? "",
    title = defaults?.title,
    color = defaults?.color ?? "white",
    backgroundColor = defaults?.backgroundColor ?? "#888"
  } = input;
  const titleHtml = title ? `<div class="${DEFAULT_TOOLTIP_CLASS}-title"
        style="color: ${color}; background-color: ${backgroundColor}">${title}</div>` : "";
  const titleAria = title ? `${title}: ` : "";
  const contentHtml = content ? `<div class="${DEFAULT_TOOLTIP_CLASS}-content">${content}</div>` : "";
  return {
    html: `${titleHtml}${contentHtml}`,
    ariaLabel: toAccessibleText(`${titleAria}${content}`)
  };
}
var TooltipPosition = class extends BaseProperties {
  constructor() {
    super(...arguments);
    /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */
    this.type = "pointer";
    /** The horizontal offset in pixels for the position of the tooltip. */
    this.xOffset = 0;
    /** The vertical offset in pixels for the position of the tooltip. */
    this.yOffset = 0;
  }
};
__decorateClass([
  Validate(
    UNION(
      [
        "pointer",
        "node",
        "top",
        "right",
        "bottom",
        "left",
        "top-left",
        "top-right",
        "bottom-right",
        "bottom-left",
        { value: "sparkline", undocumented: true }
      ],
      "a position type"
    )
  )
], TooltipPosition.prototype, "type", 2);
__decorateClass([
  Validate(NUMBER)
], TooltipPosition.prototype, "xOffset", 2);
__decorateClass([
  Validate(NUMBER)
], TooltipPosition.prototype, "yOffset", 2);
var Tooltip = class extends BaseProperties {
  constructor() {
    super();
    this.enabled = true;
    this.delay = 0;
    this.range = void 0;
    this.wrapping = "hyphenate";
    this.position = new TooltipPosition();
    this.darkTheme = false;
    this.bounds = "extended";
    this.enableInteraction = false;
    this.lastVisibilityChange = Date.now();
    this.wrapTypes = ["always", "hyphenate", "on-space", "never"];
    this.showTimeout = 0;
    this._showArrow = true;
  }
  get interactive() {
    return this.enableInteraction;
  }
  setup(domManager) {
    this.element = domManager.addChild("canvas-overlay", DEFAULT_TOOLTIP_CLASS);
    this.element.classList.add(DEFAULT_TOOLTIP_CLASS);
  }
  destroy(domManager) {
    domManager.removeChild("canvas-overlay", DEFAULT_TOOLTIP_CLASS);
  }
  isVisible() {
    return !this.element?.classList.contains(DEFAULT_TOOLTIP_CLASS + "-hidden");
  }
  /**
   * Shows tooltip at the given event's coordinates.
   * If the `html` parameter is missing, moves the existing tooltip to the new position.
   */
  show(boundingRect, canvasRect, meta, content, instantly = false) {
    const { element: element2 } = this;
    const existingPosition = element2?.getBoundingClientRect();
    if (content != null && element2 != null) {
      element2.innerHTML = content.html;
    } else if (!element2?.innerHTML) {
      this.toggle(false);
      return;
    }
    const positionType = meta.position?.type ?? this.position.type;
    const xOffset = meta.position?.xOffset ?? 0;
    const yOffset = meta.position?.yOffset ?? 0;
    const tooltipBounds = this.getTooltipBounds({ positionType, meta, yOffset, xOffset, canvasRect });
    const relativeRect = {
      x: boundingRect.x - canvasRect.x,
      y: boundingRect.y - canvasRect.y,
      width: boundingRect.width,
      height: boundingRect.height
    };
    const position = calculatePlacement(element2.clientWidth, element2.clientHeight, relativeRect, tooltipBounds);
    const minX = relativeRect.x;
    const minY = relativeRect.y;
    const maxX = relativeRect.width - element2.clientWidth - 1 + minX;
    const maxY = relativeRect.height - element2.clientHeight + minY;
    const left = clamp(minX, position.x, maxX);
    const top = clamp(minY, position.y, maxY);
    let willExistOutsideBoundingRectDuringTransition = false;
    if (existingPosition != null) {
      const maxXWithPreviousPosition = relativeRect.width - existingPosition.width - 1 + minX;
      const maxYWithPreviousPosition = relativeRect.height - existingPosition.height + minY;
      willExistOutsideBoundingRectDuringTransition = maxXWithPreviousPosition > maxX || maxYWithPreviousPosition > maxY;
    }
    const constrained = left !== position.x || top !== position.y;
    const defaultShowArrow = (positionType === "node" || positionType === "pointer" || positionType === "sparkline") && !constrained && !xOffset && !yOffset;
    const showArrow = meta.showArrow ?? this.showArrow ?? defaultShowArrow;
    this.updateShowArrow(showArrow);
    if (willExistOutsideBoundingRectDuringTransition) {
      element2.style.transition = "none";
    }
    element2.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;
    if (willExistOutsideBoundingRectDuringTransition) {
      element2.style.transition = "";
    }
    if (meta.enableInteraction) {
      this.enableInteraction = true;
      element2.style.pointerEvents = "auto";
      setAttribute(element2, "aria-hidden", void 0);
    } else {
      this.enableInteraction = false;
      element2.style.pointerEvents = "none";
      setAttribute(element2, "aria-hidden", true);
    }
    if (this.delay > 0 && !instantly) {
      this.toggle(false);
      this.showTimeout = setTimeout(() => {
        this.toggle(true);
      }, this.delay);
    } else {
      this.toggle(true);
    }
  }
  toggle(visible) {
    if (!this.element)
      return;
    const { classList } = this.element;
    const toggleClass = (name, include) => classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-${name}`, include);
    const wasVisible = this.isVisible();
    let timeSinceLastVisibilityChangeMs = Infinity;
    if (!visible) {
      clearTimeout(this.showTimeout);
    }
    if (wasVisible !== visible) {
      const now = Date.now();
      timeSinceLastVisibilityChangeMs = now - this.lastVisibilityChange;
      this.lastVisibilityChange = now;
    }
    const animatedMoveThresholdMs = 100;
    const thrashingThresholdMs = 5;
    const noAnimation = !wasVisible && visible && timeSinceLastVisibilityChangeMs > animatedMoveThresholdMs;
    if (timeSinceLastVisibilityChangeMs > thrashingThresholdMs) {
      toggleClass("no-animation", noAnimation);
    }
    toggleClass("no-interaction", !this.enableInteraction);
    toggleClass("hidden", !visible);
    toggleClass("arrow", this._showArrow);
    classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);
    for (const wrapType of this.wrapTypes) {
      classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-wrap-${wrapType}`, wrapType === this.wrapping);
    }
  }
  updateShowArrow(show) {
    this._showArrow = show;
  }
  getTooltipBounds(opts) {
    if (!this.element)
      return {};
    const { positionType, meta, yOffset, xOffset, canvasRect } = opts;
    const { clientWidth: tooltipWidth, clientHeight: tooltipHeight } = this.element;
    const bounds = { width: tooltipWidth, height: tooltipHeight };
    switch (positionType) {
      case "node":
      case "pointer": {
        bounds.top = meta.offsetY + yOffset - tooltipHeight - 8;
        bounds.left = meta.offsetX + xOffset - tooltipWidth / 2;
        return bounds;
      }
      case "top": {
        bounds.top = yOffset;
        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;
        return bounds;
      }
      case "right": {
        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;
        bounds.left = canvasRect.width - tooltipWidth / 2 + xOffset;
        return bounds;
      }
      case "left": {
        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;
        bounds.left = xOffset;
        return bounds;
      }
      case "bottom": {
        bounds.top = canvasRect.height - tooltipHeight + yOffset;
        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;
        return bounds;
      }
      case "top-left": {
        bounds.top = yOffset;
        bounds.left = xOffset;
        return bounds;
      }
      case "top-right": {
        bounds.top = yOffset;
        bounds.left = canvasRect.width - tooltipWidth + xOffset;
        return bounds;
      }
      case "bottom-right": {
        bounds.top = canvasRect.height - tooltipHeight + yOffset;
        bounds.left = canvasRect.width - tooltipWidth + xOffset;
        return bounds;
      }
      case "bottom-left": {
        bounds.top = canvasRect.height - tooltipHeight + yOffset;
        bounds.left = xOffset;
        return bounds;
      }
      case "sparkline": {
        if (enterpriseModule.isEnterprise) {
          bounds.top = yOffset - tooltipHeight - 8;
        } else {
          bounds.top = meta.offsetY + yOffset - tooltipHeight - 8;
        }
        bounds.left = meta.offsetX + xOffset - tooltipWidth / 2;
        return bounds;
      }
    }
  }
};
__decorateClass([
  Validate(BOOLEAN)
], Tooltip.prototype, "enabled", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], Tooltip.prototype, "showArrow", 2);
__decorateClass([
  ObserveChanges((target, newValue, oldValue) => {
    if (newValue) {
      target.element?.classList.add(newValue);
    }
    if (oldValue) {
      target.element?.classList.remove(oldValue);
    }
  }),
  Validate(STRING, { optional: true })
], Tooltip.prototype, "class", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Tooltip.prototype, "delay", 2);
__decorateClass([
  Validate(INTERACTION_RANGE, { optional: true })
], Tooltip.prototype, "range", 2);
__decorateClass([
  Validate(TEXT_WRAP)
], Tooltip.prototype, "wrapping", 2);
__decorateClass([
  Validate(OBJECT)
], Tooltip.prototype, "position", 2);
__decorateClass([
  Validate(BOOLEAN)
], Tooltip.prototype, "darkTheme", 2);
__decorateClass([
  Validate(UNION(["extended", "canvas"]))
], Tooltip.prototype, "bounds", 2);

// packages/ag-charts-community/src/chart/caption.ts
var Caption = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.id = createId(this);
    this.node = new RotatableText({ zIndex: 1 }).setProperties({
      textAlign: "center",
      pointerEvents: 1 /* None */
    });
    this.enabled = false;
    this.textAlign = "center";
    this.fontSize = 10;
    this.fontFamily = "sans-serif";
    this.wrapping = "always";
    this.padding = 0;
    this.layoutStyle = "block";
    this.truncated = false;
  }
  registerInteraction(moduleCtx, where) {
    const { regionManager, proxyInteractionService, layoutManager } = moduleCtx;
    const region = regionManager.getRegion("root");
    const destroyFns = [
      layoutManager.addListener("layout:complete", () => this.updateA11yText(proxyInteractionService, where)),
      region.addListener("hover", (event) => this.handleMouseMove(moduleCtx, event)),
      region.addListener("leave", (event) => this.handleMouseLeave(moduleCtx, event))
    ];
    return joinFunctions(...destroyFns);
  }
  computeTextWrap(containerWidth, containerHeight) {
    const { text, padding, wrapping } = this;
    const maxWidth = Math.min(this.maxWidth ?? Infinity, containerWidth) - padding * 2;
    const maxHeight = this.maxHeight ?? containerHeight - padding * 2;
    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {
      this.node.text = text;
      return;
    }
    const wrappedText = TextWrapper.wrapText(text ?? "", { maxWidth, maxHeight, font: this, textWrap: wrapping });
    this.node.text = wrappedText;
    this.truncated = wrappedText.includes(TextUtils.EllipsisChar);
  }
  updateA11yText(proxyService, where) {
    if (this.enabled && this.text) {
      const bbox = Transformable.toCanvas(this.node);
      if (bbox) {
        const { id } = this;
        this.proxyText ?? (this.proxyText = proxyService.createProxyElement({ type: "text", id, parent: where }));
        this.proxyText.textContent = this.text;
        this.proxyText.updateBounds(bbox);
      }
    } else {
      this.proxyText?.remove();
      this.proxyText = void 0;
    }
  }
  handleMouseMove(moduleCtx, event) {
    if (event !== void 0 && this.enabled && this.node.visible && this.truncated) {
      const { offsetX, offsetY } = event;
      moduleCtx.tooltipManager.updateTooltip(
        this.id,
        { offsetX, offsetY, lastPointerEvent: event, showArrow: false },
        toTooltipHtml({ content: this.text })
      );
    }
  }
  handleMouseLeave(moduleCtx, _event) {
    moduleCtx.tooltipManager.removeTooltip(this.id);
  }
};
Caption.SMALL_PADDING = 10;
Caption.LARGE_PADDING = 20;
__decorateClass([
  Validate(BOOLEAN),
  ProxyPropertyOnWrite("node", "visible")
], Caption.prototype, "enabled", 2);
__decorateClass([
  Validate(STRING, { optional: true }),
  ProxyPropertyOnWrite("node")
], Caption.prototype, "text", 2);
__decorateClass([
  Validate(TEXT_ALIGN, { optional: true }),
  ProxyPropertyOnWrite("node")
], Caption.prototype, "textAlign", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true }),
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT, { optional: true }),
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontWeight", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER),
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING),
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontFamily", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true }),
  ProxyPropertyOnWrite("node", "fill")
], Caption.prototype, "color", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], Caption.prototype, "spacing", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], Caption.prototype, "maxWidth", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], Caption.prototype, "maxHeight", 2);
__decorateClass([
  Validate(TEXT_WRAP)
], Caption.prototype, "wrapping", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Caption.prototype, "padding", 2);
__decorateClass([
  Validate(STRING)
], Caption.prototype, "layoutStyle", 2);

// packages/ag-charts-community/src/scene/layer.ts
var _Layer = class _Layer extends Group {
  constructor(opts) {
    super(opts);
    this.opts = opts;
    this.lastBBox = void 0;
  }
  static is(value) {
    return value instanceof _Layer;
  }
  markDirty(type = 1 /* TRIVIAL */) {
    super.markDirty(type, 1 /* TRIVIAL */);
  }
  preRender() {
    const counts = super.preRender();
    if (counts.nonGroups > 0) {
      this.layer ?? (this.layer = this._layerManager?.addLayer({
        name: this.name,
        zIndex: this.zIndex,
        zIndexSubOrder: this.zIndexSubOrder,
        getComputedOpacity: () => this.getComputedOpacity(),
        getVisibility: () => this.getVisibility()
      }));
      if (this.opts?.deriveZIndexFromChildren) {
        this.deriveZIndexFromChildren();
      }
    }
    return counts;
  }
  debugSkip(renderCtx) {
    super.debugSkip(renderCtx);
    const { stats } = renderCtx;
    if (stats) {
      stats.layersSkipped++;
      stats.nodesSkipped += nodeCount(this).count;
    }
  }
  render(renderCtx) {
    if (!this.layer) {
      return super.render(renderCtx);
    }
    const { opts: { name } = {}, _debug: debug3, clipRect } = this;
    const { isDirty, isChildDirty, isChildLayerDirty } = this.isDirty(renderCtx);
    const { stats } = renderCtx;
    let { forceRender, clipBBox } = renderCtx;
    const currentBBox = this.getBBox();
    if (!this.lastBBox?.equals(currentBBox)) {
      forceRender = "dirtyTransform";
      this.lastBBox = currentBBox;
    }
    if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {
      this.debugSkip(renderCtx);
      this.markClean({ recursive: false });
      return;
    }
    if (forceRender !== "dirtyTransform") {
      forceRender = isChildDirty || this.dirtyZIndex;
    }
    if (forceRender) {
      this.layer.clear();
    }
    if (this.dirtyZIndex) {
      this.sortChildren(Group.compareChildren);
    }
    const children = this.sortedChildren();
    const renderCtxTransform = renderCtx.ctx.getTransform();
    const { context: ctx } = this.layer;
    ctx.save();
    if (clipBBox) {
      const { width, height, x, y } = clipBBox;
      ctx.beginPath();
      ctx.rect(x, y, width, height);
      ctx.clip();
      debug3?.(() => ({ name, clipBBox, renderCtx, group: this, ctxTransform: ctx.getTransform() }));
    }
    ctx.setTransform(renderCtxTransform);
    if (this.clipRect) {
      clipBBox = this.renderClip({ ...renderCtx, ctx });
    }
    this.renderChildren(children, { ...renderCtx, ctx, forceRender, clipBBox });
    super.render(renderCtx, true);
    if (clipRect) {
      ctx.restore();
    }
    for (const child of this.virtualChildren()) {
      child.markClean({ recursive: "virtual" });
    }
    if (stats)
      stats.layersRendered++;
    ctx.restore();
    ctx.verifyDepthZero?.();
    if (name && stats) {
      debug3?.({
        name,
        renderCtx,
        result: "rendered",
        skipped: stats.nodesSkipped,
        counts: nodeCount(this),
        group: this
      });
    }
  }
  deriveZIndexFromChildren() {
    let lastChild;
    for (const child of this.children()) {
      if (!child.childNodeCounts.nonGroups)
        continue;
      if (!lastChild || Group.compareChildren(lastChild, child) < 0) {
        lastChild = child;
      }
    }
    this.zIndex = lastChild?.zIndex ?? -Infinity;
    this.zIndexSubOrder = lastChild?.zIndexSubOrder;
  }
  _setLayerManager(layersManager) {
    if (this.layer) {
      this._layerManager?.removeLayer(this.layer);
      this.layer = void 0;
    }
    super._setLayerManager(layersManager);
  }
  getComputedOpacity() {
    let opacity = 1;
    for (const node of this.traverseUp(true)) {
      if (node instanceof Group) {
        opacity *= node.opacity;
      }
    }
    return opacity;
  }
  getVisibility() {
    for (const node of this.traverseUp(true)) {
      if (!node.visible) {
        return false;
      }
    }
    return true;
  }
  onVisibleChange() {
    if (this.layer) {
      this.layer.enabled = this.visible;
    }
  }
  onZIndexChange() {
    super.onZIndexChange();
    if (this.layer) {
      this._layerManager?.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);
    }
  }
};
_Layer.className = "Layer";
var Layer = _Layer;
var TranslatableLayer = class extends Translatable(Layer) {
};

// packages/ag-charts-community/src/scene/shape/range.ts
var Range = class extends Shape {
  constructor(opts = {}) {
    super(opts);
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.startLine = false;
    this.endLine = false;
    this.isRange = false;
    this.restoreOwnStyles();
  }
  computeBBox() {
    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);
  }
  isPointInPath(_x, _y) {
    return false;
  }
  render(renderCtx) {
    const { ctx, forceRender, stats } = renderCtx;
    if (this.dirty === 0 /* NONE */ && !forceRender) {
      if (stats)
        stats.nodesSkipped += nodeCount(this).count;
      return;
    }
    let { x1, y1, x2, y2 } = this;
    x1 = this.align(x1);
    y1 = this.align(y1);
    x2 = this.align(x2);
    y2 = this.align(y2);
    const { fill, opacity, isRange } = this;
    const fillActive = !!(isRange && fill);
    if (fillActive) {
      const { fillOpacity } = this;
      this.applyFill(ctx);
      ctx.globalAlpha = opacity * fillOpacity;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y1);
      ctx.lineTo(x2, y2);
      ctx.lineTo(x1, y2);
      ctx.closePath();
      ctx.fill();
    }
    const { stroke, strokeWidth, startLine, endLine } = this;
    const strokeActive = !!((startLine || endLine) && stroke && strokeWidth);
    if (strokeActive) {
      const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;
      ctx.strokeStyle = stroke;
      ctx.globalAlpha = opacity * strokeOpacity;
      ctx.lineWidth = strokeWidth;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      ctx.beginPath();
      if (startLine) {
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y1);
      }
      if (endLine) {
        ctx.moveTo(x2, y2);
        ctx.lineTo(x1, y2);
      }
      ctx.stroke();
    }
    this.fillShadow?.markClean();
    super.render(renderCtx);
  }
};
Range.className = "Range";
Range.defaultStyles = {
  ...Shape.defaultStyles,
  strokeWidth: 1
};
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "x1", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "y1", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "x2", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "y2", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "startLine", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "endLine", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "isRange", 2);

// packages/ag-charts-community/src/chart/label.ts
var Label = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.fontSize = 12;
    this.fontFamily = "Verdana, sans-serif";
  }
  getFont() {
    return TextUtils.toFontString(this);
  }
};
__decorateClass([
  Validate(BOOLEAN)
], Label.prototype, "enabled", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], Label.prototype, "color", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true })
], Label.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT, { optional: true })
], Label.prototype, "fontWeight", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Label.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING)
], Label.prototype, "fontFamily", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], Label.prototype, "formatter", 2);
function calculateLabelRotation(opts) {
  const { parallelFlipRotation = 0, regularFlipRotation = 0 } = opts;
  const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;
  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;
  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;
  let defaultRotation = 0;
  if (opts.parallel) {
    defaultRotation = parallelFlipFlag * Math.PI / 2;
  } else if (regularFlipFlag === -1) {
    defaultRotation = Math.PI;
  }
  return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };
}
function getLabelSpacing(minSpacing, rotated) {
  if (!isNaN(minSpacing)) {
    return minSpacing;
  }
  return rotated ? 0 : 10;
}
function getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {
  if (parallel && !labelRotation) {
    return sideFlag * parallelFlipFlag === -1 ? "hanging" : "bottom";
  }
  return "middle";
}
function getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {
  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;
  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;
  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;
  if (parallel) {
    if (labelRotation || labelAutoRotation) {
      if (sideFlag * alignFlag === -1) {
        return "end";
      }
    } else {
      return "center";
    }
  } else if (sideFlag * regularFlipFlag === -1) {
    return "end";
  }
  return "start";
}
function calculateLabelBBox(text, bbox, labelMatrix) {
  const { x: labelX, y: labelY, width, height } = bbox;
  const translatedBBox = new BBox(labelX, labelY, 0, 0);
  labelMatrix.transformBBox(translatedBBox, bbox);
  const { x, y } = bbox;
  return {
    point: { x, y },
    label: { text, width, height }
  };
}

// packages/ag-charts-community/src/util/value.ts
function isStringObject(value) {
  return value != null && Object.hasOwn(value, "toString") && isString(value.toString());
}
function isNumberObject(value) {
  return value != null && Object.hasOwn(value, "valueOf") && isFiniteNumber(value.valueOf());
}
function isContinuous(value) {
  return isFiniteNumber(value) || isValidDate(value) || isNumberObject(value);
}
function checkDatum(value, isContinuousScale) {
  return value != null && (!isContinuousScale || isContinuous(value));
}
function transformIntegratedCategoryValue(value) {
  if (isStringObject(value) && Object.hasOwn(value, "id")) {
    return value.id;
  }
  return value;
}

// packages/ag-charts-community/src/chart/crossline/crossLine.ts
var MATCHING_CROSSLINE_TYPE = (property) => {
  return property === "value" ? predicateWithMessage(
    (_, ctx) => ctx.target["type"] === "line",
    (ctx) => ctx.target["type"] === "range" ? `crossLine type 'range' to have a 'range' property instead of 'value'` : `crossLine property 'type' to be 'line'`
  ) : predicateWithMessage(
    (_, ctx) => ctx.target["type"] === "range",
    (ctx) => ctx.target.type === "line" ? `crossLine type 'line' to have a 'value' property instead of 'range'` : `crossLine property 'type' to be 'range'`
  );
};
var validateCrossLineValues = (type, value, range3, scale2, visibilityCheck) => {
  const lineCrossLine = type === "line" && value !== void 0;
  const rangeCrossLine = type === "range" && range3 !== void 0;
  if (!lineCrossLine && !rangeCrossLine) {
    return true;
  }
  const [start, end] = range3 ?? [value, void 0];
  const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);
  const validStart = checkDatum(start, isContinuous2) && !isNaN(scale2.convert(start));
  const validEnd = checkDatum(end, isContinuous2) && !isNaN(scale2.convert(end));
  if (lineCrossLine && validStart || rangeCrossLine && validStart && validEnd) {
    return visibilityCheck?.() ?? true;
  }
  const message = [`Expecting crossLine`];
  if (rangeCrossLine) {
    if (!validStart) {
      message.push(`range start ${stringify(start)}`);
    }
    if (!validEnd) {
      message.push(`${validStart ? "" : "and "}range end ${stringify(end)}`);
    }
  } else {
    message.push(`value ${stringify(start)}`);
  }
  message.push(`to match the axis scale domain.`);
  Logger.warnOnce(message.join(" "));
  return false;
};

// packages/ag-charts-community/src/chart/crossline/crossLineLabelPosition.ts
var horizontalCrosslineTranslationDirections = {
  top: { xTranslationDirection: 0, yTranslationDirection: -1 },
  bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },
  left: { xTranslationDirection: -1, yTranslationDirection: 0 },
  right: { xTranslationDirection: 1, yTranslationDirection: 0 },
  topLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },
  topRight: { xTranslationDirection: -1, yTranslationDirection: -1 },
  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },
  bottomRight: { xTranslationDirection: -1, yTranslationDirection: 1 },
  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },
  insideLeft: { xTranslationDirection: 1, yTranslationDirection: 0 },
  insideRight: { xTranslationDirection: -1, yTranslationDirection: 0 },
  insideTop: { xTranslationDirection: 0, yTranslationDirection: 1 },
  insideBottom: { xTranslationDirection: 0, yTranslationDirection: -1 },
  insideTopLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },
  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },
  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: 1 },
  insideBottomRight: { xTranslationDirection: -1, yTranslationDirection: -1 }
};
var verticalCrossLineTranslationDirections = {
  top: { xTranslationDirection: 1, yTranslationDirection: 0 },
  bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },
  left: { xTranslationDirection: 0, yTranslationDirection: -1 },
  right: { xTranslationDirection: 0, yTranslationDirection: 1 },
  topLeft: { xTranslationDirection: -1, yTranslationDirection: -1 },
  topRight: { xTranslationDirection: -1, yTranslationDirection: 1 },
  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },
  bottomRight: { xTranslationDirection: 1, yTranslationDirection: 1 },
  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },
  insideLeft: { xTranslationDirection: 0, yTranslationDirection: 1 },
  insideRight: { xTranslationDirection: 0, yTranslationDirection: -1 },
  insideTop: { xTranslationDirection: -1, yTranslationDirection: 0 },
  insideBottom: { xTranslationDirection: 1, yTranslationDirection: 0 },
  insideTopLeft: { xTranslationDirection: -1, yTranslationDirection: 1 },
  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },
  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: -1 },
  insideBottomRight: { xTranslationDirection: 1, yTranslationDirection: -1 }
};
function calculateLabelTranslation({
  yDirection,
  padding = 0,
  position = "top",
  bbox
}) {
  const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;
  const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];
  const xTranslation = xTranslationDirection * (padding + bbox.width / 2);
  const yTranslation = yTranslationDirection * (padding + bbox.height / 2);
  return {
    xTranslation,
    yTranslation
  };
}
function calculateLabelChartPadding({
  yDirection,
  bbox,
  padding = 0,
  position = "top"
}) {
  const chartPadding = {};
  if (position.startsWith("inside"))
    return chartPadding;
  if (position === "top" && !yDirection) {
    chartPadding.top = padding + bbox.height;
  } else if (position === "bottom" && !yDirection) {
    chartPadding.bottom = padding + bbox.height;
  } else if (position === "left" && yDirection) {
    chartPadding.left = padding + bbox.width;
  } else if (position === "right" && yDirection) {
    chartPadding.right = padding + bbox.width;
  }
  return chartPadding;
}
var POSITION_TOP_COORDINATES = ({ direction, xEnd, yStart, yEnd }) => {
  if (direction === "y" /* Y */) {
    return { x: xEnd / 2, y: yStart };
  } else {
    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };
  }
};
var POSITION_LEFT_COORDINATES = ({ direction, xStart, xEnd, yStart, yEnd }) => {
  if (direction === "y" /* Y */) {
    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };
  } else {
    return { x: xEnd / 2, y: yStart };
  }
};
var POSITION_RIGHT_COORDINATES = ({ direction, xEnd, yStart, yEnd }) => {
  if (direction === "y" /* Y */) {
    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };
  } else {
    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };
  }
};
var POSITION_BOTTOM_COORDINATES = ({ direction, xStart, xEnd, yStart, yEnd }) => {
  if (direction === "y" /* Y */) {
    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };
  } else {
    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };
  }
};
var POSITION_INSIDE_COORDINATES = ({ xEnd, yStart, yEnd }) => {
  return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };
};
var POSITION_TOP_LEFT_COORDINATES = ({ direction, xStart, xEnd, yStart }) => {
  if (direction === "y" /* Y */) {
    return { x: xStart / 2, y: yStart };
  } else {
    return { x: xEnd, y: yStart };
  }
};
var POSITION_BOTTOM_LEFT_COORDINATES = ({ direction, xStart, yStart, yEnd }) => {
  if (direction === "y" /* Y */) {
    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };
  } else {
    return { x: xStart, y: yStart };
  }
};
var POSITION_TOP_RIGHT_COORDINATES = ({ direction, xEnd, yStart, yEnd }) => {
  if (direction === "y" /* Y */) {
    return { x: xEnd, y: yStart };
  } else {
    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };
  }
};
var POSITION_BOTTOM_RIGHT_COORDINATES = ({ direction, xStart, xEnd, yStart, yEnd }) => {
  if (direction === "y" /* Y */) {
    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };
  } else {
    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };
  }
};
var labelDirectionHandling = {
  top: { c: POSITION_TOP_COORDINATES },
  bottom: { c: POSITION_BOTTOM_COORDINATES },
  left: { c: POSITION_LEFT_COORDINATES },
  right: { c: POSITION_RIGHT_COORDINATES },
  topLeft: { c: POSITION_TOP_LEFT_COORDINATES },
  topRight: { c: POSITION_TOP_RIGHT_COORDINATES },
  bottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },
  bottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES },
  inside: { c: POSITION_INSIDE_COORDINATES },
  insideLeft: { c: POSITION_LEFT_COORDINATES },
  insideRight: { c: POSITION_RIGHT_COORDINATES },
  insideTop: { c: POSITION_TOP_COORDINATES },
  insideBottom: { c: POSITION_BOTTOM_COORDINATES },
  insideTopLeft: { c: POSITION_TOP_LEFT_COORDINATES },
  insideBottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },
  insideTopRight: { c: POSITION_TOP_RIGHT_COORDINATES },
  insideBottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES }
};

// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts
var CROSSLINE_LABEL_POSITION = UNION(
  [
    "top",
    "left",
    "right",
    "bottom",
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight",
    "inside",
    "insideLeft",
    "insideRight",
    "insideTop",
    "insideBottom",
    "insideTopLeft",
    "insideBottomLeft",
    "insideTopRight",
    "insideBottomRight"
  ],
  "crossLine label position"
);
var CartesianCrossLineLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.fontSize = 14;
    this.fontFamily = "Verdana, sans-serif";
    this.padding = 5;
    this.color = "rgba(87, 87, 87, 1)";
  }
};
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], CartesianCrossLineLabel.prototype, "enabled", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], CartesianCrossLineLabel.prototype, "text", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true })
], CartesianCrossLineLabel.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT, { optional: true })
], CartesianCrossLineLabel.prototype, "fontWeight", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], CartesianCrossLineLabel.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING)
], CartesianCrossLineLabel.prototype, "fontFamily", 2);
__decorateClass([
  Validate(NUMBER)
], CartesianCrossLineLabel.prototype, "padding", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], CartesianCrossLineLabel.prototype, "color", 2);
__decorateClass([
  Validate(CROSSLINE_LABEL_POSITION, { optional: true })
], CartesianCrossLineLabel.prototype, "position", 2);
__decorateClass([
  Validate(DEGREE, { optional: true })
], CartesianCrossLineLabel.prototype, "rotation", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], CartesianCrossLineLabel.prototype, "parallel", 2);
var _CartesianCrossLine = class _CartesianCrossLine extends BaseProperties {
  constructor() {
    super();
    this.id = createId(this);
    this.label = new CartesianCrossLineLabel();
    this.scale = void 0;
    this.clippedRange = [-Infinity, Infinity];
    this.gridLength = 0;
    this.sideFlag = -1;
    this.parallelFlipRotation = 0;
    this.regularFlipRotation = 0;
    this.direction = "x" /* X */;
    this.group = new Layer({ name: this.id, zIndex: _CartesianCrossLine.LINE_LAYER_ZINDEX });
    this.labelGroup = new Layer({ name: this.id, zIndex: _CartesianCrossLine.LABEL_LAYER_ZINDEX });
    this.crossLineRange = new Range();
    this.crossLineLabel = new TransformableText();
    this.labelPoint = void 0;
    this.data = [];
    this.startLine = false;
    this.endLine = false;
    this.isRange = false;
    this.group.append(this.crossLineRange);
    this.labelGroup.append(this.crossLineLabel);
    this.crossLineRange.pointerEvents = 1 /* None */;
  }
  update(visible) {
    const { enabled, data, type, value, range: range3, scale: scale2 } = this;
    if (!type || !scale2 || !enabled || !visible || !validateCrossLineValues(type, value, range3, scale2) || data.length === 0) {
      this.group.visible = false;
      this.labelGroup.visible = false;
      return;
    }
    this.group.visible = visible;
    this.labelGroup.visible = visible;
    this.group.zIndex = this.getZIndex(this.isRange);
    this.updateNodes();
  }
  calculateLayout(visible, reversedAxis) {
    if (!visible)
      return;
    const {
      scale: scale2,
      gridLength,
      sideFlag,
      direction,
      label: { position = "top" },
      clippedRange,
      strokeWidth = 0
    } = this;
    this.data = [];
    if (!scale2)
      return;
    const bandwidth = scale2.bandwidth ?? 0;
    const step = scale2.step ?? 0;
    const padding = (reversedAxis ? -1 : 1) * (scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0);
    const [xStart, xEnd] = [0, sideFlag * gridLength];
    let [yStart, yEnd] = this.getRange();
    const ordinalTimeScalePadding = yEnd === void 0 && OrdinalTimeScale.is(scale2) ? bandwidth / 2 + padding : 0;
    let [clampedYStart, clampedYEnd] = [
      Number(scale2.convert(yStart, { clampMode: "clamped" })) - padding + ordinalTimeScalePadding,
      scale2.convert(yEnd, { clampMode: "clamped" }) + bandwidth + padding
    ];
    clampedYStart = clampArray(clampedYStart, clippedRange);
    clampedYEnd = clampArray(clampedYEnd, clippedRange);
    [yStart, yEnd] = [Number(scale2.convert(yStart)) + ordinalTimeScalePadding, scale2.convert(yEnd) + bandwidth];
    const validRange = (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;
    if (validRange && clampedYStart > clampedYEnd) {
      [clampedYStart, clampedYEnd] = [clampedYEnd, clampedYStart];
      [yStart, yEnd] = [yEnd, yStart];
    }
    if (yStart - padding >= clampedYStart)
      yStart -= padding;
    if (yEnd + padding <= clampedYEnd)
      yEnd += padding;
    this.isRange = validRange;
    this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + padding;
    this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - padding && yEnd <= clampedYEnd;
    if (!validRange && !this.startLine && !this.endLine)
      return;
    this.data = [clampedYStart, clampedYEnd];
    if (!this.label.enabled)
      return;
    const { c = POSITION_TOP_COORDINATES } = labelDirectionHandling[position] ?? {};
    const { x: labelX, y: labelY } = c({
      direction,
      xStart,
      xEnd,
      yStart: clampedYStart,
      yEnd: clampedYEnd
    });
    this.labelPoint = {
      x: labelX,
      y: labelY
    };
  }
  updateNodes() {
    this.updateRangeNode();
    if (this.label.enabled) {
      this.updateLabel();
      this.positionLabel();
    }
  }
  updateRangeNode() {
    const {
      crossLineRange,
      sideFlag,
      gridLength,
      data,
      startLine,
      endLine,
      isRange,
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      lineDash
    } = this;
    crossLineRange.x1 = 0;
    crossLineRange.x2 = sideFlag * gridLength;
    crossLineRange.y1 = data[0];
    crossLineRange.y2 = data[1];
    crossLineRange.startLine = startLine;
    crossLineRange.endLine = endLine;
    crossLineRange.isRange = isRange;
    crossLineRange.fill = fill;
    crossLineRange.fillOpacity = fillOpacity ?? 1;
    crossLineRange.stroke = stroke;
    crossLineRange.strokeWidth = strokeWidth ?? 1;
    crossLineRange.strokeOpacity = this.strokeOpacity ?? 1;
    crossLineRange.lineDash = lineDash;
  }
  updateLabel() {
    const { crossLineLabel, label } = this;
    if (!label.text)
      return;
    crossLineLabel.fontStyle = label.fontStyle;
    crossLineLabel.fontWeight = label.fontWeight;
    crossLineLabel.fontSize = label.fontSize;
    crossLineLabel.fontFamily = label.fontFamily;
    crossLineLabel.fill = label.color;
    crossLineLabel.text = label.text;
  }
  positionLabel() {
    const {
      crossLineLabel,
      labelPoint: { x = void 0, y = void 0 } = {},
      label: { parallel, rotation, position = "top", padding = 0 },
      direction,
      parallelFlipRotation,
      regularFlipRotation
    } = this;
    if (x === void 0 || y === void 0)
      return;
    const { defaultRotation, configuredRotation } = calculateLabelRotation({
      rotation,
      parallel,
      regularFlipRotation,
      parallelFlipRotation
    });
    crossLineLabel.rotation = defaultRotation + configuredRotation;
    crossLineLabel.textBaseline = "middle";
    crossLineLabel.textAlign = "center";
    const bbox = crossLineLabel.getBBox();
    if (!bbox)
      return;
    const yDirection = direction === "y" /* Y */;
    const { xTranslation, yTranslation } = calculateLabelTranslation({
      yDirection,
      padding,
      position,
      bbox
    });
    crossLineLabel.translationX = x + xTranslation;
    crossLineLabel.translationY = y + yTranslation;
  }
  getZIndex(isRange = false) {
    return isRange ? _CartesianCrossLine.RANGE_LAYER_ZINDEX : _CartesianCrossLine.LINE_LAYER_ZINDEX;
  }
  getRange() {
    const { value, range: range3, scale: scale2 } = this;
    const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);
    const start = range3?.[0] ?? value;
    let end = range3?.[1];
    if (!isContinuous2 && end === void 0) {
      end = start;
    }
    if (isContinuous2 && start === end) {
      end = void 0;
    }
    return [start, end];
  }
  computeLabelBBox() {
    const { label } = this;
    if (!label.enabled)
      return;
    const tempText = new TransformableText();
    tempText.fontFamily = label.fontFamily;
    tempText.fontSize = label.fontSize;
    tempText.fontStyle = label.fontStyle;
    tempText.fontWeight = label.fontWeight;
    tempText.text = label.text;
    const {
      labelPoint: { x = void 0, y = void 0 } = {},
      label: { parallel, rotation, position = "top", padding = 0 },
      direction,
      parallelFlipRotation,
      regularFlipRotation
    } = this;
    if (x === void 0 || y === void 0)
      return;
    const { configuredRotation } = calculateLabelRotation({
      rotation,
      parallel,
      regularFlipRotation,
      parallelFlipRotation
    });
    tempText.rotation = configuredRotation;
    tempText.textBaseline = "middle";
    tempText.textAlign = "center";
    const bbox = tempText.getBBox();
    if (!bbox)
      return;
    const yDirection = direction === "y" /* Y */;
    const { xTranslation, yTranslation } = calculateLabelTranslation({
      yDirection,
      padding,
      position,
      bbox
    });
    tempText.x = x + xTranslation;
    tempText.y = y + yTranslation;
    return tempText.getBBox();
  }
  calculatePadding(padding) {
    const {
      isRange,
      startLine,
      endLine,
      direction,
      label: { padding: labelPadding = 0, position = "top" }
    } = this;
    if (!isRange && !startLine && !endLine)
      return;
    const crossLineLabelBBox = this.computeLabelBBox();
    if (crossLineLabelBBox?.x == null || crossLineLabelBBox?.y == null)
      return;
    const chartPadding = calculateLabelChartPadding({
      yDirection: direction === "y" /* Y */,
      padding: labelPadding,
      position,
      bbox: crossLineLabelBBox
    });
    padding.left = Math.max(padding.left ?? 0, chartPadding.left ?? 0);
    padding.right = Math.max(padding.right ?? 0, chartPadding.right ?? 0);
    padding.top = Math.max(padding.top ?? 0, chartPadding.top ?? 0);
    padding.bottom = Math.max(padding.bottom ?? 0, chartPadding.bottom ?? 0);
  }
};
_CartesianCrossLine.LINE_LAYER_ZINDEX = 9 /* SERIES_CROSSLINE_LINE */;
_CartesianCrossLine.RANGE_LAYER_ZINDEX = 3 /* SERIES_CROSSLINE_RANGE */;
_CartesianCrossLine.LABEL_LAYER_ZINDEX = 14 /* SERIES_LABEL */;
_CartesianCrossLine.className = "CrossLine";
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], _CartesianCrossLine.prototype, "enabled", 2);
__decorateClass([
  Validate(UNION(["range", "line"], "a crossLine type"), { optional: true })
], _CartesianCrossLine.prototype, "type", 2);
__decorateClass([
  Validate(AND(MATCHING_CROSSLINE_TYPE("range"), ARRAY.restrict({ length: 2 })), {
    optional: true
  })
], _CartesianCrossLine.prototype, "range", 2);
__decorateClass([
  Validate(MATCHING_CROSSLINE_TYPE("value"), { optional: true })
], _CartesianCrossLine.prototype, "value", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], _CartesianCrossLine.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], _CartesianCrossLine.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], _CartesianCrossLine.prototype, "stroke", 2);
__decorateClass([
  Validate(NUMBER, { optional: true })
], _CartesianCrossLine.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], _CartesianCrossLine.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH, { optional: true })
], _CartesianCrossLine.prototype, "lineDash", 2);
__decorateClass([
  Validate(OBJECT)
], _CartesianCrossLine.prototype, "label", 2);
var CartesianCrossLine = _CartesianCrossLine;

// packages/ag-charts-community/src/chart/axis/axisGridLine.ts
var GRID_STYLE_KEYS = ["stroke", "lineDash"];
var GRID_STYLE = ARRAY_OF(
  (value) => isObject(value) && Object.keys(value).every((key) => GRID_STYLE_KEYS.includes(key)),
  "objects with gridline style properties such as 'stroke' or 'lineDash'"
);
var AxisGridLine = class {
  constructor() {
    this.enabled = true;
    this.width = 1;
    this.style = [
      {
        stroke: void 0,
        lineDash: []
      }
    ];
  }
};
__decorateClass([
  Validate(BOOLEAN)
], AxisGridLine.prototype, "enabled", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AxisGridLine.prototype, "width", 2);
__decorateClass([
  Validate(GRID_STYLE)
], AxisGridLine.prototype, "style", 2);

// packages/ag-charts-community/src/util/default.ts
function Default(defaultValue, replaces = [void 0]) {
  return addTransformToInstanceProperty((_, __, v) => {
    if (replaces.includes(v)) {
      return isFunction(defaultValue) ? defaultValue(v) : defaultValue;
    }
    return v;
  });
}

// packages/ag-charts-community/src/util/time/utcMinute.ts
function encode8(date) {
  return Math.floor(date.getTime() / durationMinute);
}
function decode8(encoded) {
  return new Date(encoded * durationMinute);
}
var utcMinute = new CountableTimeInterval(encode8, decode8);

// packages/ag-charts-community/src/util/time/utcHour.ts
function encode9(date) {
  return Math.floor(date.getTime() / durationHour);
}
function decode9(encoded) {
  return new Date(encoded * durationHour);
}
var utcHour = new CountableTimeInterval(encode9, decode9);

// packages/ag-charts-community/src/util/time/utcDay.ts
function encode10(date) {
  return Math.floor(date.getTime() / durationDay);
}
function decode10(encoded) {
  const d = /* @__PURE__ */ new Date(0);
  d.setUTCDate(d.getUTCDate() + encoded);
  d.setUTCHours(0, 0, 0, 0);
  return d;
}
var utcDay = new CountableTimeInterval(encode10, decode10);

// packages/ag-charts-community/src/util/time/utcMonth.ts
function encode11(date) {
  return date.getUTCFullYear() * 12 + date.getUTCMonth();
}
function decode11(encoded) {
  const year2 = Math.floor(encoded / 12);
  const month2 = encoded - year2 * 12;
  return new Date(Date.UTC(year2, month2, 1));
}
var utcMonth = new CountableTimeInterval(encode11, decode11);

// packages/ag-charts-community/src/util/time/utcYear.ts
function encode12(date) {
  return date.getUTCFullYear();
}
function decode12(encoded) {
  const d = /* @__PURE__ */ new Date();
  d.setUTCFullYear(encoded);
  d.setUTCMonth(0, 1);
  d.setUTCHours(0, 0, 0, 0);
  return d;
}
var utcYear = new CountableTimeInterval(encode12, decode12);

// packages/ag-charts-community/src/chart/axis/axisInterval.ts
var TICK_INTERVAL = predicateWithMessage(
  (value) => isFiniteNumber(value) && value > 0 || value instanceof TimeInterval,
  `a non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`
);
var AxisInterval = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.minSpacing = NaN;
    this.maxSpacing = NaN;
  }
};
__decorateClass([
  Validate(TICK_INTERVAL, { optional: true })
], AxisInterval.prototype, "step", 2);
__decorateClass([
  Validate(ARRAY, { optional: true })
], AxisInterval.prototype, "values", 2);
__decorateClass([
  Validate(MIN_SPACING),
  Default(NaN)
], AxisInterval.prototype, "minSpacing", 2);
__decorateClass([
  Validate(MAX_SPACING),
  Default(NaN)
], AxisInterval.prototype, "maxSpacing", 2);

// packages/ag-charts-community/src/chart/axis/axisLabel.ts
var AxisLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.fontSize = 12;
    this.fontFamily = "Verdana, sans-serif";
    this.padding = 5;
    this.minSpacing = NaN;
    this.color = "#575757";
    this.avoidCollisions = true;
    this.mirrored = false;
    this.parallel = false;
  }
  /**
   * The side of the axis line to position the labels on.
   * -1 = left (default)
   * 1 = right
   */
  getSideFlag() {
    return this.mirrored ? 1 : -1;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], AxisLabel.prototype, "enabled", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true })
], AxisLabel.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT, { optional: true })
], AxisLabel.prototype, "fontWeight", 2);
__decorateClass([
  Validate(NUMBER.restrict({ min: 1 }))
], AxisLabel.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING)
], AxisLabel.prototype, "fontFamily", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AxisLabel.prototype, "padding", 2);
__decorateClass([
  Validate(NUMBER_OR_NAN),
  Default(NaN)
], AxisLabel.prototype, "minSpacing", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], AxisLabel.prototype, "color", 2);
__decorateClass([
  Validate(DEGREE, { optional: true })
], AxisLabel.prototype, "rotation", 2);
__decorateClass([
  Validate(BOOLEAN)
], AxisLabel.prototype, "avoidCollisions", 2);
__decorateClass([
  Validate(BOOLEAN)
], AxisLabel.prototype, "mirrored", 2);
__decorateClass([
  Validate(BOOLEAN)
], AxisLabel.prototype, "parallel", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], AxisLabel.prototype, "formatter", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], AxisLabel.prototype, "format", 2);

// packages/ag-charts-community/src/chart/axis/axisLine.ts
var AxisLine = class {
  constructor() {
    this.enabled = true;
    this.width = 1;
    this.stroke = void 0;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], AxisLine.prototype, "enabled", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AxisLine.prototype, "width", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], AxisLine.prototype, "stroke", 2);

// packages/ag-charts-community/src/chart/axis/axisTick.ts
var AxisTick = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.width = 1;
    this.size = 6;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], AxisTick.prototype, "enabled", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AxisTick.prototype, "width", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AxisTick.prototype, "size", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], AxisTick.prototype, "stroke", 2);

// packages/ag-charts-community/src/chart/axis/axisTitle.ts
var AxisTitle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.caption = new Caption();
    this.enabled = false;
    this.spacing = Caption.SMALL_PADDING;
    this.fontSize = 10;
    this.fontFamily = "sans-serif";
    this.wrapping = "always";
  }
};
__decorateClass([
  Validate(BOOLEAN)
], AxisTitle.prototype, "enabled", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], AxisTitle.prototype, "text", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], AxisTitle.prototype, "spacing", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true })
], AxisTitle.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT, { optional: true })
], AxisTitle.prototype, "fontWeight", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AxisTitle.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING)
], AxisTitle.prototype, "fontFamily", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], AxisTitle.prototype, "color", 2);
__decorateClass([
  Validate(TEXT_WRAP)
], AxisTitle.prototype, "wrapping", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], AxisTitle.prototype, "formatter", 2);

// packages/ag-charts-community/src/chart/axis/axisUtil.ts
function prepareAxisAnimationContext(axis) {
  const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);
  const min = Math.floor(requestedRangeMin);
  const max = Math.ceil(requestedRangeMax);
  return { min, max, visible: min !== max };
}
var fullCircle = Math.PI * 2;
var halfCircle = fullCircle / 2;
function normaliseEndRotation(start, end) {
  const directDistance = Math.abs(end - start);
  if (directDistance < halfCircle) {
    return end;
  } else if (start > end) {
    return end + fullCircle;
  }
  return end - fullCircle;
}
function prepareAxisAnimationFunctions(ctx) {
  const outOfBounds = (y, range3) => {
    const [min = ctx.min, max = ctx.max] = findMinMax(range3 ?? []);
    return y < min || y > max;
  };
  const tick = {
    fromFn(node, datum, status) {
      let y = node.y1 + node.translationY;
      let opacity = node.opacity;
      if (status === "added" || outOfBounds(node.datum.translationY, node.datum.range)) {
        y = datum.translationY;
        opacity = 0;
      }
      return { y: 0, translationY: y, opacity, phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] };
    },
    toFn(_node, datum, status) {
      const y = datum.translationY;
      let opacity = 1;
      if (status === "removed") {
        opacity = 0;
      }
      return {
        y: 0,
        translationY: y,
        opacity,
        finish: {
          // Set explicit y after animation so it's pixel aligned
          y,
          translationY: 0
        }
      };
    },
    applyFn(node, props) {
      node.setProperties(props);
      node.visible = !outOfBounds(node.y);
    }
  };
  const label = {
    fromFn(node, newDatum, status) {
      const datum = node.previousDatum ?? newDatum;
      const x = datum.x;
      const y = datum.y;
      const rotationCenterX = datum.rotationCenterX;
      let translationY = Math.round(node.translationY);
      let rotation = datum.rotation;
      let opacity = node.opacity;
      if (status === "removed" || outOfBounds(datum.y, datum.range)) {
        rotation = newDatum.rotation;
      } else if (status === "added" || outOfBounds(node.datum.y, node.datum.range)) {
        translationY = Math.round(datum.translationY);
        opacity = 0;
        rotation = newDatum.rotation;
      }
      return {
        x,
        y,
        rotationCenterX,
        translationY,
        rotation,
        opacity,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
      };
    },
    toFn(node, datum, status) {
      const x = datum.x;
      const y = datum.y;
      const rotationCenterX = datum.rotationCenterX;
      const translationY = Math.round(datum.translationY);
      let rotation = 0;
      let opacity = 1;
      if (status === "added") {
        opacity = 1;
        rotation = datum.rotation;
      } else if (status === "removed") {
        opacity = 0;
        rotation = datum.rotation;
      } else {
        rotation = normaliseEndRotation(node.previousDatum?.rotation ?? datum.rotation, datum.rotation);
      }
      return { x, y, rotationCenterX, translationY, rotation, opacity, finish: { rotation: datum.rotation } };
    }
  };
  const line = {
    fromFn(node, datum) {
      return {
        ...node.previousDatum ?? datum,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
      };
    },
    toFn(_node, datum) {
      return { ...datum };
    }
  };
  const group = {
    fromFn(node, _datum) {
      const { rotation, translationX, translationY } = node;
      return {
        rotation,
        translationX,
        translationY,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
      };
    },
    toFn(_node, datum) {
      const { rotation, translationX, translationY } = datum;
      return {
        rotation,
        translationX,
        translationY
      };
    }
  };
  return { tick, line, label, group };
}
function resetAxisGroupFn() {
  return (_node, datum) => {
    return {
      rotation: datum.rotation,
      rotationCenterX: datum.rotationCenterX,
      rotationCenterY: datum.rotationCenterY,
      translationX: datum.translationX,
      translationY: datum.translationY
    };
  };
}
function resetAxisSelectionFn(ctx) {
  const { visible: rangeVisible, min, max } = ctx;
  return (_node, datum) => {
    const y = datum.translationY;
    const visible = rangeVisible && y >= min && y <= max;
    return {
      y,
      translationY: 0,
      opacity: 1,
      visible
    };
  };
}
function resetAxisLabelSelectionFn() {
  return (_node, datum) => {
    return {
      x: datum.x,
      y: datum.y,
      translationY: datum.translationY,
      rotation: datum.rotation,
      rotationCenterX: datum.rotationCenterX
    };
  };
}
function resetAxisLineSelectionFn() {
  return (_node, datum) => {
    return { ...datum };
  };
}

// packages/ag-charts-community/src/chart/axis/axis.ts
var TranslatableLine = class extends Translatable(Line) {
};
var _Axis = class _Axis {
  constructor(moduleCtx, scale2) {
    this.moduleCtx = moduleCtx;
    this.scale = scale2;
    this.id = createId(this);
    this.nice = true;
    this.reverse = false;
    this.keys = [];
    this.interval = new AxisInterval();
    this.dataDomain = { domain: [], clipped: false };
    this.layoutConstraints = {
      stacked: true,
      align: "start",
      width: 100,
      unit: "percent"
    };
    this.boundSeries = [];
    this.includeInvisibleDomains = false;
    this.interactionEnabled = true;
    this.axisGroup = new TransformableGroup({ name: `${this.id}-axis`, zIndex: 2 /* AXIS */ });
    this.lineNode = this.axisGroup.appendChild(new TranslatableLine({ name: `${this.id}-Axis-line` }));
    this.tickLineGroup = this.axisGroup.appendChild(
      new Group({ name: `${this.id}-Axis-tick-lines`, zIndex: 2 /* AXIS */ })
    );
    this.tickLabelGroup = this.axisGroup.appendChild(
      new Group({ name: `${this.id}-Axis-tick-labels`, zIndex: 2 /* AXIS */ })
    );
    this.crossLineGroup = new TransformableGroup({ name: `${this.id}-CrossLines` });
    this.labelGroup = new Group({ name: `${this.id}-Labels`, zIndex: 10 /* SERIES_ANNOTATION */ });
    this.gridGroup = new TransformableGroup({ name: `${this.id}-Axis-grid` });
    this.gridLineGroup = this.gridGroup.appendChild(
      new Group({
        name: `${this.id}-gridLines`,
        zIndex: 1 /* AXIS_GRID */
      })
    );
    this.tickLineGroupSelection = Selection.select(this.tickLineGroup, TranslatableLine, false);
    this.tickLabelGroupSelection = Selection.select(
      this.tickLabelGroup,
      TransformableText,
      false
    );
    this.gridLineGroupSelection = Selection.select(this.gridLineGroup, TranslatableLine, false);
    this._crossLines = [];
    this.line = new AxisLine();
    this.tick = new AxisTick();
    this.gridLine = new AxisGridLine();
    this.label = this.createLabel();
    this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;
    this.translation = { x: 0, y: 0 };
    this.rotation = 0;
    // axis rotation angle in degrees
    this.layout = {
      label: {
        fractionDigits: 0,
        padding: this.label.padding,
        format: this.label.format
      }
    };
    this.destroyFns = [];
    this.range = [0, 1];
    this.visibleRange = [0, 1];
    this.title = new AxisTitle();
    this.gridLength = 0;
    /**
     * The distance between the grid ticks and the axis ticks.
     */
    this.gridPadding = 0;
    /**
     * Is used to avoid collisions between axis labels and series.
     */
    this.seriesAreaPadding = 0;
    this.tickGenerationResult = void 0;
    this.moduleMap = new ModuleMap();
    this.range = this.scale.range.slice();
    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));
    this.axisGroup.appendChild(this.title.caption.node);
    this.animationManager = moduleCtx.animationManager;
    this.animationState = new StateMachine("empty", {
      empty: {
        update: {
          target: "ready",
          action: () => this.resetSelectionNodes()
        },
        reset: "empty"
      },
      ready: {
        update: (data) => this.animateReadyUpdate(data),
        resize: () => this.resetSelectionNodes(),
        reset: "empty"
      }
    });
    let previousSize = void 0;
    this.destroyFns.push(
      this.title.caption.registerInteraction(this.moduleCtx, "afterend"),
      moduleCtx.layoutManager.addListener("layout:complete", (e) => {
        if (previousSize != null && jsonDiff(e.chart, previousSize) != null) {
          this.animationState.transition("resize");
        }
        previousSize = { ...e.chart };
      })
    );
  }
  get type() {
    return this.constructor.type ?? "";
  }
  set crossLines(value) {
    const { CrossLineConstructor } = this.constructor;
    this._crossLines.forEach((crossLine) => this.detachCrossLine(crossLine));
    this._crossLines = value.map((crossLine) => {
      const instance = new CrossLineConstructor();
      instance.set(crossLine);
      return instance;
    });
    this._crossLines.forEach((crossLine) => {
      this.attachCrossLine(crossLine);
      this.initCrossLine(crossLine);
    });
  }
  get crossLines() {
    return this._crossLines;
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    }
  }
  attachCrossLine(crossLine) {
    this.crossLineGroup.appendChild(crossLine.group);
    this.crossLineGroup.appendChild(crossLine.labelGroup);
  }
  detachCrossLine(crossLine) {
    this.crossLineGroup.removeChild(crossLine.group);
    this.crossLineGroup.removeChild(crossLine.labelGroup);
  }
  destroy() {
    this.moduleMap.destroy();
    this.destroyFns.forEach((f) => f());
  }
  updateRange() {
    const { range: rr, visibleRange: vr, scale: scale2 } = this;
    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);
    const shift = span * vr[0];
    const start = rr[0] - shift;
    scale2.setVisibleRange?.(vr);
    scale2.range = [start, start + span];
    this.crossLines.forEach((crossLine) => {
      crossLine.clippedRange = [rr[0], rr[1]];
    });
  }
  setCrossLinesVisible(visible) {
    this.crossLineGroup.visible = visible;
  }
  attachAxis(axisNode, gridNode) {
    gridNode.appendChild(this.gridGroup);
    axisNode.appendChild(this.axisGroup);
    axisNode.appendChild(this.crossLineGroup);
    axisNode.appendChild(this.labelGroup);
  }
  attachLabel(axisLabelNode) {
    this.labelGroup.append(axisLabelNode);
  }
  detachAxis(axisNode, gridNode) {
    gridNode.removeChild(this.gridGroup);
    axisNode.removeChild(this.axisGroup);
    axisNode.removeChild(this.crossLineGroup);
    axisNode.removeChild(this.labelGroup);
  }
  /**
   * Checks if a point or an object is in range.
   * @param x A point (or object's starting point).
   * @param tolerance Expands the range on both ends by this amount.
   */
  inRange(x, tolerance = 0) {
    const [min, max] = findMinMax(this.range);
    return x >= min - tolerance && x <= max + tolerance;
  }
  onFormatChange(ticks, fractionDigits, _domain, format) {
    const { scale: scale2 } = this;
    const logScale = scale2 instanceof LogScale;
    const defaultFormatter = (formatOffset) => logScale ? String : (x) => typeof x === "number" ? x.toFixed(fractionDigits + formatOffset) : String(x);
    if (format && scale2 && scale2.tickFormat) {
      try {
        const formatter = scale2.tickFormat({ ticks, specifier: format });
        this.labelFormatter = formatter;
        this.datumFormatter = formatter;
      } catch (e) {
        this.labelFormatter = defaultFormatter(0);
        this.datumFormatter = defaultFormatter(1);
        Logger.warnOnce(`the axis label format string ${format} is invalid. No formatting will be applied`);
      }
    } else {
      this.labelFormatter = defaultFormatter(0);
      this.datumFormatter = defaultFormatter(1);
    }
  }
  onGridLengthChange(value, prevValue) {
    if (prevValue ^ value) {
      this.onGridVisibilityChange();
    }
    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));
  }
  onGridVisibilityChange() {
    this.gridLineGroupSelection.clear();
  }
  createLabel() {
    return new AxisLabel();
  }
  /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   */
  update(animated = true) {
    if (!this.tickGenerationResult) {
      return;
    }
    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();
    const sideFlag = this.label.getSideFlag();
    this.updatePosition();
    const lineData = this.getAxisLineCoordinates();
    const { tickData, combinedRotation, textBaseline, textAlign, primaryTickCount } = this.tickGenerationResult;
    const previousTicks = this.tickLabelGroupSelection.nodes().map((node) => node.datum.tickId);
    this.updateSelections(lineData, tickData.ticks, {
      combinedRotation,
      textAlign,
      textBaseline,
      range: this.scale.range
    });
    if (!animated || this.animationManager.isSkipped()) {
      this.resetSelectionNodes();
    } else {
      const diff2 = this.calculateUpdateDiff(previousTicks, tickData);
      this.animationState.transition("update", diff2);
    }
    this.updateAxisLine();
    this.updateLabels();
    this.updateVisibility();
    this.updateGridLines(sideFlag);
    this.updateTickLines();
    this.updateTitle({ anyTickVisible: tickData.ticks.length > 0 });
    this.updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation });
    this.updateLayoutState(tickData.fractionDigits);
    return primaryTickCount;
  }
  getAxisLineCoordinates() {
    const [min, max] = findMinMax(this.range);
    return { x: 0, y1: min, y2: max };
  }
  getTickLineCoordinates(datum) {
    const sideFlag = this.label.getSideFlag();
    const x = sideFlag * this.getTickSize();
    const x1 = Math.min(0, x);
    const x2 = x1 + Math.abs(x);
    const y = datum.translationY;
    return { x1, x2, y };
  }
  getTickLabelProps(datum, params) {
    const { label } = this;
    const { combinedRotation, textBaseline, textAlign, range: range3 } = params;
    const text = datum.tickLabel;
    const sideFlag = label.getSideFlag();
    const labelX = sideFlag * (this.getTickSize() + label.padding + this.seriesAreaPadding);
    const visible = text !== "" && text != null;
    return {
      tickId: datum.tickId,
      translationY: datum.translationY,
      fill: label.color,
      fontFamily: label.fontFamily,
      fontSize: label.fontSize,
      fontStyle: label.fontStyle,
      fontWeight: label.fontWeight,
      rotation: combinedRotation,
      rotationCenterX: labelX,
      text,
      textAlign,
      textBaseline,
      visible,
      x: labelX,
      y: 0,
      range: range3
    };
  }
  getTickSize() {
    return this.tick.enabled ? this.tick.size : 6;
  }
  setTitleProps(caption, params) {
    const { title } = this;
    if (!title.enabled) {
      caption.enabled = false;
      caption.node.visible = false;
      return;
    }
    caption.color = title.color;
    caption.fontFamily = title.fontFamily;
    caption.fontSize = title.fontSize;
    caption.fontStyle = title.fontStyle;
    caption.fontWeight = title.fontWeight;
    caption.enabled = title.enabled;
    caption.wrapping = title.wrapping;
    const titleNode = caption.node;
    const padding = (title.spacing ?? 0) + params.spacing;
    const sideFlag = this.label.getSideFlag();
    const parallelFlipRotation = normalizeAngle360(this.rotation);
    const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;
    const rotation = titleRotationFlag * sideFlag * Math.PI / 2;
    const textBaseline = titleRotationFlag === 1 ? "bottom" : "top";
    const { range: range3 } = this;
    const x = Math.floor(titleRotationFlag * sideFlag * (range3[0] + range3[1]) / 2);
    const y = sideFlag === -1 ? Math.floor(titleRotationFlag * -padding) : Math.floor(-padding);
    const { callbackCache } = this.moduleCtx;
    const { formatter = (p) => p.defaultValue } = title;
    const text = callbackCache.call(formatter, this.getTitleFormatterParams());
    caption.text = text;
    titleNode.setProperties({ visible: true, text, textBaseline, x, y, rotation });
  }
  calculateLayout(domain, primaryTickCount) {
    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();
    const sideFlag = this.label.getSideFlag();
    const labelX = sideFlag * (this.getTickSize() + this.label.padding + this.seriesAreaPadding);
    this.updateScale(domain);
    this.tickGenerationResult = this.generateTicks({
      primaryTickCount,
      parallelFlipRotation,
      regularFlipRotation,
      labelX,
      sideFlag
    });
    const { tickData, combinedRotation, textBaseline, textAlign, ...ticksResult } = this.tickGenerationResult;
    this.updateLayoutState(tickData.fractionDigits);
    const boxes = [];
    const { x, y1, y2 } = this.getAxisLineCoordinates();
    const lineBox = new BBox(
      x + Math.min(sideFlag * this.seriesAreaPadding, 0),
      y1,
      this.seriesAreaPadding,
      y2 - y1
    );
    boxes.push(lineBox);
    if (this.tick.enabled) {
      tickData.ticks.forEach((datum) => {
        const { x1, x2, y } = this.getTickLineCoordinates(datum);
        const tickLineBox = new BBox(x1, y, x2 - x1, 0);
        boxes.push(tickLineBox);
      });
    }
    if (this.label.enabled) {
      const tempText = new TransformableText();
      tickData.ticks.forEach((datum) => {
        const labelProps = this.getTickLabelProps(datum, {
          combinedRotation,
          textAlign,
          textBaseline,
          range: this.scale.range
        });
        if (!labelProps.visible) {
          return;
        }
        tempText.setProperties({
          ...labelProps,
          translationY: Math.round(datum.translationY)
        });
        const box = tempText.getBBox();
        if (box) {
          boxes.push(box);
        }
      });
    }
    if (this.title?.enabled) {
      const caption = new Caption();
      const spacing = BBox.merge(boxes).width;
      this.setTitleProps(caption, { spacing });
      const titleBox = caption.node.getBBox();
      if (titleBox) {
        boxes.push(titleBox);
      }
    }
    const bbox = BBox.merge(boxes);
    const transformedBBox = this.getTransformBox(bbox);
    const anySeriesActive = this.isAnySeriesActive();
    this.crossLines.forEach((crossLine) => {
      var _a;
      crossLine.sideFlag = -sideFlag;
      crossLine.direction = rotation === -Math.PI / 2 ? "x" /* X */ : "y" /* Y */;
      if (crossLine instanceof CartesianCrossLine) {
        (_a = crossLine.label).parallel ?? (_a.parallel = this.label.parallel);
      }
      crossLine.parallelFlipRotation = parallelFlipRotation;
      crossLine.regularFlipRotation = regularFlipRotation;
      crossLine.calculateLayout?.(anySeriesActive, this.reverse);
    });
    return {
      primaryTickCount: ticksResult.primaryTickCount,
      bbox: transformedBBox
    };
  }
  updateLayoutState(fractionDigits) {
    this.layout.label = {
      fractionDigits,
      padding: this.label.padding,
      format: this.label.format
    };
  }
  getTransformBox(bbox) {
    const matrix = new Matrix();
    const { rotation, translationX, translationY } = this.getAxisTransform();
    Matrix.updateTransformMatrix(matrix, 1, 1, rotation, translationX, translationY);
    return matrix.transformBBox(bbox);
  }
  setDomain(domain) {
    this.dataDomain = this.normaliseDataDomain(domain);
    if (this.reverse) {
      this.dataDomain.domain.reverse();
    }
    this.scale.domain = this.dataDomain.domain;
  }
  updateScale(domain) {
    if (domain) {
      this.setDomain(domain);
    } else {
      this.calculateDomain();
    }
    this.updateRange();
    this.scale.interval = this.interval.step;
    if (ContinuousScale.is(this.scale)) {
      this.scale.nice = this.nice;
      this.scale.update();
    }
  }
  calculateRotations() {
    const rotation = toRadians(this.rotation);
    const parallelFlipRotation = normalizeAngle360(rotation);
    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);
    return { rotation, parallelFlipRotation, regularFlipRotation };
  }
  generateTicks({
    primaryTickCount,
    parallelFlipRotation,
    regularFlipRotation,
    labelX,
    sideFlag
  }) {
    const {
      scale: scale2,
      interval: { minSpacing, maxSpacing },
      label: { parallel, rotation, fontFamily, fontSize, fontStyle, fontWeight }
    } = this;
    const secondaryAxis = primaryTickCount !== void 0;
    const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation({
      rotation,
      parallel,
      regularFlipRotation,
      parallelFlipRotation
    });
    const initialRotation = configuredRotation + defaultRotation;
    const labelMatrix = new Matrix();
    const { maxTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });
    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);
    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;
    let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);
    const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);
    const font = TextUtils.toFontString({ fontFamily, fontSize, fontStyle, fontWeight });
    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });
    const textProps = {
      fontFamily,
      fontSize,
      fontStyle,
      fontWeight,
      textBaseline,
      textAlign
    };
    let tickData = {
      rawTicks: [],
      fractionDigits: 0,
      ticks: [],
      labelCount: 0
    };
    let index = 0;
    let autoRotation = 0;
    let labelOverlap = true;
    let labelData = [];
    let terminate = false;
    while (labelOverlap && index <= maxIterations) {
      if (terminate) {
        break;
      }
      autoRotation = 0;
      textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);
      const tickStrategies = this.getTickStrategies({ secondaryAxis, index });
      for (const strategy of tickStrategies) {
        ({ tickData, index, autoRotation, terminate } = strategy({
          index,
          tickData,
          textProps,
          labelOverlap,
          terminate,
          primaryTickCount
        }));
        const rotated = configuredRotation !== 0 || autoRotation !== 0;
        const labelRotation = initialRotation + autoRotation;
        const labelSpacing = getLabelSpacing(this.label.minSpacing, rotated);
        Matrix.updateTransformMatrix(labelMatrix, 1, 1, labelRotation, 0, 0);
        textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);
        labelData = this.createLabelData(tickData.ticks, labelX, labelMatrix, textMeasurer);
        labelOverlap = this.label.avoidCollisions ? axisLabelsOverlap(labelData, labelSpacing) : false;
      }
    }
    const combinedRotation = defaultRotation + configuredRotation + autoRotation;
    if (!secondaryAxis && tickData.rawTicks.length > 0) {
      primaryTickCount = tickData.rawTicks.length;
    }
    return { tickData, primaryTickCount, combinedRotation, textBaseline, textAlign, labelData };
  }
  getTickStrategies({
    index: iteration,
    secondaryAxis
  }) {
    const { scale: scale2, label } = this;
    const { minSpacing } = this.interval;
    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);
    const avoidLabelCollisions = label.enabled && label.avoidCollisions;
    const filterTicks = !continuous && iteration !== 0 && avoidLabelCollisions;
    const autoRotate = label.autoRotate === true && label.rotation === void 0;
    const strategies = [];
    let tickGenerationType;
    if (this.interval.values) {
      tickGenerationType = 3 /* VALUES */;
    } else if (secondaryAxis) {
      tickGenerationType = 1 /* CREATE_SECONDARY */;
    } else if (filterTicks) {
      tickGenerationType = 2 /* FILTER */;
    } else {
      tickGenerationType = 0 /* CREATE */;
    }
    const tickGenerationStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount);
    strategies.push(tickGenerationStrategy);
    if (!continuous && !isNaN(minSpacing)) {
      const tickFilterStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(2 /* FILTER */, index, tickData, terminate, primaryTickCount);
      strategies.push(tickFilterStrategy);
    }
    if (!avoidLabelCollisions) {
      return strategies;
    }
    if (autoRotate) {
      const autoRotateStrategy = ({ index, tickData, labelOverlap, terminate }) => ({
        index,
        tickData,
        autoRotation: this.getAutoRotation(labelOverlap),
        terminate
      });
      strategies.push(autoRotateStrategy);
    }
    return strategies;
  }
  createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount) {
    const { scale: scale2 } = this;
    const { step, values, minSpacing, maxSpacing } = this.interval;
    const { maxTickCount, minTickCount, defaultTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });
    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);
    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;
    let tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;
    const regenerateTicks = step === void 0 && values === void 0 && tickCount > minTickCount && (continuous || tickGenerationType === 2 /* FILTER */);
    let unchanged = true;
    while (unchanged && index <= maxIterations) {
      const prevTicks = tickData.rawTicks;
      tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;
      const { rawTicks, fractionDigits, ticks, labelCount } = this.getTicks({
        tickGenerationType,
        previousTicks: prevTicks,
        tickCount,
        minTickCount,
        maxTickCount,
        primaryTickCount
      });
      tickData.rawTicks = rawTicks;
      tickData.fractionDigits = fractionDigits;
      tickData.ticks = ticks;
      tickData.labelCount = labelCount;
      unchanged = regenerateTicks ? areArrayNumbersEqual(rawTicks, prevTicks) : false;
      index++;
    }
    const shouldTerminate = step !== void 0 || values !== void 0;
    terminate || (terminate = shouldTerminate);
    return { tickData, index, autoRotation: 0, terminate };
  }
  createLabelData(tickData, labelX, labelMatrix, textMeasurer) {
    const labelData = [];
    for (const { tickLabel, translationY } of tickData) {
      if (!tickLabel)
        continue;
      const { width, height } = textMeasurer.measureLines(tickLabel);
      const bbox = new BBox(labelX, translationY, width, height);
      const labelDatum = calculateLabelBBox(tickLabel, bbox, labelMatrix);
      labelData.push(labelDatum);
    }
    return labelData;
  }
  getAutoRotation(labelOverlap) {
    return labelOverlap ? normalizeAngle360(toRadians(this.label.autoRotateAngle ?? 0)) : 0;
  }
  getTicks({
    tickGenerationType,
    previousTicks,
    tickCount,
    minTickCount,
    maxTickCount,
    primaryTickCount
  }) {
    const { range: range3, scale: scale2, visibleRange } = this;
    let rawTicks;
    switch (tickGenerationType) {
      case 3 /* VALUES */:
        rawTicks = this.interval.values;
        if (ContinuousScale.is(scale2)) {
          const [d0, d1] = findMinMax(scale2.getDomain().map(Number));
          rawTicks = rawTicks.filter((value) => value >= d0 && value <= d1).sort((a, b) => a - b);
        }
        break;
      case 1 /* CREATE_SECONDARY */:
        if (ContinuousScale.is(scale2)) {
          rawTicks = this.updateSecondaryAxisTicks(primaryTickCount);
        } else {
          rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);
        }
        break;
      case 2 /* FILTER */:
        rawTicks = this.filterTicks(previousTicks, tickCount);
        break;
      default:
        rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);
        break;
    }
    const fractionDigits = rawTicks.reduce(
      (max, tick) => Math.max(max, typeof tick === "number" ? countFractionDigits(tick) : 0),
      0
    );
    const halfBandwidth = (scale2.bandwidth ?? 0) / 2;
    const ticks = [];
    let labelCount = 0;
    const tickIdCounts = /* @__PURE__ */ new Map();
    const start = Math.max(0, Math.floor(visibleRange[0] * rawTicks.length));
    const end = Math.min(rawTicks.length, Math.ceil(visibleRange[1] * rawTicks.length));
    const filteredTicks = rawTicks.slice(start, end);
    this.onFormatChange(filteredTicks, fractionDigits, rawTicks, this.label.format);
    for (let i = 0; i < filteredTicks.length; i++) {
      const tick = filteredTicks[i];
      const translationY = scale2.convert(tick) + halfBandwidth;
      if (range3.length > 0 && !this.inRange(translationY, 1e-3))
        continue;
      const tickLabel = this.formatTick(tick, fractionDigits, start + i);
      let tickId = tickLabel;
      if (tickIdCounts.has(tickId)) {
        const count = tickIdCounts.get(tickId);
        tickIdCounts.set(tickId, count + 1);
        tickId = `${tickId}_${count}`;
      } else {
        tickIdCounts.set(tickId, 1);
      }
      ticks.push({ tick, tickId, tickLabel, translationY: Math.floor(translationY) });
      if (tickLabel === "" || tickLabel == null) {
        continue;
      }
      labelCount++;
    }
    return { rawTicks, fractionDigits, ticks, labelCount };
  }
  filterTicks(ticks, tickCount) {
    const { minSpacing, maxSpacing } = this.interval;
    const tickSpacing = !isNaN(minSpacing) || !isNaN(maxSpacing);
    const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;
    return ticks.filter((_, i) => i % keepEvery === 0);
  }
  createTicks(tickCount, minTickCount, maxTickCount) {
    const { scale: scale2 } = this;
    if (tickCount && (ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2))) {
      scale2.tickCount = tickCount;
      scale2.minTickCount = minTickCount ?? 0;
      scale2.maxTickCount = maxTickCount ?? Infinity;
    }
    return scale2.ticks?.() ?? [];
  }
  estimateTickCount({ minSpacing, maxSpacing }) {
    if (!this.label.avoidCollisions) {
      return {
        minTickCount: ContinuousScale.defaultMaxTickCount,
        maxTickCount: ContinuousScale.defaultMaxTickCount,
        defaultTickCount: ContinuousScale.defaultMaxTickCount
      };
    }
    const rangeWithBleed = this.calculateRangeWithBleed();
    const defaultMinSpacing = Math.max(
      this.defaultTickMinSpacing,
      rangeWithBleed / ContinuousScale.defaultMaxTickCount
    );
    let clampMaxTickCount = !isNaN(maxSpacing);
    if (isNaN(minSpacing)) {
      minSpacing = defaultMinSpacing;
    }
    if (isNaN(maxSpacing)) {
      maxSpacing = rangeWithBleed;
    }
    if (minSpacing > maxSpacing) {
      if (minSpacing === defaultMinSpacing) {
        minSpacing = maxSpacing;
      } else {
        maxSpacing = minSpacing;
      }
    }
    const minRectDistance = 2;
    clampMaxTickCount && (clampMaxTickCount = minRectDistance < defaultMinSpacing);
    const maxTickCount = clamp(
      1,
      Math.floor(rangeWithBleed / minSpacing),
      clampMaxTickCount ? Math.min(Math.floor(rangeWithBleed / minRectDistance), 100) : 100
    );
    const minTickCount = Math.min(maxTickCount, Math.ceil(rangeWithBleed / maxSpacing));
    const defaultTickCount = clamp(minTickCount, ContinuousScale.defaultTickCount, maxTickCount);
    return { minTickCount, maxTickCount, defaultTickCount };
  }
  updateVisibility() {
    if (this.moduleCtx.animationManager.isSkipped()) {
      this.resetSelectionNodes();
    }
    this.tickLineGroup.visible = this.tick.enabled;
    this.gridLineGroup.visible = this.gridLine.enabled;
    this.tickLabelGroup.visible = this.label.enabled;
  }
  updateCrossLines({
    rotation,
    parallelFlipRotation,
    regularFlipRotation
  }) {
    const sideFlag = this.label.getSideFlag();
    const anySeriesActive = this.isAnySeriesActive();
    this.crossLines.forEach((crossLine) => {
      var _a;
      crossLine.sideFlag = -sideFlag;
      crossLine.direction = rotation === -Math.PI / 2 ? "x" /* X */ : "y" /* Y */;
      if (crossLine instanceof CartesianCrossLine) {
        (_a = crossLine.label).parallel ?? (_a.parallel = this.label.parallel);
      }
      crossLine.parallelFlipRotation = parallelFlipRotation;
      crossLine.regularFlipRotation = regularFlipRotation;
      crossLine.update(anySeriesActive);
    });
  }
  updateTickLines() {
    const { tick, label } = this;
    const sideFlag = label.getSideFlag();
    this.tickLineGroupSelection.each((line) => {
      line.strokeWidth = tick.width;
      line.stroke = tick.stroke;
      line.x1 = sideFlag * this.getTickSize();
      line.x2 = 0;
    });
  }
  calculateAvailableRange() {
    return findRangeExtent(this.range);
  }
  /**
   * Calculates the available range with an additional "bleed" beyond the canvas that encompasses the full axis when
   * the visible range is only a portion of the axis.
   */
  calculateRangeWithBleed() {
    const visibleScale = 1 / findRangeExtent(this.visibleRange);
    return round(this.calculateAvailableRange() * visibleScale, 2);
  }
  calculateDomain() {
    const visibleSeries = this.boundSeries.filter((s) => this.includeInvisibleDomains || s.isEnabled());
    const domains = visibleSeries.flatMap((series) => series.getDomain(this.direction));
    this.setDomain(domains);
  }
  getAxisTransform() {
    return {
      rotation: toRadians(this.rotation),
      translationX: Math.floor(this.translation.x),
      translationY: Math.floor(this.translation.y)
    };
  }
  updatePosition() {
    const { crossLineGroup, axisGroup, gridGroup, translation } = this;
    const { rotation } = this.calculateRotations();
    const translationX = Math.floor(translation.x);
    const translationY = Math.floor(translation.y);
    crossLineGroup.setProperties({ rotation, translationX, translationY });
    gridGroup.setProperties({ rotation, translationX, translationY });
    axisGroup.datum = this.getAxisTransform();
  }
  updateSecondaryAxisTicks(_primaryTickCount) {
    throw new Error("AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.");
  }
  updateSelections(lineData, data, params) {
    const getDatumId = (datum) => datum.tickId;
    const labelsData = data.map((d) => this.getTickLabelProps(d, params));
    this.lineNode.datum = lineData;
    this.gridLineGroupSelection.update(this.gridLength ? data : [], void 0, getDatumId);
    this.tickLineGroupSelection.update(data, void 0, getDatumId);
    this.tickLabelGroupSelection.update(labelsData, void 0, getDatumId);
  }
  updateAxisLine() {
    const { enabled, stroke, width } = this.line;
    this.lineNode.setProperties({ stroke, strokeWidth: enabled ? width : 0 });
  }
  updateGridLines(sideFlag) {
    const {
      gridLine: { style, width },
      gridPadding,
      gridLength
    } = this;
    if (gridLength === 0 || style.length === 0) {
      return;
    }
    this.gridLineGroupSelection.each((line, _, index) => {
      const { stroke, lineDash } = style[index % style.length];
      line.setProperties({
        x1: gridPadding,
        x2: -sideFlag * gridLength + gridPadding,
        stroke,
        strokeWidth: width,
        lineDash
      });
    });
  }
  updateLabels() {
    if (!this.label.enabled)
      return;
    this.tickLabelGroupSelection.each((node, datum) => {
      node.setProperties(datum, [
        "fill",
        "fontFamily",
        "fontSize",
        "fontStyle",
        "fontWeight",
        "text",
        "textAlign",
        "textBaseline"
      ]);
    });
  }
  updateTitle(params) {
    const { title, lineNode, tickLineGroup, tickLabelGroup } = this;
    let spacing = 0;
    if (title.enabled && params.anyTickVisible) {
      const tickBBox = Group.computeChildrenBBox([tickLineGroup, tickLabelGroup, lineNode]);
      spacing += tickBBox.width + (this.tickLabelGroup.visible ? 0 : this.seriesAreaPadding);
    }
    this.setTitleProps(title.caption, { spacing });
  }
  // For formatting (nice rounded) tick values.
  formatTick(datum, fractionDigits, index) {
    return String(this.getFormatter(index, true)(datum, fractionDigits));
  }
  // For formatting arbitrary values between the ticks.
  formatDatum(datum) {
    return String(this.getFormatter()(datum));
  }
  getFormatter(index = 0, isTickLabel) {
    const {
      label,
      labelFormatter,
      datumFormatter,
      moduleCtx: { callbackCache }
    } = this;
    if (label.formatter) {
      return (datum, fractionDigits) => callbackCache.call(label.formatter, { value: datum, index, fractionDigits }) ?? datum;
    } else if (!isTickLabel && datumFormatter) {
      return (datum) => callbackCache.call(datumFormatter, datum) ?? String(datum);
    } else if (labelFormatter) {
      return (datum) => callbackCache.call(labelFormatter, datum) ?? String(datum);
    }
    return (datum) => String(datum);
  }
  getBBox() {
    return this.axisGroup.getBBox();
  }
  getRegionNode() {
    return void 0;
  }
  initCrossLine(crossLine) {
    crossLine.scale = this.scale;
    crossLine.gridLength = this.gridLength;
  }
  isAnySeriesActive() {
    return this.boundSeries.some((s) => this.includeInvisibleDomains || s.isEnabled());
  }
  clipTickLines(x, y, width, height) {
    this.tickLineGroup.setClipRect(new BBox(x, y, width, height));
  }
  clipGrid(x, y, width, height) {
    this.gridGroup.setClipRect(new BBox(x, y, width, height));
  }
  getTitleFormatterParams() {
    const { direction } = this;
    const boundSeries = [];
    for (const series of this.boundSeries) {
      const keys = series.getKeys(direction);
      const names = series.getNames(direction);
      for (let idx = 0; idx < keys.length; idx++) {
        boundSeries.push({ key: keys[idx], name: names[idx] });
      }
    }
    return { direction, boundSeries, defaultValue: this.title?.text };
  }
  normaliseDataDomain(d) {
    return { domain: [...d], clipped: false };
  }
  getLayoutState() {
    return {
      id: this.id,
      rect: this.getBBox(),
      gridPadding: this.gridPadding,
      seriesAreaPadding: this.seriesAreaPadding,
      tickSize: this.getTickSize(),
      direction: this.direction,
      domain: this.dataDomain.domain,
      scale: this.scale,
      ...this.layout
    };
  }
  getModuleMap() {
    return this.moduleMap;
  }
  createModuleContext() {
    this.axisContext ?? (this.axisContext = this.createAxisContext());
    return { ...this.moduleCtx, parent: this.axisContext };
  }
  createAxisContext() {
    const { scale: scale2 } = this;
    return {
      axisId: this.id,
      scale: this.scale,
      direction: this.direction,
      continuous: ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2),
      keys: () => this.boundSeries.flatMap((s) => s.getKeys(this.direction)),
      seriesKeyProperties: () => this.boundSeries.reduce((keys, series) => {
        const seriesKeys = series.getKeyProperties(this.direction);
        seriesKeys.forEach((key) => {
          if (keys.indexOf(key) < 0) {
            keys.push(key);
          }
        });
        return keys;
      }, []),
      scaleValueFormatter: (specifier) => this.getScaleValueFormatter(specifier),
      scaleBandwidth: () => scale2.bandwidth ?? 0,
      scaleDomain: () => scale2.getDomain?.(),
      scaleConvert: (val) => scale2.convert(val),
      scaleInvert: OrdinalTimeScale.is(scale2) ? (val) => scale2.invertNearest?.(val) : (val) => scale2.invert?.(val),
      scaleInvertNearest: (val) => scale2.invertNearest?.(val),
      scaleStep: () => scale2.step ?? 0,
      attachLabel: (node) => this.attachLabel(node),
      inRange: (x, tolerance) => this.inRange(x, tolerance)
    };
  }
  getScaleValueFormatter(format) {
    const { scale: scale2 } = this;
    if (format && scale2 && scale2.tickFormat) {
      try {
        return scale2.tickFormat({ specifier: format });
      } catch (e) {
        Logger.warnOnce(`the format string ${format} is invalid, ignoring.`);
      }
    }
    return this.getFormatter();
  }
  animateReadyUpdate(diff2) {
    const { animationManager } = this.moduleCtx;
    const selectionCtx = prepareAxisAnimationContext(this);
    const fns = prepareAxisAnimationFunctions(selectionCtx);
    fromToMotion(this.id, "axis-group", animationManager, [this.axisGroup], fns.group);
    fromToMotion(this.id, "line", animationManager, [this.lineNode], fns.line);
    fromToMotion(
      this.id,
      "line-paths",
      animationManager,
      [this.gridLineGroupSelection, this.tickLineGroupSelection],
      fns.tick,
      (_, d) => d.tickId,
      diff2
    );
    fromToMotion(
      this.id,
      "tick-labels",
      animationManager,
      [this.tickLabelGroupSelection],
      fns.label,
      (_, d) => d.tickId,
      diff2
    );
  }
  resetSelectionNodes() {
    const { gridLineGroupSelection, tickLineGroupSelection, tickLabelGroupSelection, lineNode } = this;
    const selectionCtx = prepareAxisAnimationContext(this);
    resetMotion([this.axisGroup], resetAxisGroupFn());
    resetMotion([gridLineGroupSelection, tickLineGroupSelection], resetAxisSelectionFn(selectionCtx));
    resetMotion([tickLabelGroupSelection], resetAxisLabelSelectionFn());
    resetMotion([lineNode], resetAxisLineSelectionFn());
  }
  calculateUpdateDiff(previous, tickData) {
    const added = /* @__PURE__ */ new Set();
    const removed = /* @__PURE__ */ new Set();
    const tickMap = {};
    const tickCount = Math.max(previous.length, tickData.ticks.length);
    for (let i = 0; i < tickCount; i++) {
      const tickDatum = tickData.ticks[i];
      const prev = previous[i];
      const tick = tickDatum?.tickId;
      tickMap[tick ?? prev] = tickDatum;
      if (prev === tick) {
        continue;
      }
      if (removed.has(tick)) {
        removed.delete(tick);
      } else if (tick) {
        added.add(tick);
      }
      if (added.has(prev)) {
        added.delete(prev);
      } else if (prev) {
        removed.add(prev);
      }
    }
    return { changed: added.size > 0 || removed.size > 0, added, removed };
  }
  isReversed() {
    return this.reverse;
  }
};
_Axis.defaultTickMinSpacing = 50;
_Axis.CrossLineConstructor = CartesianCrossLine;
__decorateClass([
  Validate(BOOLEAN)
], _Axis.prototype, "nice", 2);
__decorateClass([
  Validate(BOOLEAN)
], _Axis.prototype, "reverse", 2);
__decorateClass([
  Validate(STRING_ARRAY)
], _Axis.prototype, "keys", 2);
__decorateClass([
  Validate(OBJECT)
], _Axis.prototype, "interval", 2);
__decorateClass([
  Validate(OBJECT)
], _Axis.prototype, "title", 2);
__decorateClass([
  ObserveChanges((target, value, oldValue) => target.onGridLengthChange(value, oldValue))
], _Axis.prototype, "gridLength", 2);
var Axis = _Axis;

// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts
var CartesianAxisLabel = class extends AxisLabel {
  constructor() {
    super(...arguments);
    this.autoRotateAngle = 335;
  }
};
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], CartesianAxisLabel.prototype, "autoRotate", 2);
__decorateClass([
  Validate(DEGREE)
], CartesianAxisLabel.prototype, "autoRotateAngle", 2);

// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts
var _CartesianAxis = class _CartesianAxis extends Axis {
  constructor() {
    super(...arguments);
    this.thickness = 0;
  }
  static is(value) {
    return value instanceof _CartesianAxis;
  }
  get direction() {
    return this.position === "top" || this.position === "bottom" ? "x" /* X */ : "y" /* Y */;
  }
  updateDirection() {
    switch (this.position) {
      case "top":
        this.rotation = -90;
        this.label.mirrored = true;
        this.label.parallel = true;
        break;
      case "right":
        this.rotation = 0;
        this.label.mirrored = true;
        this.label.parallel = false;
        break;
      case "bottom":
        this.rotation = -90;
        this.label.mirrored = false;
        this.label.parallel = true;
        break;
      case "left":
        this.rotation = 0;
        this.label.mirrored = false;
        this.label.parallel = false;
        break;
    }
    if (this.axisContext) {
      this.axisContext.position = this.position;
      this.axisContext.direction = this.direction;
    }
  }
  update(animated) {
    this.updateDirection();
    return super.update(animated);
  }
  calculateLayout(domain, primaryTickCount) {
    this.updateDirection();
    return super.calculateLayout(domain, primaryTickCount);
  }
  createAxisContext() {
    return { ...super.createAxisContext(), position: this.position };
  }
  createLabel() {
    return new CartesianAxisLabel();
  }
  getRegionNode() {
    return this.axisGroup;
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER)
], _CartesianAxis.prototype, "thickness", 2);
__decorateClass([
  Validate(POSITION)
], _CartesianAxis.prototype, "position", 2);
var CartesianAxis = _CartesianAxis;

// packages/ag-charts-community/src/chart/axis/categoryAxis.ts
var _CategoryAxis = class _CategoryAxis extends CartesianAxis {
  constructor(moduleCtx, scale2 = new BandScale()) {
    super(moduleCtx, scale2);
    this.groupPaddingInner = 0.1;
    this.includeInvisibleDomains = true;
  }
  static is(value) {
    return value instanceof _CategoryAxis;
  }
  normaliseDataDomain(d) {
    const domain = [];
    const uniqueValues = /* @__PURE__ */ new Set();
    for (const v of d) {
      const key = v instanceof Date ? v.getTime() : v;
      if (!uniqueValues.has(key)) {
        uniqueValues.add(key);
        domain.push(v);
      }
    }
    return { domain, clipped: false };
  }
  updateScale(domain) {
    let { paddingInner, paddingOuter } = this;
    if (!isFiniteNumber(paddingInner) || !isFiniteNumber(paddingOuter)) {
      const padding = this.reduceBandScalePadding();
      paddingInner ?? (paddingInner = padding.inner);
      paddingOuter ?? (paddingOuter = padding.outer);
    }
    this.scale.paddingInner = paddingInner ?? 0;
    this.scale.paddingOuter = paddingOuter ?? 0;
    super.updateScale(domain);
  }
  reduceBandScalePadding() {
    return this.boundSeries.reduce(
      (result, series) => {
        const padding = series.getBandScalePadding?.();
        if (padding) {
          if (result.inner > padding.inner) {
            result.inner = padding.inner;
          }
          if (result.outer < padding.outer) {
            result.outer = padding.outer;
          }
        }
        return result;
      },
      { inner: Infinity, outer: -Infinity }
    );
  }
};
_CategoryAxis.className = "CategoryAxis";
_CategoryAxis.type = "category";
__decorateClass([
  Validate(RATIO)
], _CategoryAxis.prototype, "groupPaddingInner", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], _CategoryAxis.prototype, "paddingInner", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], _CategoryAxis.prototype, "paddingOuter", 2);
var CategoryAxis = _CategoryAxis;

// packages/ag-charts-community/src/chart/axis/tree.ts
var TreeNode = class {
  // current number in sibling group (index)
  constructor(label = "", parent, number2 = 0) {
    this.x = 0;
    this.y = 0;
    this.subtreeLeft = NaN;
    this.subtreeRight = NaN;
    this.screenX = 0;
    this.screenY = 0;
    this.children = [];
    this.leafCount = 0;
    this.prelim = 0;
    this.mod = 0;
    this.ancestor = this;
    this.change = 0;
    this.shift = 0;
    this.label = label;
    this.parent = parent;
    this.depth = parent ? parent.depth + 1 : 0;
    this.number = number2;
  }
  getLeftSibling() {
    return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : void 0;
  }
  getLeftmostSibling() {
    return this.number > 0 && this.parent ? this.parent.children[0] : void 0;
  }
  // traverse the left contour of a subtree, return the successor of v on this contour
  nextLeft() {
    return this.children ? this.children[0] : this.thread;
  }
  // traverse the right contour of a subtree, return the successor of v on this contour
  nextRight() {
    return this.children ? this.children[this.children.length - 1] : this.thread;
  }
  getSiblings() {
    return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];
  }
};
function ticksToTree(ticks, pad2 = true) {
  const root = new TreeNode();
  let depth = 0;
  if (pad2) {
    ticks.forEach((tick) => depth = Math.max(depth, tick.labels.length));
  }
  ticks.forEach((tick) => {
    if (pad2) {
      while (tick.labels.length < depth) {
        tick.labels.unshift("");
      }
    }
    insertTick(root, tick);
  });
  return root;
}
function insertTick(root, tick) {
  const pathParts = tick.labels.slice().reverse();
  const lastPartIndex = pathParts.length - 1;
  pathParts.forEach((pathPart, partIndex) => {
    const children = root.children;
    const existingNode = children.find((child) => child.label === pathPart);
    const isNotLeaf = partIndex !== lastPartIndex;
    if (existingNode && isNotLeaf) {
      root = existingNode;
    } else {
      const node = new TreeNode(pathPart, root);
      node.number = children.length;
      children.push(node);
      if (isNotLeaf) {
        root = node;
      }
    }
  });
}
function moveSubtree(wm, wp, shift) {
  const subtrees = wp.number - wm.number;
  const ratio2 = shift / subtrees;
  wp.change -= ratio2;
  wp.shift += shift;
  wm.change += ratio2;
  wp.prelim += shift;
  wp.mod += shift;
}
function ancestor(vim, v, defaultAncestor) {
  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;
}
function executeShifts(v) {
  const children = v.children;
  if (children) {
    let shift = 0;
    let change = 0;
    for (let i = children.length - 1; i >= 0; i--) {
      const w = children[i];
      w.prelim += shift;
      w.mod += shift;
      change += w.change;
      shift += w.shift + change;
    }
  }
}
function apportion(v, defaultAncestor, distance3) {
  const w = v.getLeftSibling();
  if (w) {
    let vop = v;
    let vip = v;
    let vim = w;
    let vom = vip.getLeftmostSibling();
    let sip = vip.mod;
    let sop = vop.mod;
    let sim = vim.mod;
    let som = vom.mod;
    while (vim.nextRight() && vip.nextLeft()) {
      vim = vim.nextRight();
      vip = vip.nextLeft();
      vom = vom.nextLeft();
      vop = vop.nextRight();
      vop.ancestor = v;
      const shift = vim.prelim + sim - (vip.prelim + sip) + distance3;
      if (shift > 0) {
        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);
        sip += shift;
        sop += shift;
      }
      sim += vim.mod;
      sip += vip.mod;
      som += vom.mod;
      sop += vop.mod;
    }
    if (vim.nextRight() && !vop.nextRight()) {
      vop.thread = vim.nextRight();
      vop.mod += sim - sop;
    } else {
      if (vip.nextLeft() && !vom.nextLeft()) {
        vom.thread = vip.nextLeft();
        vom.mod += sip - som;
      }
      defaultAncestor = v;
    }
  }
  return defaultAncestor;
}
function firstWalk(node, distance3) {
  const children = node.children;
  if (children.length) {
    let defaultAncestor = children[0];
    children.forEach((child) => {
      firstWalk(child, distance3);
      defaultAncestor = apportion(child, defaultAncestor, distance3);
    });
    executeShifts(node);
    const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;
    const leftSibling = node.getLeftSibling();
    if (leftSibling) {
      node.prelim = leftSibling.prelim + distance3;
      node.mod = node.prelim - midpoint;
    } else {
      node.prelim = midpoint;
    }
  } else {
    const leftSibling = node.getLeftSibling();
    node.prelim = leftSibling ? leftSibling.prelim + distance3 : 0;
  }
}
var Dimensions = class {
  constructor() {
    this.top = Infinity;
    this.right = -Infinity;
    this.bottom = -Infinity;
    this.left = Infinity;
  }
  update(node, xy) {
    const { x, y } = xy(node);
    if (x > this.right) {
      this.right = x;
    }
    if (x < this.left) {
      this.left = x;
    }
    if (y > this.bottom) {
      this.bottom = y;
    }
    if (y < this.top) {
      this.top = y;
    }
  }
};
function secondWalk(v, m, layout) {
  v.x = v.prelim + m;
  v.y = v.depth;
  layout.update(v);
  v.children.forEach((w) => secondWalk(w, m + v.mod, layout));
}
function thirdWalk(v) {
  const children = v.children;
  let leafCount = 0;
  children.forEach((w) => {
    thirdWalk(w);
    if (w.children.length) {
      leafCount += w.leafCount;
    } else {
      leafCount++;
    }
  });
  v.leafCount = leafCount;
  if (children.length) {
    v.subtreeLeft = children[0].subtreeLeft;
    v.subtreeRight = children[v.children.length - 1].subtreeRight;
    v.x = (v.subtreeLeft + v.subtreeRight) / 2;
  } else {
    v.subtreeLeft = v.x;
    v.subtreeRight = v.x;
  }
}
function treeLayout(root) {
  const layout = new TreeLayout();
  firstWalk(root, 1);
  secondWalk(root, -root.prelim, layout);
  thirdWalk(root);
  return layout;
}
var TreeLayout = class {
  constructor() {
    this.dimensions = new Dimensions();
    this.leafCount = 0;
    this.nodes = [];
    // One might want to process leaf nodes separately from the rest of the tree.
    // For example, position labels corresponding to leafs vertically, rather than horizontally.
    this.leafNodes = [];
    this.nonLeafNodes = [];
    this.depth = 0;
  }
  update(node) {
    this.dimensions.update(node, (n) => ({ x: n.x, y: n.y }));
    if (node.children.length) {
      this.nonLeafNodes.push(node);
    } else {
      this.leafCount++;
      this.leafNodes.push(node);
    }
    if (node.depth > this.depth) {
      this.depth = node.depth;
    }
    this.nodes.push(node);
  }
  resize(width, height, shiftX = 0, shiftY = 0, flipX = false) {
    const xSteps = this.leafCount - 1;
    const ySteps = this.depth;
    const dimensions = this.dimensions;
    let scalingX = 1;
    let scalingY = 1;
    if (width > 0 && xSteps) {
      const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;
      const desiredSpacingX = width / xSteps;
      scalingX = desiredSpacingX / existingSpacingX;
      if (flipX) {
        scalingX = -scalingX;
      }
    }
    if (height > 0 && ySteps) {
      const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;
      const desiredSpacingY = height / ySteps;
      scalingY = desiredSpacingY / existingSpacingY;
    }
    const screenDimensions = new Dimensions();
    this.nodes.forEach((node) => {
      node.screenX = node.x * scalingX;
      node.screenY = node.y * scalingY;
      screenDimensions.update(node, (n) => ({ x: n.screenX, y: n.screenY }));
    });
    const offsetX = -screenDimensions.left;
    const offsetY = -screenDimensions.top;
    this.nodes.forEach((node) => {
      node.screenX += offsetX + shiftX;
      node.screenY += offsetY + shiftY;
    });
  }
};

// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts
var GroupedCategoryAxisLabel = class extends AxisLabel {
  constructor() {
    super(...arguments);
    this.grid = false;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], GroupedCategoryAxisLabel.prototype, "grid", 2);
var GroupedCategoryAxis = class extends CartesianAxis {
  constructor(moduleCtx) {
    const scale2 = new BandScale();
    scale2.paddingOuter = 0.1;
    scale2.paddingInner = scale2.paddingOuter * 2;
    super(moduleCtx, scale2);
    // Label scale (labels are positioned between ticks, tick count = label count + 1).
    // We don't call is `labelScale` for consistency with other axes.
    this.tickScale = new BandScale();
    this.line = new AxisLine();
    this.label = new GroupedCategoryAxisLabel();
    this.labelColor = "rgba(87, 87, 87, 1)";
    this.includeInvisibleDomains = true;
    const { tickLineGroup, tickLabelGroup, gridLineGroup, tickScale } = this;
    tickScale.paddingInner = 1;
    tickScale.paddingOuter = 0;
    this.gridLineSelection = Selection.select(gridLineGroup, Line);
    this.axisLineSelection = Selection.select(tickLineGroup, Line);
    this.separatorSelection = Selection.select(tickLineGroup, Line);
    this.labelSelection = Selection.select(tickLabelGroup, TransformableText);
    this.lineNode.visible = false;
  }
  updateRange() {
    const { range: rr, visibleRange: vr, scale: scale2 } = this;
    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);
    const shift = span * vr[0];
    const start = rr[0] - shift;
    this.tickScale.range = scale2.range = [start, start + span];
    this.resizeTickTree();
  }
  resizeTickTree() {
    const s = this.scale;
    const range3 = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;
    const layout = this.tickTreeLayout;
    const lineHeight = this.lineHeight;
    if (layout) {
      layout.resize(
        Math.abs(range3[1] - range3[0]),
        layout.depth * lineHeight,
        (Math.min(range3[0], range3[1]) || 0) + (s.bandwidth ?? 0) / 2,
        -layout.depth * lineHeight,
        range3[1] - range3[0] < 0
      );
    }
  }
  get lineHeight() {
    return this.label.fontSize * 1.5;
  }
  /**
   * The length of the grid. The grid is only visible in case of a non-zero value.
   */
  onGridVisibilityChange() {
    this.gridLineSelection.clear();
    this.labelSelection.clear();
  }
  calculateDomain() {
    const { direction } = this;
    let isNumericX = null;
    const flatDomains = this.boundSeries.filter((s) => s.visible).flatMap((series) => {
      if (direction === "y" /* Y */ || isNumericX) {
        return series.getDomain(direction);
      }
      if (isNumericX === null) {
        const domain2 = series.getDomain(direction);
        isNumericX = isNumber(domain2[0]);
        return domain2;
      }
      return [];
    });
    this.setDomain(extent(flatDomains) ?? unique(flatDomains));
    const { domain } = this.dataDomain;
    this.tickTreeLayout = treeLayout(ticksToTree(domain));
    this.tickScale.domain = domain.concat("");
    this.resizeTickTree();
  }
  /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   * Supposed to be called _manually_ after changing _any_ of the axis properties.
   * This allows to bulk set axis properties before updating the nodes.
   * The node changes made by this method are rendered on the next animation frame.
   * We could schedule this method call automatically on the next animation frame
   * when any of the axis properties change (the way we do when properties of scene graph's
   * nodes change), but this will mean that we first wait for the next animation
   * frame to make changes to the nodes of the axis, then wait for another animation
   * frame to render those changes. It's nice to have everything update automatically,
   * but this extra level of async indirection will not just introduce an unwanted delay,
   * it will also make it harder to reason about the program.
   */
  update() {
    if (!this.computedLayout) {
      return;
    }
    this.updatePosition();
    this.updateTitleCaption();
    this.updateCategoryLabels();
    this.updateSeparators();
    this.updateAxisLines();
    this.updateCategoryGridLines();
    this.resetSelectionNodes();
  }
  updateTitleCaption() {
    this.title.caption.node.visible = false;
  }
  updateCategoryLabels() {
    if (!this.computedLayout)
      return;
    const { tickLabelLayout } = this.computedLayout;
    const labelSelection = this.labelSelection.update(tickLabelLayout);
    labelSelection.each((node, datum) => {
      node.setProperties(datum);
    });
  }
  updateSeparators() {
    if (!this.computedLayout)
      return;
    const { separatorLayout } = this.computedLayout;
    const { range: range3 } = this;
    const epsilon2 = 1e-7;
    const separatorSelection = this.separatorSelection.update(separatorLayout);
    separatorSelection.each((line, datum) => {
      line.x1 = datum.x1;
      line.x2 = datum.x2;
      line.y1 = datum.y;
      line.y2 = datum.y;
      line.visible = this.tick.enabled && datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2;
      line.stroke = this.tick.stroke;
      line.strokeWidth = 1;
    });
  }
  updateAxisLines() {
    if (!this.computedLayout)
      return;
    const { axisLineLayout } = this.computedLayout;
    const axisLineSelection = this.axisLineSelection.update(axisLineLayout);
    axisLineSelection.each((line, datum) => {
      line.setProperties(datum);
      line.stroke = this.line.stroke;
      line.strokeWidth = this.line.width;
    });
  }
  updateCategoryGridLines() {
    const { gridLength, gridLine, label, range: range3, tickScale } = this;
    const ticks = tickScale.ticks();
    const sideFlag = label.getSideFlag();
    const gridSelection = this.gridLineSelection.update(gridLength ? ticks : []);
    if (gridLength) {
      const { width, style } = gridLine;
      const styleCount = style.length;
      gridSelection.each((line, datum, index) => {
        const y = Math.round(tickScale.convert(datum));
        const { stroke, lineDash } = style[index % styleCount];
        line.visible = gridLine.enabled && y >= range3[0] && y <= range3[1];
        line.x1 = 0;
        line.x2 = -sideFlag * gridLength;
        line.y1 = y;
        line.y2 = y;
        line.stroke = stroke;
        line.strokeWidth = width;
        line.lineDash = lineDash;
      });
    }
  }
  computeLayout() {
    this.updateDirection();
    this.calculateDomain();
    this.updateRange();
    const {
      scale: scale2,
      label,
      label: { parallel },
      moduleCtx: { callbackCache },
      range: range3,
      title,
      title: { formatter = (p) => p.defaultValue } = {}
    } = this;
    const rangeStart = scale2.range[0];
    const rangeEnd = scale2.range[1];
    const rangeLength = Math.abs(rangeEnd - rangeStart);
    const bandwidth = rangeLength / scale2.domain.length || 0;
    const keepEvery = Math.ceil(label.fontSize / bandwidth);
    const rotation = toRadians(this.rotation);
    const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;
    const sideFlag = label.getSideFlag();
    const lineHeight = this.lineHeight;
    const tickTreeLayout = this.tickTreeLayout;
    const labels = scale2.ticks();
    const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];
    const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;
    const isCaptionEnabled = title?.enabled && labels.length > 0;
    const { defaultRotation, configuredRotation, parallelFlipFlag } = calculateLabelRotation({
      rotation: label.rotation,
      parallel,
      regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),
      parallelFlipRotation: normalizeAngle360(rotation)
    });
    const tickLabelLayout = [];
    const copyLabelProps = (node) => {
      return {
        fill: node.fill,
        fontFamily: node.fontFamily,
        fontSize: node.fontSize,
        fontStyle: node.fontStyle,
        fontWeight: node.fontWeight,
        rotation: node.rotation,
        rotationCenterX: node.rotationCenterX,
        rotationCenterY: node.rotationCenterY,
        text: node.text,
        textAlign: node.textAlign,
        textBaseline: node.textBaseline,
        translationX: node.translationX,
        translationY: node.translationY,
        visible: node.visible,
        x: node.x,
        y: node.y
      };
    };
    const labelBBoxes = /* @__PURE__ */ new Map();
    let maxLeafLabelWidth = 0;
    const tempText = new TransformableText();
    const setLabelProps = (datum, index) => {
      if (index === 0) {
        if (isCaptionEnabled) {
          const text = callbackCache.call(formatter, this.getTitleFormatterParams());
          tempText.setProperties({
            text,
            fill: title.color,
            fontFamily: title.fontFamily,
            fontSize: title.fontSize,
            fontStyle: title.fontStyle,
            fontWeight: title.fontWeight,
            textAlign: "center",
            textBaseline: "hanging",
            translationX: datum.screenY - title.fontSize * 0.25,
            translationY: datum.screenX
          });
          return true;
        }
        return false;
      }
      tempText.setProperties({
        fill: label.color,
        fontFamily: label.fontFamily,
        fontSize: label.fontSize,
        fontStyle: label.fontStyle,
        fontWeight: label.fontWeight,
        textAlign: "center",
        textBaseline: parallelFlipFlag === -1 ? "bottom" : "hanging",
        translationX: datum.screenY - label.fontSize * 0.25,
        translationY: datum.screenX
      });
      if (index % keepEvery !== 0) {
        return false;
      }
      if (datum.screenX < range3[0] || datum.screenX > range3[1]) {
        return false;
      }
      if (label.formatter) {
        tempText.text = callbackCache.call(label.formatter, {
          value: String(datum.label),
          index
        }) ?? String(datum.label);
      } else {
        tempText.text = String(datum.label);
      }
      return true;
    };
    treeLabels.forEach((datum, index) => {
      const isVisible = setLabelProps(datum, index);
      if (!isVisible)
        return;
      const bbox2 = tempText.getBBox();
      if (!bbox2)
        return;
      labelBBoxes.set(index, bbox2);
      const isLeaf = !datum.children.length;
      if (isLeaf && bbox2.width > maxLeafLabelWidth) {
        maxLeafLabelWidth = bbox2.width;
      }
    });
    const labelX = sideFlag * label.padding;
    const labelGrid = this.label.grid;
    const separatorData = [];
    treeLabels.forEach((datum, index) => {
      const isLeaf = !datum.children.length;
      let visible = setLabelProps(datum, index);
      tempText.x = labelX;
      tempText.y = index === 0 && isCaptionEnabled ? title.spacing ?? 0 : 0;
      tempText.rotationCenterX = labelX;
      if (isLeaf) {
        tempText.rotation = configuredRotation;
        tempText.textAlign = "end";
        tempText.textBaseline = "middle";
      } else {
        const availableRange = datum.leafCount * bandwidth;
        const bbox2 = labelBBoxes.get(index);
        tempText.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;
        if (bbox2 && bbox2.width > availableRange) {
          visible = false;
          labelBBoxes.delete(index);
        } else {
          tempText.rotation = isHorizontal ? defaultRotation : -Math.PI / 2;
        }
      }
      if (datum.parent && isLabelTree) {
        const y = isLeaf ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;
        if (isLeaf) {
          if (datum.number !== datum.children.length - 1 || labelGrid) {
            separatorData.push({
              y,
              x1: 0,
              x2: -maxLeafLabelWidth - this.label.padding * 2
            });
          }
        } else {
          const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;
          separatorData.push({
            y,
            x1: x + lineHeight,
            x2: x
          });
        }
      }
      let props;
      if (visible) {
        const bbox2 = Transformable.toCanvas(tempText);
        if (bbox2) {
          labelBBoxes.set(index, bbox2);
        }
        props = { ...copyLabelProps(tempText), visible };
      } else {
        labelBBoxes.delete(index);
        props = { visible };
      }
      tickLabelLayout.push(props);
    });
    let minX = 0;
    separatorData.forEach((d) => minX = Math.min(minX, d.x2));
    separatorData.push({
      y: Math.max(rangeStart, rangeEnd),
      x1: 0,
      x2: minX
    });
    const separatorLayout = [];
    const separatorBoxes = [];
    const epsilon2 = 1e-7;
    separatorData.forEach((datum) => {
      if (datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2) {
        const { x1, x2, y } = datum;
        const separatorBox = new BBox(Math.min(x1, x2), y, Math.abs(x1 - x2), 0);
        separatorBoxes.push(separatorBox);
        separatorLayout.push({ x1, x2, y });
      }
    });
    const axisLineLayout = [];
    const axisLineBoxes = [];
    const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;
    for (let i = 0; i < lineCount; i++) {
      const visible = labels.length > 0 && (i === 0 || labelGrid && isLabelTree);
      const x = i > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (i - 1) * lineHeight : 0;
      const lineBox = new BBox(x, Math.min(...range3), 0, Math.abs(range3[1] - range3[0]));
      axisLineBoxes.push(lineBox);
      axisLineLayout.push({ x, y1: range3[0], y2: range3[1], visible });
    }
    const bbox = BBox.merge(iterate(labelBBoxes.values(), separatorBoxes, axisLineBoxes));
    const transformedBBox = this.getTransformBox(bbox);
    return {
      bbox: transformedBBox,
      tickLabelLayout,
      separatorLayout,
      axisLineLayout
    };
  }
  calculateLayout() {
    const { axisLineLayout, separatorLayout, tickLabelLayout, bbox } = this.computeLayout();
    this.computedLayout = { axisLineLayout, separatorLayout, tickLabelLayout };
    return { bbox, primaryTickCount: void 0 };
  }
};
GroupedCategoryAxis.className = "GroupedCategoryAxis";
GroupedCategoryAxis.type = "grouped-category";
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], GroupedCategoryAxis.prototype, "labelColor", 2);

// packages/ag-charts-community/src/module/module.ts
var BaseModuleInstance = class {
  constructor() {
    this.destroyFns = [];
  }
  destroy() {
    for (const destroyFn of this.destroyFns) {
      destroyFn();
    }
  }
};
var ModuleRegistry = class {
  constructor() {
    this.modules = [];
    this.dependencies = /* @__PURE__ */ new Map();
    this.dependents = /* @__PURE__ */ new Map();
  }
  register(...modules) {
    for (const module2 of modules) {
      this.registerDependencies(module2);
      const otherModule = this.modules.find(
        (other) => module2.type === other.type && module2.optionsKey === other.optionsKey && module2.identifier === other.identifier
      );
      if (otherModule) {
        if (module2.packageType === "enterprise" && otherModule.packageType === "community") {
          const index = this.modules.indexOf(otherModule);
          this.modules.splice(index, 1, module2);
        }
      } else {
        this.modules.push(module2);
      }
    }
  }
  hasEnterpriseModules() {
    return this.modules.some((m) => m.packageType === "enterprise");
  }
  *byType(...types) {
    const { dependents } = this;
    const yielded = /* @__PURE__ */ new Set();
    let count = 0;
    const maxCount = 3;
    const modulesByType = this.modules.filter((module2) => types.includes(module2.type));
    do {
      for (const module2 of modulesByType) {
        if (yielded.has(module2.optionsKey) || dependents.has(module2.optionsKey)) {
          continue;
        }
        yield module2;
        yielded.add(module2.optionsKey);
        for (const [key, dependencies] of dependents.entries()) {
          dependencies.delete(module2.optionsKey);
          if (dependencies.size === 0) {
            dependents.delete(key);
          }
        }
      }
      count++;
    } while (yielded.size < modulesByType.length && count < maxCount);
    if (dependents.size > 0) {
      throw new Error(`Could not resolve module dependencies: [${[...dependents.keys()]}]`);
    }
  }
  registerDependencies(module2) {
    if (module2.dependencies == null || module2.dependencies.length === 0)
      return;
    for (const key of module2.dependencies) {
      const dependencies = this.dependencies.get(key) ?? /* @__PURE__ */ new Set();
      dependencies.add(module2.optionsKey);
      this.dependencies.set(key, dependencies);
    }
    this.dependents.set(module2.optionsKey, new Set(module2.dependencies));
  }
};
var moduleRegistry = new ModuleRegistry();

// packages/ag-charts-community/src/util/async.ts
function sleep(sleepTimeoutMs) {
  return new Promise((resolve) => {
    setTimeout(() => resolve(void 0), sleepTimeoutMs);
  });
}

// packages/ag-charts-community/src/util/mutex.ts
var Mutex = class {
  constructor() {
    this.available = true;
    this.acquireQueue = [];
  }
  acquire(cb) {
    return new Promise((resolve) => {
      this.acquireQueue.push([cb, resolve]);
      if (this.available) {
        this.dispatchNext().catch((e) => Logger.errorOnce(e));
      }
    });
  }
  async acquireImmediately(cb) {
    if (!this.available) {
      return false;
    }
    await this.acquire(cb);
    return true;
  }
  async waitForClearAcquireQueue() {
    return this.acquire(async () => void 0);
  }
  async dispatchNext() {
    this.available = false;
    let [next, done] = this.acquireQueue.shift() ?? [];
    while (next) {
      try {
        await next();
        done?.();
      } catch (error) {
        Logger.error("mutex callback error", error);
        done?.();
      }
      [next, done] = this.acquireQueue.shift() ?? [];
    }
    this.available = true;
  }
};

// packages/ag-charts-community/src/util/observable.ts
var Observable = class {
  constructor() {
    this.eventListeners = /* @__PURE__ */ new Map();
  }
  addEventListener(eventType, listener) {
    if (typeof listener !== "function") {
      throw new Error("AG Charts - listener must be a Function");
    }
    const eventTypeListeners = this.eventListeners.get(eventType);
    if (eventTypeListeners) {
      eventTypeListeners.add(listener);
    } else {
      this.eventListeners.set(eventType, /* @__PURE__ */ new Set([listener]));
    }
  }
  removeEventListener(type, listener) {
    this.eventListeners.get(type)?.delete(listener);
    if (this.eventListeners.size === 0) {
      this.eventListeners.delete(type);
    }
  }
  hasEventListener(type) {
    return this.eventListeners.has(type);
  }
  clearEventListeners() {
    this.eventListeners.clear();
  }
  fireEvent(event) {
    this.eventListeners.get(event.type)?.forEach((listener) => listener(event));
  }
};

// packages/ag-charts-community/src/util/padding.ts
var Padding = class extends BaseProperties {
  constructor(top = 0, right = top, bottom = top, left = right) {
    super();
    this.top = top;
    this.right = right;
    this.bottom = bottom;
    this.left = left;
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Padding.prototype, "top", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Padding.prototype, "right", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Padding.prototype, "bottom", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Padding.prototype, "left", 2);

// packages/ag-charts-community/src/util/render.ts
function debouncedAnimationFrame(cb) {
  return buildScheduler((innerCb, _delayMs) => getWindow().requestAnimationFrame(innerCb), cb);
}
function debouncedCallback(cb) {
  return buildScheduler((innerCb, delayMs = 0) => setTimeout(innerCb, delayMs), cb);
}
function buildScheduler(scheduleFn, cb) {
  let scheduleCount = 0;
  let promiseRunning = false;
  let awaitingPromise;
  let awaitingDone;
  const busy = () => {
    return promiseRunning;
  };
  const done = () => {
    promiseRunning = false;
    awaitingDone?.();
    awaitingDone = void 0;
    awaitingPromise = void 0;
    if (scheduleCount > 0) {
      scheduleFn(scheduleCb);
    }
  };
  const scheduleCb = () => {
    const count = scheduleCount;
    scheduleCount = 0;
    promiseRunning = true;
    const maybePromise = cb({ count });
    if (!maybePromise) {
      done();
      return;
    }
    maybePromise.then(done, done);
  };
  return {
    schedule(delayMs) {
      if (scheduleCount === 0 && !busy()) {
        scheduleFn(scheduleCb, delayMs);
      }
      scheduleCount++;
    },
    async await() {
      if (!busy()) {
        return;
      }
      if (awaitingPromise == null) {
        awaitingPromise = new Promise((resolve) => {
          awaitingDone = resolve;
        });
      }
      while (busy()) {
        await awaitingPromise;
      }
    }
  };
}

// packages/ag-charts-community/src/util/eventEmitter.ts
var EventEmitter = class {
  constructor() {
    this.events = /* @__PURE__ */ new Map();
  }
  /**
   * Registers an event listener.
   * @param eventName The event name to listen for.
   * @param listener The callback to be invoked on the event.
   * @returns A function to unregister the listener.
   */
  on(eventName, listener) {
    if (!this.events.has(eventName)) {
      this.events.set(eventName, /* @__PURE__ */ new Set());
    }
    this.events.get(eventName)?.add(listener);
    return () => this.off(eventName, listener);
  }
  /**
   * Unregisters an event listener.
   * @param eventName The event name to stop listening for.
   * @param listener The callback to be removed.
   */
  off(eventName, listener) {
    const eventListeners = this.events.get(eventName);
    if (eventListeners) {
      eventListeners.delete(listener);
      if (eventListeners.size === 0) {
        this.events.delete(eventName);
      }
    }
  }
  /**
   * Emits an event to all registered listeners.
   * @param eventName The name of the event to emit.
   * @param event The event payload.
   */
  emit(eventName, event) {
    this.events.get(eventName)?.forEach((callback2) => callback2(event));
  }
  /**
   * Clears all listeners for a specific event or all events if no event name is provided.
   * @param eventName (Optional) The name of the event to clear listeners for. If not provided, all listeners for all events are cleared.
   */
  clear(eventName) {
    if (eventName) {
      this.events.delete(eventName);
    } else {
      this.events.clear();
    }
  }
};

// packages/ag-charts-community/src/chart/layout/layoutManager.ts
var LayoutElement = /* @__PURE__ */ ((LayoutElement2) => {
  LayoutElement2[LayoutElement2["Caption"] = 0] = "Caption";
  LayoutElement2[LayoutElement2["Legend"] = 1] = "Legend";
  LayoutElement2[LayoutElement2["Toolbar"] = 2] = "Toolbar";
  LayoutElement2[LayoutElement2["Navigator"] = 3] = "Navigator";
  LayoutElement2[LayoutElement2["Overlay"] = 4] = "Overlay";
  return LayoutElement2;
})(LayoutElement || {});
var LayoutManager = class {
  constructor() {
    this.events = new EventEmitter();
    this.elements = /* @__PURE__ */ new Map();
  }
  addListener(eventName, listener) {
    return this.events.on(eventName, listener);
  }
  registerElement(element2, listener) {
    if (this.elements.has(element2)) {
      this.elements.get(element2).add(listener);
    } else {
      this.elements.set(element2, /* @__PURE__ */ new Set([listener]));
    }
    return () => this.elements.get(element2)?.delete(listener);
  }
  createContext(width, height) {
    const context = new LayoutContext(width, height);
    for (const element2 of Object.values(LayoutElement)) {
      if (typeof element2 !== "number")
        continue;
      this.elements.get(element2)?.forEach((listener) => listener(context));
    }
    return context;
  }
  emitLayoutComplete(context, options) {
    const eventType = "layout:complete";
    const { width, height } = context;
    this.events.emit(eventType, {
      type: eventType,
      axes: options.axes ?? [],
      chart: { width, height },
      clipSeries: options.clipSeries ?? false,
      series: options.series
    });
  }
};
var LayoutContext = class {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.layoutBox = new BBox(0, 0, width, height);
  }
};

// packages/ag-charts-community/src/chart/chartCaptions.ts
var ChartCaptions = class {
  constructor() {
    this.title = new Caption();
    this.subtitle = new Caption();
    this.footnote = new Caption();
  }
  positionCaptions(ctx) {
    const { title, subtitle, footnote } = this;
    const maxHeight = ctx.layoutBox.height / 10;
    if (title.enabled) {
      const { spacing = subtitle.enabled ? Caption.SMALL_PADDING : Caption.LARGE_PADDING } = title;
      this.positionCaption("top", title, ctx.layoutBox, maxHeight);
      this.shrinkLayoutByCaption("top", title, ctx.layoutBox, spacing);
    }
    if (subtitle.enabled) {
      this.positionCaption("top", subtitle, ctx.layoutBox, maxHeight);
      this.shrinkLayoutByCaption("top", subtitle, ctx.layoutBox, subtitle.spacing);
    }
    if (footnote.enabled) {
      this.positionCaption("bottom", footnote, ctx.layoutBox, maxHeight);
      this.shrinkLayoutByCaption("bottom", footnote, ctx.layoutBox, footnote.spacing);
    }
  }
  positionAbsoluteCaptions(ctx) {
    const { title, subtitle, footnote } = this;
    const { rect } = ctx.series;
    for (const caption of [title, subtitle, footnote]) {
      if (caption.layoutStyle !== "overlay")
        continue;
      if (caption.textAlign === "left") {
        caption.node.x = rect.x + caption.padding;
      } else if (caption.textAlign === "right") {
        const bbox = caption.node.getBBox();
        caption.node.x = rect.x + rect.width - bbox.width - caption.padding;
      }
    }
  }
  computeX(align, layoutBox) {
    if (align === "left") {
      return layoutBox.x;
    } else if (align === "right") {
      return layoutBox.x + layoutBox.width;
    }
    return layoutBox.x + layoutBox.width / 2;
  }
  positionCaption(vAlign, caption, layoutBox, maxHeight) {
    const containerHeight = Math.max(TextUtils.getLineHeight(caption.fontSize), maxHeight);
    caption.node.x = this.computeX(caption.textAlign, layoutBox) + caption.padding;
    caption.node.y = layoutBox.y + (vAlign === "top" ? 0 : layoutBox.height) + caption.padding;
    caption.node.textBaseline = vAlign;
    caption.computeTextWrap(layoutBox.width, containerHeight);
  }
  shrinkLayoutByCaption(vAlign, caption, layoutBox, spacing = 0) {
    if (caption.layoutStyle === "block") {
      const bbox = caption.node.getBBox();
      layoutBox.shrink(
        vAlign === "top" ? Math.ceil(bbox.y - layoutBox.y + bbox.height + spacing) : Math.ceil(layoutBox.y + layoutBox.height - bbox.y + spacing),
        vAlign
      );
    }
  }
};
__decorateClass([
  Validate(OBJECT)
], ChartCaptions.prototype, "title", 2);
__decorateClass([
  Validate(OBJECT)
], ChartCaptions.prototype, "subtitle", 2);
__decorateClass([
  Validate(OBJECT)
], ChartCaptions.prototype, "footnote", 2);

// packages/ag-charts-community/src/util/listeners.ts
var Listeners = class {
  constructor() {
    this.registeredListeners = /* @__PURE__ */ new Map();
  }
  addListener(eventType, handler) {
    const record = { symbol: Symbol(eventType), handler };
    if (this.registeredListeners.has(eventType)) {
      this.registeredListeners.get(eventType).push(record);
    } else {
      this.registeredListeners.set(eventType, [record]);
    }
    return () => this.removeListener(record.symbol);
  }
  removeListener(eventSymbol) {
    for (const [type, listeners] of this.registeredListeners.entries()) {
      const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);
      if (matchIndex >= 0) {
        listeners.splice(matchIndex, 1);
        if (listeners.length === 0) {
          this.registeredListeners.delete(type);
        }
        break;
      }
    }
  }
  dispatch(eventType, ...params) {
    for (const listener of this.getListenersByType(eventType)) {
      try {
        listener.handler(...params);
      } catch (e) {
        Logger.errorOnce(e);
      }
    }
  }
  dispatchWrapHandlers(eventType, wrapFn, ...params) {
    for (const listener of this.getListenersByType(eventType)) {
      try {
        wrapFn(listener.handler, ...params);
      } catch (e) {
        Logger.errorOnce(e);
      }
    }
  }
  getListenersByType(eventType) {
    return this.registeredListeners.get(eventType) ?? [];
  }
  destroy() {
    this.registeredListeners.clear();
  }
};

// packages/ag-charts-community/src/chart/baseManager.ts
var BaseManager = class {
  constructor() {
    this.listeners = new Listeners();
    this.destroyFns = [];
  }
  addListener(type, handler) {
    return this.listeners.addListener(type, handler);
  }
  destroy() {
    this.listeners.destroy();
    this.destroyFns.forEach((fn) => fn());
  }
};

// packages/ag-charts-community/src/chart/interaction/interactionStateListener.ts
var InteractionState = /* @__PURE__ */ ((InteractionState2) => {
  InteractionState2[InteractionState2["Default"] = 32] = "Default";
  InteractionState2[InteractionState2["ZoomDrag"] = 16] = "ZoomDrag";
  InteractionState2[InteractionState2["Annotations"] = 8] = "Annotations";
  InteractionState2[InteractionState2["ContextMenu"] = 4] = "ContextMenu";
  InteractionState2[InteractionState2["Animation"] = 2] = "Animation";
  InteractionState2[InteractionState2["AnnotationsSelected"] = 1] = "AnnotationsSelected";
  InteractionState2[InteractionState2["All"] = 63] = "All";
  return InteractionState2;
})(InteractionState || {});
var InteractionStateListener = class extends BaseManager {
  // Wrapper to only broadcast events when the InteractionManager is a given state.
  addListener(type, handler, triggeringStates = 32 /* Default */) {
    return super.addListener(type, (e) => {
      const currentState = this.getState();
      if (currentState & triggeringStates) {
        handler(e);
      }
    });
  }
};

// packages/ag-charts-community/src/util/destroy.ts
var DestroyFns = class {
  constructor() {
    this.destroyFns = [];
  }
  destroy() {
    this.destroyFns.forEach((fn) => fn());
    this.destroyFns.length = 0;
  }
  setFns(destroyFns) {
    this.destroy();
    this.destroyFns = destroyFns;
  }
};

// packages/ag-charts-community/src/version.ts
var VERSION = "10.3.1";

// packages/ag-charts-community/src/api/state/historyManager.ts
var NOT_FOUND = Symbol("previous-memento-not-found");
var HistoryManager = class {
  constructor(keyNavManager) {
    this.history = [];
    this.historyIndex = -1;
    this.originators = /* @__PURE__ */ new Map();
    this.clearState = /* @__PURE__ */ new Map();
    this.maxHistoryLength = 100;
    this.debug = Debug.create(true, "history");
    this.destroyFns = new DestroyFns();
    this.destroyFns.setFns([
      keyNavManager.addListener("undo", this.undo.bind(this), 63 /* All */),
      keyNavManager.addListener("redo", this.redo.bind(this), 63 /* All */)
    ]);
  }
  destroy() {
    this.destroyFns.destroy();
  }
  addMementoOriginator(originator) {
    this.originators.set(originator.mementoOriginatorKey, originator);
    this.clearState.set(originator.mementoOriginatorKey, originator.createMemento());
    this.debugEvent("History add originator:", originator.mementoOriginatorKey);
  }
  clear() {
    this.debug(`History clear:`, Object.keys(this.originators));
    this.history = [];
    this.historyIndex = -1;
    for (const [mementoOriginatorKey, originator] of this.originators.entries()) {
      this.clearState.set(mementoOriginatorKey, originator.createMemento());
    }
  }
  record(label, ...originators) {
    if (this.historyIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.historyIndex + 1);
    }
    if (this.history.length > this.maxHistoryLength) {
      this.history = this.history.slice(-this.maxHistoryLength);
    }
    const mementos = /* @__PURE__ */ new Map();
    for (const originator of originators) {
      if (!this.originators.has(originator.mementoOriginatorKey)) {
        throw new Error(
          `Originator [${originator.mementoOriginatorKey}] has not been added to the HistoryManager.`
        );
      }
      mementos.set(originator.mementoOriginatorKey, originator.createMemento());
    }
    this.history.push({ label, mementos });
    this.historyIndex = this.history.length - 1;
    this.debugEvent(`History record: [${label}]`);
  }
  undo() {
    const undoAction = this.history[this.historyIndex];
    if (!undoAction)
      return;
    for (const mementoOriginatorKey of undoAction.mementos.keys()) {
      const previousMemento = this.findPreviousMemento(mementoOriginatorKey);
      if (previousMemento === NOT_FOUND) {
        throw new Error(`Could not find previous memento for [${mementoOriginatorKey}].`);
      }
      this.restoreMemento(mementoOriginatorKey, previousMemento);
    }
    this.historyIndex -= 1;
    this.debugEvent(`History undo: [${undoAction.label}]`);
  }
  redo() {
    const redoAction = this.history[this.historyIndex + 1];
    if (!redoAction)
      return;
    for (const [mementoOriginatorKey, memento] of redoAction.mementos.entries()) {
      this.restoreMemento(mementoOriginatorKey, memento);
    }
    this.historyIndex += 1;
    this.debugEvent(`History redo: [${redoAction.label}]`);
  }
  findPreviousMemento(mementoOriginatorKey) {
    for (let i = this.historyIndex - 1; i >= 0; i--) {
      if (this.history[i].mementos.has(mementoOriginatorKey)) {
        return this.history[i].mementos.get(mementoOriginatorKey);
      }
    }
    if (this.clearState.has(mementoOriginatorKey)) {
      return this.clearState.get(mementoOriginatorKey);
    }
    return NOT_FOUND;
  }
  restoreMemento(mementoOriginatorKey, memento) {
    this.originators.get(mementoOriginatorKey)?.restoreMemento(VERSION, VERSION, memento);
  }
  debugEvent(...logContent) {
    this.debug(
      ...logContent,
      this.history.map((action, index) => index === this.historyIndex ? `** ${action.label} **` : action.label)
    );
  }
};

// packages/ag-charts-community/src/api/state/memento.ts
var MementoCaretaker = class {
  constructor(version) {
    this.version = version.split("-")[0];
  }
  save(...originators) {
    const packet = { version: this.version };
    for (const originator of Object.values(originators)) {
      packet[originator.mementoOriginatorKey] = this.encode(originator, originator.createMemento());
    }
    return packet;
  }
  restore(blob, ...originators) {
    if (typeof blob !== "object") {
      Logger.warnOnce(`Could not restore data of type [${typeof blob}], expecting an object, ignoring.`);
      return;
    }
    if (blob == null) {
      Logger.warnOnce(`Could not restore data of type [null], expecting an object, ignoring.`);
      return;
    }
    if (!("version" in blob) || typeof blob.version !== "string") {
      Logger.warnOnce(`Could not restore data, missing [version] string in object, ignoring.`);
      return;
    }
    for (const originator of originators) {
      if (!(originator.mementoOriginatorKey in blob)) {
        continue;
      }
      const memento = this.decode(originator, blob[originator.mementoOriginatorKey]);
      if (!originator.guardMemento(memento)) {
        Logger.warnOnce(
          `Could not restore [${originator.mementoOriginatorKey}] data, value was invalid, ignoring.`,
          memento
        );
        return;
      }
      originator.restoreMemento(this.version, blob.version, memento);
    }
  }
  /**
   * Encode a memento as a serializable object, encoding any non-serializble types.
   */
  encode(originator, memento) {
    try {
      return JSON.parse(JSON.stringify(memento, this.encodeTypes));
    } catch (error) {
      throw new Error(`Failed to encode [${originator.mementoOriginatorKey}] value [${error}].`, {
        cause: error
      });
    }
  }
  /**
   * Decode an encoded memento, decoding any non-serializable types.
   */
  decode(originator, encoded) {
    try {
      return JSON.parse(JSON.stringify(encoded), this.decodeTypes);
    } catch (error) {
      throw new Error(`Failed to decode [${originator.mementoOriginatorKey}] value [${error}].`, {
        cause: error
      });
    }
  }
  encodeTypes(key, value) {
    if (isDate(this[key])) {
      return { __type: "date", value: String(this[key]) };
    }
    return value;
  }
  decodeTypes(key, value) {
    if (isObject(this[key]) && "__type" in this[key] && this[key].__type === "date") {
      return new Date(this[key].value);
    }
    return value;
  }
};

// packages/ag-charts-community/src/api/state/stateManager.ts
var StateManager = class {
  constructor() {
    this.caretaker = new MementoCaretaker(VERSION);
    this.state = /* @__PURE__ */ new Map();
  }
  setState(originator, value) {
    if (jsonDiff(this.state.get(originator.mementoOriginatorKey), value) == null) {
      return;
    }
    this.state.set(originator.mementoOriginatorKey, value);
    this.restoreState(originator);
  }
  restoreState(originator) {
    const { caretaker, state } = this;
    if (!state.has(originator.mementoOriginatorKey))
      return;
    const value = state.get(originator.mementoOriginatorKey);
    caretaker.restore({ version: caretaker.version, [originator.mementoOriginatorKey]: value }, originator);
  }
};

// packages/ag-charts-community/src/styles.css
var styles_default = '.ag-charts-wrapper,.ag-charts-wrapper:focus,.ag-charts-wrapper:after,.ag-charts-wrapper:before,.ag-charts-wrapper *,.ag-charts-wrapper *:focus,.ag-charts-wrapper *:after,.ag-charts-wrapper *:before{box-sizing:border-box;outline:none}.ag-charts-wrapper{position:relative;user-select:none}.ag-charts-canvas-center{width:100%;height:100%;position:absolute;touch-action:auto;display:flex;align-items:var(--ag-charts-align);justify-content:var(--ag-charts-justify)}.ag-charts-canvas-container,.ag-charts-canvas{position:relative;user-select:none}.ag-charts-canvas-container>*,.ag-charts-canvas>*{display:block;pointer-events:none}.ag-charts-series-area{opacity:0;pointer-events:auto;position:absolute}.ag-charts-series-area:focus-visible{opacity:1}.ag-charts-canvas-proxy,.ag-charts-canvas-overlay{inset:0;pointer-events:none;position:absolute;user-select:none}.ag-charts-canvas-overlay>*{position:absolute;pointer-events:auto}.ag-charts-theme-default,.ag-charts-theme-default-dark{--ag-charts-active-color: var(--ag-active-color, #2196f3);--ag-charts-background-color: var(--ag-background-color, #fff);--ag-charts-foreground-color: var(--ag-foreground-color, #181d1f);--ag-charts-border-color: var(--ag-border-color, #dddddd);--ag-charts-hover-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 12%);--ag-charts-font-family: "Verdana", sans-serif;--ag-charts-font-size: var(--ag-font-size, 14px);--ag-charts-size: var(--ag-grid-size, 8px);--ag-charts-border: var(--ag-charts-border-color) var(--ag-borders, solid 1px);--ag-charts-border-critical: var(--ag-borders-critical, solid 1px);--ag-charts-layer-ui-overlay: 5;--ag-charts-layer-tooltip: 4;--ag-charts-layer-toolbar: 3;--ag-charts-layer-crosshair: 2;--ag-charts-layer-annotations: 1;--ag-charts-align: center;--ag-charts-justify: center;--ag-charts-axis-label-background-color: #474747;--ag-charts-axis-label-color: #ffffff;--ag-charts-toolbar-foreground-color: var(--ag-header-foreground-color, var(--ag-charts-foreground-color));--ag-charts-toolbar-background-color: var( --ag-header-background-color, color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-foreground-color) 2%) );--ag-charts-toolbar-size: 34px;--ag-charts-toolbar-size-small: 24px;--ag-charts-toolbar-border: var(--ag-charts-border-critical, solid 1px) var(--ag-charts-border-color);--ag-charts-toolbar-hover-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 12% );--ag-charts-toolbar-focus-color: var(--ag-charts-active-color);--ag-charts-toolbar-active-background-color: var(--ag-charts-toolbar-hover-color);--ag-charts-toolbar-active-color: var(--ag-charts-active-color);--ag-charts-toolbar-disabled-foreground-color: var( --ag-disabled-foreground-color, color-mix(in srgb, transparent, var(--ag-charts-toolbar-foreground-color) 50%) );--ag-charts-toolbar-disabled-background-color: color-mix( in srgb, var(--ag-charts-toolbar-background-color), var(--ag-charts-toolbar-foreground-color) 6% );--ag-charts-toolbar-gap: var(--ag-charts-size);--ag-charts-toolbar-font-size: 13px;--ag-charts-toolbar-font-size-small: 12px;--ag-charts-toolbar-button-padding: 6px;--ag-charts-toolbar-button-padding-small: 1px;--ag-charts-popover-background-color: var(--ag-charts-toolbar-background-color);--ag-charts-popover-foreground-color: var(--ag-charts-toolbar-foreground-color);--ag-charts-popover-border: var(--ag-charts-toolbar-border);--ag-charts-popover-border-radius: var(--ag-border-radius, 4px);--ag-charts-popover-active-color: var(--ag-charts-toolbar-active-color);--ag-charts-popover-hover-color: var(--ag-charts-toolbar-hover-color);--ag-charts-popover-active-background-color: var(--ag-charts-toolbar-active-background-color);--ag-charts-popover-font-size: 14px;--ag-charts-popover-font-size-small: var(--ag-charts-toolbar-font-size-small);--ag-charts-dialog-input-group-label-color: color-mix(in srgb, transparent, var(--ag-charts-foreground-color) 55%);--ag-charts-dialog-tab-color--inactive: color-mix(in srgb, transparent, var(--ag-charts-foreground-color) 55%);--ag-charts-button-radius: var(--ag-border-radius, 4px);--ag-charts-focus-border-color: var(--ag-input-focus-border-color, var(--ag-charts-active-color));--ag-charts-focus-border: solid 1px var(--ag-charts-focus-border-color);--ag-charts-focus-border-shadow: var( --ag-input-focus-box-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color, var(--ag-charts-active-color)) 20%) );--ag-charts-focus-box-shadow: var(--box-shadow), 0 0 0 2px #fff8, var(--ag-charts-focus-border-shadow);--ag-charts-icon-font-family: "agChartsDefault";--ag-charts-icon-font-weight: normal;--ag-charts-icon-font-color: color-mix(in srgb, transparent, var(--ag-charts-foreground-color), 90%);--ag-charts-icon-size: 20px;--ag-charts-input-background-color: var(--ag-charts-background-color);--ag-charts-input-background-color--hover: var(--ag-charts-hover-color);--ag-charts-input-background-color--active: var(--ag-charts-hover-color);--ag-charts-input-border-color: var(--ag-charts-border-color);--ag-charts-input-border-color--active: var(--ag-charts-active-color);--ag-charts-input-border-radius: var(--ag-border-radius, 4px);--ag-charts-input-color--active: var(--ag-charts-active-color);--ag-charts-input-focus-outline: var(--ag-charts-focus-border);--ag-charts-input-focus-box-shadow: var(--ag-charts-focus-border-shadow);--ag-charts-input-font-family: var(--ag-charts-font-family);--ag-charts-input-font-size: var(--ag-charts-font-size);--ag-charts-input-padding: 8px;--ag-charts-input-padding-large: 10px;--ag-charts-input-placeholder-color: #888888;--ag-charts-input-spacing: 8px;--ag-charts-input-transition-duration: .25s;--ag-charts-input-transition-duration--fast: .1s;--ag-charts-input-transition-timing-function: ease-out;--ag-charts-input-checkbox-background-color: #babbbc;--ag-charts-input-checkbox-background-color--checked: var(--ag-charts-active-color)}.ag-charts-theme-default-dark{--ag-charts-background-color: var(--ag-background-color, color-mix(in srgb, #fff, #182230 97%));--ag-charts-foreground-color: var(--ag-foreground-color, #fff);--ag-charts-border-color: var(--ag-border-color, rgba(255, 255, 255, .16));--ag-charts-hover-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 18%);--ag-charts-axis-label-background-color: #9caebb;--ag-charts-axis-label-color: #000000;--ag-charts-toolbar-background-color: var(--ag-header-background-color, color-mix(in srgb, #fff, #182230 93%));--ag-charts-toolbar-hover-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 18% );--ag-charts-dialog-input-group-label-text-color: #ffffff;--ag-charts-focus-border-shadow: var( --ag-input-focus-box-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color, var(--ag-charts-active-color)) 20%) );--ag-charts-input-placeholder-color: #aaaaaa}.ag-charts-icon{display:block;width:var(--ag-charts-icon-size);height:var(--ag-charts-icon-size);speak:none;speak:never;mask:var(--icon) center / contain no-repeat;background-color:currentColor;transition:background-color .25s ease-in-out}.ag-charts-icon-align-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNyAxMGg2djFIN3pNNCA3aDEydjFINHptMSA2aDEwdjFINXoiLz48L3N2Zz4=)}.ag-charts-icon-align-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNCAxMGg2djFINHptMC0zaDEydjFINHptMCA2aDEwdjFINHoiLz48L3N2Zz4=)}.ag-charts-icon-align-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTAgMTBoNnYxaC02ek00IDdoMTJ2MUg0em0yIDZoMTB2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-arrow-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1LjI5MyA0LjVIMTIuNXYtMUgxN3Y0aC0xVjUuMjA3bC05LjY0NiA5LjY0Ny0uNzA4LS43MDh6IiBmaWxsPSIjMDAwIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03IDE2YTIuNSAyLjUgMCAxIDEtNSAwIDIuNSAyLjUgMCAwIDEgNSAwbS0yLjUgMS41YTEuNSAxLjUgMCAxIDAgMC0zIDEuNSAxLjUgMCAwIDAgMCAzIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-arrow-down-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02IDhMMS41IDhMMTAgMThMMTguNSA4TDE0IDhMMTQgM0w2IDNMNiA4Wk03IDRMNyA5SDMuNjYyNDRMMTAgMTYuNDU2TDE2LjMzNzYgOUwxMyA5TDEzIDRMNyA0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-arrow-up-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNCAxMkgxOC41TDEwIDJMMS41IDEySDZMNi4wMDAwMiAxN0gxNFYxMlpNMTMgMTZWMTFIMTYuMzM3NkwxMCAzLjU0NDA1TDMuNjYyNDQgMTFIN0w3LjAwMDAyIDE2SDEzWiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-callout-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtNC41MTRhMjYgMjYgMCAwIDAtMi4wMTcgMS41NGwtLjMxNC4yNmMtLjU1LjQ1Ny0xLjExNS45MjYtMS43NiAxLjQtLjY2OS40OTEtMS41NjItLjAxMi0xLjU2Mi0uOFYxNEg0LjVBMS41IDEuNSAwIDAgMSAzIDEyLjV6TTQuNSA0YS41LjUgMCAwIDAtLjUuNXY4YS41LjUgMCAwIDAgLjUuNWgxLjgzM3YzLjM3MmEzNiAzNiAwIDAgMCAxLjY3OC0xLjMzOGwuMzItLjI2NWEyNiAyNiAwIDAgMSAyLjIyNS0xLjY4NWwuMTI2LS4wODRIMTUuNWEuNS41IDAgMCAwIC41LS41di04YS41LjUgMCAwIDAtLjUtLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyAxdjNoMnYxMkg3djNINnYtM0g0VjRoMlYxek01IDVoM3YxMEg1ek0xMSAxNFY2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6bTEtN2gzdjZoLTN6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-close{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtNSA1IDEwIDEwTTUgMTUgMTUgNSIgc3Ryb2tlPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-comment-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy41MTMgMy45OTVhNi41IDYuNSAwIDAgMSA2LjA5OCAxMS40MWMtLjU4OC4zOTMtMS4yMTcuNTM2LTEuODI5LjU4NWExMyAxMyAwIDAgMS0xLjI3LjAxN0EyNyAyNyAwIDAgMCAxMCAxNkg0LjVhLjUuNSAwIDAgMS0uNS0uNVYxMHEwLS4yNDctLjAwNy0uNTEzYy0uMDA4LS40MTYtLjAxNi0uODU3LjAxNy0xLjI2OS4wNS0uNjEyLjE5Mi0xLjI0LjU4NS0xLjgzYTYuNSA2LjUgMCAwIDEgMi45MTgtMi4zOTNtMy41Ni42MWE1LjUgNS41IDAgMCAwLTUuNjQ2IDIuMzRjLS4yNjYuMzk3LS4zNzkuODQyLS40MiAxLjM1NC0uMDMuMzYtLjAyMi43MTgtLjAxNSAxLjEwOFE1IDkuNjg5IDUgMTB2NWg1cS4zMTEuMDAxLjU5My4wMDhjLjM5LjAwNy43NDcuMDE1IDEuMTA4LS4wMTUuNTEyLS4wNDEuOTU3LS4xNTQgMS4zNTUtLjQyYTUuNSA1LjUgMCAwIDAtMS45ODMtOS45NjciIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-crosshair-add-line{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-date-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMiAyaDF2MTZIMnptMTUgMGgxdjE2aC0xeiIgZmlsbD0iIzE4MUQxRiIvPjxwYXRoIGQ9Ik0xMy4xNTcgMTFINXYtMWg3Ljc5M0wxMSA4LjIwN2wuNzA3LS43MDcgMy4xODIgMy4xODItMy4xODIgMy4xODItLjcwNy0uNzA3eiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-date-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMyAySDJ2MTZoMXptMy41MDcgNC44OUw4LjUgNC44OTVWMTBINXYxaDMuNXY3aDF2LTdoNS4wODhsLTEuOTU3IDEuOTU3LjcwNy43MDcgMy4xODItMy4xODJMMTMuMzM4IDcuM2wtLjcwNy43MDdMMTQuNjI0IDEwSDkuNVY0LjkzMmwxLjk1NyAxLjk1Ny43MDctLjcwN0w4Ljk4MiAzIDUuOCA2LjE4MnoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-delete{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTguNDk2IDguOTk2QS41LjUgMCAwIDEgOSA5LjQ5MnY0YS41LjUgMCAxIDEtMSAuMDA4di00YS41LjUgMCAwIDEgLjQ5Ni0uNTA0TTEyIDkuNWEuNS41IDAgMCAwLTEgMHY0YS41LjUgMCAwIDAgMSAweiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTYgNVYzLjVBMi41IDIuNSAwIDAgMSA4LjUgMWgzQTIuNSAyLjUgMCAwIDEgMTQgMy41VjVoMi44MzNhLjUuNSAwIDAgMSAwIDFIMTV2MTAuMjVjMCAuNDE1LS4wNjYuODYzLS4zIDEuMjIxLS4yNTcuMzk0LS42NzIuNjEyLTEuMi42MTJoLTdjLS41MjggMC0uOTQzLS4yMTgtMS4yLS42MTItLjIzNC0uMzU4LS4zLS44MDYtLjMtMS4yMjFWNkgzLjMzM2EuNS41IDAgMCAxIDAtMXptMS0xLjVBMS41IDEuNSAwIDAgMSA4LjUgMmgzQTEuNSAxLjUgMCAwIDEgMTMgMy41VjVIN3pNNiAxNi4yNVY2aDh2MTAuMjVjMCAuMzM1LS4wNTkuNTU0LS4xMzguNjc1LS4wNTUuMDg1LS4xNC4xNTgtLjM2Mi4xNThoLTdjLS4yMjIgMC0uMzA3LS4wNzMtLjM2Mi0uMTU4LS4wOC0uMTIxLS4xMzgtLjM0LS4xMzgtLjY3NSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-disjoint-channel,.ag-charts-icon-disjoint-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTkuMDI4IDE3LjQ2YTIuMjUgMi4yNSAwIDAgMC00LjA5Mi0xLjg1bC05LjUxMS0yLjM3OGEyLjI1IDIuMjUgMCAxIDAtLjIyNS45NzRsOS40NzUgMi4zNjlhMi4yNTEgMi4yNTEgMCAwIDAgNC4zNTMuODg2bS0xLjY2Mi0xLjk2NWExLjI1IDEuMjUgMCAxIDEtLjg4NSAyLjMzOCAxLjI1IDEuMjUgMCAwIDEgLjg4NS0yLjMzOE00LjM0MyAxMy42NjlhMS4yNSAxLjI1IDAgMSAwLTIuMzM4LS44ODUgMS4yNSAxLjI1IDAgMCAwIDIuMzM4Ljg4NU0zLjk3IDguNzY5YTIuMjUgMi4yNSAwIDAgMCAxLjQ1NS0yLjExbDkuNTExLTIuMzc4YTIuMjUgMi4yNSAwIDEgMC0uMjYtLjk2NUw1LjIgNS42ODVhMi4yNSAyLjI1IDAgMSAwLTEuMjMgMy4wODRtLjM3My0yLjU0N2ExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjc1LTMuNDM4YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-drag-handle{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjcuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjxjaXJjbGUgY3g9IjEzLjc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iMTMuNzUiIGN5PSIxMS43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjExLjc1IiByPSIuNzUiIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjUiLz48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iMTEuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjwvc3ZnPg==)}.ag-charts-icon-fill-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtOC4wNzEgNC4wNi0uOTI0LS45MjQuNzA3LS43MDcgNy4yODggNy4yODgtNC45NSA0Ljk1YTMuNSAzLjUgMCAwIDEtNC45NSAwbC0xLjQxNC0xLjQxNGEzLjUgMy41IDAgMCAxIDAtNC45NXptLjcwNy43MDhMNC41MzYgOS4wMWEyLjUgMi41IDAgMCAwIDAgMy41MzZMNS45NSAxMy45NmEyLjUgMi41IDAgMCAwIDMuNTM1IDBsNC4yNDMtNC4yNDN6bTYuOSA3LjIwMi0uMzQ1LjM2My0uMzQ0LS4zNjNhLjUuNSAwIDAgMSAuNjg4IDBtLS4zNDUgMS4wOGE4IDggMCAwIDAtLjI4LjMyMyA0LjMgNC4zIDAgMCAwLS40MDkuNTgyYy0uMTEzLjIwMS0uMTQ0LjMyNi0uMTQ0LjM3OGEuODMzLjgzMyAwIDAgMCAxLjY2NyAwYzAtLjA1Mi0uMDMxLS4xNzctLjE0NC0uMzc4YTQuMyA0LjMgMCAwIDAtLjQxLS41ODIgOCA4IDAgMCAwLS4yOC0uMzIybS0uMzQ0LTEuMDguMzQ0LjM2My4zNDQtLjM2My4wMDIuMDAyLjAwNC4wMDQuMDEzLjAxMmE2IDYgMCAwIDEgLjIwNi4yMDhjLjEzMS4xMzYuMzA4LjMyNy40ODUuNTQ1LjE3Ni4yMTUuMzYzLjQ2Ny41MDcuNzI0LjEzNy4yNDMuMjczLjU1My4yNzMuODY4YTEuODMzIDEuODMzIDAgMSAxLTMuNjY3IDBjMC0uMzE1LjEzNi0uNjI1LjI3My0uODY4LjE0NC0uMjU3LjMzLS41MDkuNTA3LS43MjRhOSA5IDAgMCAxIC42NDUtLjcwOGwuMDQ2LS4wNDUuMDEzLS4wMTIuMDA0LS4wMDR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-hollow-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1vcGFjaXR5PSIuMTUiIGQ9Ik01IDVoM3YxMEg1eiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTcgMXYzaDJ2MTJIN3YzSDZ2LTNINFY0aDJWMXpNNSA1aDN2MTBINXptNyAyaDN2NmgtM3ptLTEgN1Y2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-horizontal-line,.ag-charts-icon-horizontal-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNLjUgOS41aDcuMzA2YTIuMjUgMi4yNSAwIDAgMSA0LjM4OCAwSDE5LjV2MWgtNy4zMDZhMi4yNSAyLjI1IDAgMCAxLTQuMzg4IDBILjV6bTkuNSAxLjc1YTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTQuMjQyIDIuNzIyYy0uNjEyIDAtMS4yLjI0My0xLjYzMi42NzVsLTEuMzQzIDEuMzQ0YS41LjUgMCAwIDAtLjExMi4xMTJMNC4wNSAxMS45NTljLS4yMDcuMjA3LS4zNi40Ni0uNDQ2Ljc0di4wMDFsLS42OSAyLjc2N3YuMDAyYS44Mi44MiAwIDAgMCAxLjAyMiAxLjAyMWguMDAybDIuNjM0LS44MjJjLjI4LS4wODUuNTM0LS4yMzcuNzQtLjQ0M2w3LjEwNy03LjEwOGEuNS41IDAgMCAwIC4xMTItLjExMmwxLjM0My0xLjM0M2EyLjMwOCAyLjMwOCAwIDAgMC0xLjYzMi0zLjk0TTE0LjEyMiA3bDEuMDQ0LTEuMDQ1YTEuMzA4IDEuMzA4IDAgMSAwLTEuODQ5LTEuODVMMTIuMjcxIDUuMTV6bS0yLjU1OC0xLjE0Mi02LjgwNyA2LjgwOWEuOC44IDAgMCAwLS4xOTYuMzI1bC0uNzUgMi40NjggMi40Ny0uNzQ5YS44LjggMCAwIDAgLjMyNS0uMTk0bDYuODA4LTYuODF6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTcuMzYyIDQuODczLTQuNTk0IDYuNjU0LTQuODUtMy4zMTctNC4yNTEgNi45NzctLjg1NC0uNTJMNy42MTIgNi43OWw0Ljg5OSAzLjM1IDQuMDI4LTUuODM2eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-line-style-dashed{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDR2MUgyem0xMiAwaDR2MWgtNHpNOCA5aDR2MUg4eiIvPjwvc3ZnPg==)}.ag-charts-icon-line-style-dotted{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSIyLjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSI4LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTAuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSIxMi41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjE0LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-line-style-solid{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDE2djFIMnoiLz48L3N2Zz4=)}.ag-charts-icon-line-with-markers-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTk4IDQuODg4LTMuNTU2IDQuOTE4YTIuMjUgMi4yNSAwIDEgMS0zLjg2Ni43NWwtMS40MzItLjlhMi4yNCAyLjI0IDAgMCAxLTIuMDA5LjQzNWwtMy44MjggNi40MjgtLjg2LS41MTJMNi40NSA5LjYyM2EyLjI1IDIuMjUgMCAxIDEgMy41MS0uNzYxbDEuMzI5LjgzNWEyLjI0IDIuMjQgMCAwIDEgMi41NTctLjQ5N2wzLjU0Mi00Ljg5OHptLTQuOTYgNS4xNTNhMS4yNSAxLjI1IDAgMSAwLS42NCAyLjQxOSAxLjI1IDEuMjUgMCAwIDAgLjY0LTIuNDE5TTkuMSA4LjMyMXEuMDY2LS4xOTIuMDY3LS40MDRhMS4yNSAxLjI1IDAgMSAwLS4wNjcuNDA0IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-lock,.ag-charts-icon-locked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuMjA3IDMuNzY0YTIuODk0IDIuODk0IDAgMCAwLTIuODk1IDIuODk0VjloNS43ODlWNi42NThhMi44OTQgMi44OTQgMCAwIDAtMi44OTUtMi44OTRNMTQuMSA5VjYuNjU4YTMuODk0IDMuODk0IDAgMSAwLTcuNzg5IDB2Mi4zNDlBMi41IDIuNSAwIDAgMCA0IDExLjV2M0EyLjUgMi41IDAgMCAwIDYuNSAxN2g4YTIuNSAyLjUgMCAwIDAgMi41LTIuNXYtM0EyLjUgMi41IDAgMCAwIDE0LjUgOXpNNi41IDEwQTEuNSAxLjUgMCAwIDAgNSAxMS41djNBMS41IDEuNSAwIDAgMCA2LjUgMTZoOGExLjUgMS41IDAgMCAwIDEuNS0xLjV2LTNhMS41IDEuNSAwIDAgMC0xLjUtMS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-measurer-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibTQuNDYxIDEyLjcxIDEuNTMyLTEuNTMxIDEuNDE0IDEuNDE0LjcwNy0uNzA3TDYuNyAxMC40NzJsMS41MzItMS41MzMgMiAyIC43MDctLjcwNy0yLTIgNi4wMS02LjAxIDIuODMgMi44MjhMNS4wNSAxNy43NzggMi4yMjIgMTQuOTVsMS41MzItMS41MzIgMS40MTQgMS40MTQuNzA3LS43MDd6TS44MDggMTQuOTVsLjcwNy0uNzA3TDE0LjI0MyAxLjUxNWwuNzA3LS43MDcuNzA3LjcwNyAyLjgyOCAyLjgyOC43MDcuNzA3LS43MDcuNzA3TDUuNzU3IDE4LjQ4NWwtLjcwNy43MDctLjcwNy0uNzA3LTIuODI4LTIuODI4em0xMS4wNzgtNi44MzVMMTAuNDcgNi43bC43MDctLjcwNyAxLjQxNSAxLjQxNHptLjgyNC0zLjY1NCAxIDEgLjcwOC0uNzA3LTEtMXoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-note-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtMy4yMWwtMS40NjkgMi41N2ExIDEgMCAwIDEtMS42ODIuMDg1TDcuMjQzIDE0SDQuNUExLjUgMS41IDAgMCAxIDMgMTIuNXpNNC41IDRhLjUuNSAwIDAgMC0uNS41djhhLjUuNSAwIDAgMCAuNS41aDMuMjU3bDIuMTk2IDMuMDc0TDExLjcxIDEzaDMuNzlhLjUuNSAwIDAgMCAuNS0uNXYtOGEuNS41IDAgMCAwLS41LS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNi41IDYuNUEuNS41IDAgMCAxIDcgNmg2YS41LjUgMCAwIDEgMCAxSDdhLjUuNSAwIDAgMS0uNS0uNU02LjUgOS41QS41LjUgMCAwIDEgNyA5aDZhLjUuNSAwIDAgMSAwIDFIN2EuNS41IDAgMCAxLS41LS41IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-ohlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTEzIDExaC0zdi0xaDNWM2gxdjJoNHYxaC00djExaC0xek02IDE3di0yaDN2LTFINlY0SDV2MUgydjFoM3YxMXoiLz48L3N2Zz4=)}.ag-charts-icon-pan-end{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0ibTYuNjQ2IDEzLjgxMy0uMzUzLjM1NC43MDcuNzA3LjM1NC0uMzU0ek0xMS4xNjYgMTBsLjM1NC4zNTQuMzU0LS4zNTQtLjM1NC0uMzU0ek03LjM1NSA1LjQ4IDcgNS4xMjZsLS43MDcuNzA3LjM1My4zNTR6bTAgOS4wNCA0LjE2Ni00LjE2Ni0uNzA3LS43MDgtNC4xNjcgNC4xNjd6bTQuMTY2LTQuODc0TDcuMzU0IDUuNDhsLS43MDguNzA3IDQuMTY3IDQuMTY3ek0xMy4wODMgNXYxMGgxVjV6Ii8+PC9zdmc+)}.ag-charts-icon-pan-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuNzkgNS44MzMgOC42MjUgMTBsNC4xNjYgNC4xNjctLjcwNy43MDdMNy4yMSAxMGw0Ljg3My00Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy4yMSAxNC4xNjcgMTEuMzc2IDEwIDcuMjEgNS44MzNsLjcwNy0uNzA3TDEyLjc5IDEwbC00Ljg3MyA0Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-start{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgNXYxMGgxVjV6TTkuNjI0IDEwbDQuMTY2LTQuMTY3LS43MDctLjcwN0w4LjIxIDEwbDQuODc0IDQuODc0LjcwNy0uNzA3eiIvPjwvc3ZnPg==)}.ag-charts-icon-parallel-channel,.ag-charts-icon-parallel-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNzIgNS4zMzFBMi4yNSAyLjI1IDAgMSAwIDE0LjcwNSAzLjZsLTkuNDkgNC41NjJhMi4yNSAyLjI1IDAgMSAwIC4yMDkgMS4wMWw5LjY2Mi00LjY0NmEyLjI1IDIuMjUgMCAwIDAgMi42MzQuODA1bS4zNzMtMi41NDdhMS4yNSAxLjI1IDAgMSAxLTIuMzM4Ljg4NSAxLjI1IDEuMjUgMCAwIDEgMi4zMzgtLjg4NU00LjM0MyA4LjY3YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODVNNS4zMDcgMTYuNzI4YTIuMjUgMi4yNSAwIDEgMS0uNTI1LS44NThsOS45MjMtNC43N2EyLjI1IDIuMjUgMCAxIDEgLjM4MS45MjZ6bS0uOTY0LjI3NGExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjAyMy01LjEwNmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-position-bottom{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzem0zLTNoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgMTNoOHYxSDZ6Ii8+PC9zdmc+)}.ag-charts-icon-position-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMyAxMGgxNHYxSDN6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDdoOHYxSDZ6bTAgNmg4djFINnoiLz48L3N2Zz4=)}.ag-charts-icon-position-top{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzeiIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik02IDdoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDEzaDh2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-price-label-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNC41IDNBMS41IDEuNSAwIDAgMCAzIDQuNVYxM2ExLjUgMS41IDAgMCAwIDEuNSAxLjVoLjgzM3YuMDU3Yy4yNDItLjI5OS41OTctLjUwMyAxLS41NDhWMTMuNUg0LjVBLjUuNSAwIDAgMSA0IDEzVjQuNWEuNS41IDAgMCAxIC41LS41aDExYS41LjUgMCAwIDEgLjUuNXY4YS41LjUgMCAwIDEtLjUuNWgtNC44MThsLS4xMjYuMDg0YTI2IDI2IDAgMCAwLTIuMjI1IDEuNjg1bC0uMzIuMjY1LS4wNjguMDU2YTEuNSAxLjUgMCAwIDEtMi42MDkgMS4zNTRjLjAzMy43NjMuOTA1IDEuMjM4IDEuNTYuNzU2LjY0Ni0uNDc0IDEuMjEtLjk0MyAxLjc2MS0xLjRsLjMxMy0uMjZBMjYgMjYgMCAwIDEgMTAuOTg2IDE0SDE1LjVhMS41IDEuNSAwIDAgMCAxLjUtMS41di04QTEuNSAxLjUgMCAwIDAgMTUuNSAzeiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43MTYgMTQuODE1YTIuMjUgMi4yNSAwIDEgMS00LjIxIDEuNTkzIDIuMjUgMi4yNSAwIDAgMSA0LjIxLTEuNTkzbS0xLjY2MiAxLjk2NmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS41IDYuMjI4IDcuMTY3IDguMzc2IDYuNSA3Ljc2MiA5LjUgNWwzIDIuNzYyLS42NjcuNjE0eiIgZmlsbD0iIzAwMCIvPjxwYXRoIGQ9Ik0yIDE4di0xaDE2djF6TTIgM1YyaDE2djF6IiBmaWxsPSIjMTgxRDFGIi8+PC9zdmc+)}.ag-charts-icon-reset{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuMDQgNC40NDVhNS44MSA1LjgxIDAgMCAwLTcuMjU3IDIuNDUzLjUuNSAwIDAgMS0uODY1LS41MDJBNi44MSA2LjgxIDAgMSAxIDMgOS44MTNhLjUuNSAwIDAgMSAxIDAgNS44MSA1LjgxIDAgMSAwIDguMDQtNS4zNjgiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTQuMjg5IDMuMDAyYS41LjUgMCAwIDEgLjUuNXYyLjY1NWgyLjY1NWEuNS41IDAgMCAxIDAgMUg0LjI5YS41LjUgMCAwIDEtLjUtLjVWMy41MDJhLjUuNSAwIDAgMSAuNS0uNSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-settings{--icon: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkIj48cGF0aCBkPSJNMTAgMTNhMyAzIDAgMSAwIDAtNiAzIDMgMCAwIDAgMCA2bTAtMWEyIDIgMCAxIDEtLjAwMS0zLjk5OUEyIDIgMCAwIDEgMTAgMTIiLz48cGF0aCBkPSJNMi4zMSAxNC4zNDVjLS44MTctMS40OTEuMDI3LTIuNDk5LjQ3NC0yLjg2NS41MzEtLjQzNC45NjktLjM2NS45NzItMS40OC0uMDAzLTEuMTE1LS40NDEtMS4wNDYtLjk3Mi0xLjQ4MS0uNDU0LS4zNzEtMS4zMTctMS40MDUtLjQzNC0yLjkzNmwuMDA1LS4wMDljLjg4NC0xLjUyIDIuMjA3LTEuMjkgMi43NTUtMS4wODMuNjQxLjI0My44MDEuNjU2IDEuNzY4LjEwMS45NjQtLjU2LjY4Ni0uOTA0Ljc5Ni0xLjU4Mi4wOTQtLjU3OC41NTktMS44NDMgMi4zMjYtMS44NDNoLjAxYzEuNzU5LjAwNSAyLjIyMiAxLjI2NiAyLjMxNiAxLjg0My4xMS42NzgtLjE2OCAxLjAyMi43OTYgMS41ODIuOTY3LjU1NSAxLjEyNy4xNDIgMS43NjgtLjEwMS41NDktLjIwOCAxLjg3Ni0uNDM4IDIuNzYgMS4wOTJzLjAyIDIuNTY1LS40MzQgMi45MzZjLS41MzEuNDM1LS45NjkuMzY2LS45NzIgMS40ODEuMDAzIDEuMTE1LjQ0MSAxLjA0Ni45NzIgMS40OC40NTQuMzcyIDEuMzE3IDEuNDA2LjQzNCAyLjkzN2wtLjAwNS4wMDljLS44ODQgMS41Mi0yLjIwNyAxLjI5LTIuNzU1IDEuMDgzLS42NDEtLjI0My0uODAxLS42NTYtMS43NjgtLjEwMS0uOTY0LjU2LS42ODYuOTA0LS43OTYgMS41ODEtLjA5NC41NzktLjU1OSAxLjg0NC0yLjMyNiAxLjg0NGgtLjAxYy0xLjc1OS0uMDA1LTIuMjIyLTEuMjY2LTIuMzE2LTEuODQ0LS4xMS0uNjc3LjE2OC0xLjAyMS0uNzk2LTEuNTgxLS45NjctLjU1NS0xLjEyNy0uMTQyLTEuNzY4LjEwMS0uNTQ5LjIwOC0xLjg3Ni40MzgtMi43Ni0xLjA5MmwtLjAyLS4wMzZ6TTkuOTg0IDIuMTYySDEwYzEuMzU1IDAgMS4zNDIgMS4wMzkgMS4zNTMgMS40MjUuMDA4LjMxMi4wNCAxLjE2IDEuMjU5IDEuODcybC4wMTUuMDA4YzEuMjI1LjcgMS45NzYuMzA0IDIuMjUxLjE1NS4zMzctLjE4MyAxLjIyNi0uNzExIDEuOTAyLjQ0NWwuMDA4LjAxNGMuNjc4IDEuMTczLS4yMjkgMS42ODItLjU1OCAxLjg4NC0uMjY2LjE2My0uOTg0LjYxNS0uOTkxIDIuMDI3di4wMTZjLjAwNyAxLjQxMi43MjUgMS44NjQuOTkxIDIuMDI3LjMyOC4yMDEgMS4yMjkuNzA3LjU2NiAxLjg3bC0uMDA4LjAxNGMtLjY3NyAxLjE3NC0xLjU3MS42NDMtMS45MS40NTktLjI3NS0uMTQ5LTEuMDI2LS41NDUtMi4yNTEuMTU0bC0uMDE1LjAwOWMtMS4yMTkuNzEyLTEuMjUxIDEuNTYtMS4yNTkgMS44NzItLjAxMS4zODYuMDAyIDEuNDI1LTEuMzUzIDEuNDI1cy0xLjM0Mi0xLjAzOS0xLjM1My0xLjQyNWMtLjAwOC0uMzEyLS4wNC0xLjE2LTEuMjU5LTEuODcybC0uMDE1LS4wMDljLTEuMjI1LS42OTktMS45NzYtLjMwMy0yLjI1MS0uMTU0LS4zMzYuMTgzLTEuMjE5LjcwNi0xLjg5NC0uNDMybC0uMDE2LS4wMjdjLS42NzgtMS4xNzQuMjI5LTEuNjgyLjU1OC0xLjg4NC4yNjYtLjE2My45ODQtLjYxNS45OTEtMi4wMjd2LS4wMTZjLS4wMDctMS40MTItLjcyNS0xLjg2NC0uOTkxLTIuMDI3LS4zMjgtLjIwMS0xLjIyOS0uNzA3LS41NjYtMS44N2wuMDA4LS4wMTRjLjY3Ny0xLjE3NCAxLjU3MS0uNjQzIDEuOTEtLjQ1OS4yNzUuMTQ5IDEuMDI2LjU0NSAyLjI1MS0uMTU1bC4wMTUtLjAwOGMxLjIxOS0uNzEyIDEuMjUxLTEuNTYgMS4yNTktMS44NzIuMDEtLjM4NC0uMDAyLTEuNDE3IDEuMzM3LTEuNDI1Ii8+PC9zdmc+)}.ag-charts-icon-step-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzE4MUQxRiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNiA0aDV2OGgzVjhoNXYxaC00djRoLTVWNUg3djEwSDJ2LTFoNHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-text-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDRIMTZWN0gxNVY1SDEwLjVWMTVIMTRWMTZINlYxNUg5LjVWNUg1VjdINFY0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-trend-line,.ag-charts-icon-trend-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS4zMTQgMTAuOTM4YTIuMjUgMi4yNSAwIDEgMSAuMDEtMWg5LjM1MmEyLjI1IDIuMjUgMCAxIDEgLjAxIDF6bS0yLjE4OS43MjlhMS4yNSAxLjI1IDAgMSAwIDAtMi41IDEuMjUgMS4yNSAwIDAgMCAwIDIuNW0xMy43NSAwYTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock,.ag-charts-icon-unlocked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNjUxIDMuNWEyLjg5NCAyLjg5NCAwIDAgMC0yLjg5NCAyLjg5NFY5SDE0LjVhMi41IDIuNSAwIDAgMSAyLjUgMi41djNhMi41IDIuNSAwIDAgMS0yLjUgMi41aC04QTIuNSAyLjUgMCAwIDEgNCAxNC41di0zQTIuNSAyLjUgMCAwIDEgNi41IDloLjI1N1Y2LjM5NGEzLjg5NCAzLjg5NCAwIDEgMSA3Ljc4OSAwIC41LjUgMCAwIDEtMSAwQTIuODk0IDIuODk0IDAgMCAwIDEwLjY1IDMuNU02LjUgMTBBMS41IDEuNSAwIDAgMCA1IDExLjV2M0ExLjUgMS41IDAgMCAwIDYuNSAxNmg4YTEuNSAxLjUgMCAwIDAgMS41LTEuNXYtM2ExLjUgMS41IDAgMCAwLTEuNS0xLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-vertical-line,.ag-charts-icon-vertical-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNSA3LjgwNmEyLjI1IDIuMjUgMCAwIDEgMCA0LjM4OFYxOS41aC0xdi03LjMwNmEyLjI1IDIuMjUgMCAwIDEgMC00LjM4OFYuNWgxem0tLjUuOTQ0YTEuMjUgMS4yNSAwIDEgMSAwIDIuNSAxLjI1IDEuMjUgMCAwIDEgMC0yLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-zoom-in{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS41IDEwYS41LjUgMCAwIDEgLjUtLjVoOGEuNS41IDAgMCAxIDAgMUg2YS41LjUgMCAwIDEtLjUtLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-high-low-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyA0aDJ2MTJINFY0aDNNNSA1aDN2MTBINXpNMTEgMTRWNmg1djhoLTVtMS03aDN2NmgtM3oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTYzIDEuODM3LTUuMzM0IDExLjYyMUw2Ljk1NyA4LjEybC00LjE5OSA5LjYyMi0uOTE2LS40IDQuNzU2LTEwLjlMMTIuNDkgMTEuOCAxNy4yNTQgMS40MnoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTUuODI1IDIuNzA0LjU1IDEzLjc4NWwuOTAyLjQzIDQuNzI0LTkuOTE5IDYuMDM0IDUuMDI5IDMuMjU1LTguMTQtLjkyOC0uMzctMi43NDUgNi44NnptNy44NTIgMTQuNjM2IDUuNzgtMTMuMTM5LS45MTUtLjQwMi01LjIxOSAxMS44Ni02LjAwNS01LjUwNC0zLjI3OCA3LjY0OC45Mi4zOTQgMi43MjItNi4zNTJ6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDQuNWEuNzUuNzUgMCAwIDAtMS41IDB2Mi43NUg0LjVhLjc1Ljc1IDAgMCAwIDAgMS41aDIuNzV2Mi43NWEuNzUuNzUgMCAwIDAgMS41IDBWOC43NWgyLjc1YS43NS43NSAwIDAgMCAwLTEuNUg4Ljc1VjQuNVoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zLjc1IDhhLjc1Ljc1IDAgMCAxIC43NS0uNzVoN2EuNzUuNzUgMCAwIDEgMCAxLjVoLTdBLjc1Ljc1IDAgMCAxIDMuNzUgOFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-alt,.ag-charts-icon-zoom-in-alt-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20taW4iPjxjaXJjbGUgY3g9IjExIiBjeT0iMTEiIHI9IjgiLz48bGluZSB4MT0iMjEiIHgyPSIxNi42NSIgeTE9IjIxIiB5Mj0iMTYuNjUiLz48bGluZSB4MT0iMTEiIHgyPSIxMSIgeTE9IjgiIHkyPSIxNCIvPjxsaW5lIHgxPSI4IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjExIi8+PC9zdmc+)}.ag-charts-icon-zoom-out-alt,.ag-charts-icon-zoom-out-alt-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20tb3V0Ij48Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4Ii8+PGxpbmUgeDE9IjIxIiB4Mj0iMTYuNjUiIHkxPSIyMSIgeTI9IjE2LjY1Ii8+PGxpbmUgeDE9IjgiIHgyPSIxNCIgeTE9IjExIiB5Mj0iMTEiLz48L3N2Zz4=)}.ag-charts-icon-reset-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00LjQxMiA0LjA1OCAyLjc1IDIuMzk2VjYuNzVoLjc0NGEuNzYuNzYgMCAwIDAgLjAxMiAwaDMuNTk4TDUuNDc4IDUuMTI1YTQuMTI1IDQuMTI1IDAgMCAxIDIuNTIzLS44NzUgMy43NSAzLjc1IDAgMSAxLTMuMTE5IDUuODMzLjc1Ljc1IDAgMCAwLTEuMjQ3LjgzNEE1LjI1IDUuMjUgMCAxIDAgOCAyLjc1aC0uMDAzYTUuNjI1IDUuNjI1IDAgMCAwLTMuNTg1IDEuMzA4WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-left-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4wMyA0LjQ3YS43NS43NSAwIDAgMSAwIDEuMDZMNy41NiA4bDIuNDcgMi40N2EuNzUuNzUgMCAxIDEtMS4wNiAxLjA2bC0zLTNhLjc1Ljc1IDAgMCAxIDAtMS4wNmwzLTNhLjc1Ljc1IDAgMCAxIDEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-right-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik01Ljk3IDExLjUzYS43NS43NSAwIDAgMSAwLTEuMDZMOC40NCA4IDUuOTcgNS41M2EuNzUuNzUgMCAwIDEgMS4wNi0xLjA2bDMgM2EuNzUuNzUgMCAwIDEgMCAxLjA2bC0zIDNhLjc1Ljc1IDAgMCAxLTEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-start-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tZmlyc3QiPjxwYXRoIGQ9Im0xNyAxOC02LTYgNi02Ii8+PHBhdGggZD0iTTcgNnYxMiIvPjwvc3ZnPg==)}.ag-charts-icon-pan-end-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tbGFzdCI+PHBhdGggZD0ibTcgMTggNi02LTYtNiIvPjxwYXRoIGQ9Ik0xNyA2djEyIi8+PC9zdmc+)}.ag-charts-icon-trend-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMi41IiBjeT0iOCIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIvPjxjaXJjbGUgY3g9IjEzLjUiIGN5PSI4IiByPSIxLjc1IiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41Ii8+PHBhdGggc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIgZD0iTTQgOGg4Ii8+PC9zdmc+)}.ag-charts-icon-horizontal-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4zODYgOC43NWEyLjUwMSAyLjUwMSAwIDAgMS00Ljc3MiAwSC43NWEuNzUuNzUgMCAwIDEgMC0xLjVoNC44NjRhMi41MDEgMi41MDEgMCAwIDEgNC43NzIgMGg0Ljg2NGEuNzUuNzUgMCAwIDEgMCAxLjVoLTQuODY0Wk05IDhhMSAxIDAgMSAxLTIgMCAxIDEgMCAwIDEgMiAwWiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-vertical-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDUuNjE0YTIuNTAxIDIuNTAxIDAgMCAxIDAgNC43NzJ2NC44NjRhLjc1Ljc1IDAgMCAxLTEuNSAwdi00Ljg2NGEyLjUwMSAyLjUwMSAwIDAgMSAwLTQuNzcyVi43NWEuNzUuNzUgMCAwIDEgMS41IDB2NC44NjRaTTggN2ExIDEgMCAxIDEgMCAyIDEgMSAwIDAgMSAwLTJaIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-parallel-channel-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzc3LTIuMTRsLTYuNjMgMi45YTIuNTAxIDIuNTAxIDAgMSAwIC42MDcgMS4zNzJsNi41ODUtMi44OGEyLjUwMSAyLjUwMSAwIDAgMCAyLjgxNS43NDhabS4wNS0yLjY5M2ExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptLTExIDQuNzVhMSAxIDAgMSAxLTEuODcuNzA4IDEgMSAwIDAgMSAxLjg3LS43MDhabTEuNTUgNi4wNzVhMi41MDEgMi41MDEgMCAxIDEtLjYwNy0xLjM3Mmw2LjYzLTIuOWEyLjUwMSAyLjUwMSAwIDEgMSAuNTYyIDEuMzkxbC02LjU4NSAyLjg4Wm0tMS41NS0uMDc1YTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0xMC40Mi0zLjQ2YTEgMSAwIDEgMC0uNzA5LTEuODcgMSAxIDAgMCAwIC43MDggMS44N1oiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-disjoint-channel-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzgzLTIuNDUzTDQuNjkgNC4wNTVhMi41IDIuNSAwIDEgMCAuMzQ0IDEuNDZsNi4zOTItMS41OThhMi41MDEgMi41MDEgMCAwIDAgMyAxLjAwM1ptLjA1LTIuNjkzYTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0tMTEgMi43NWExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptMS41NiA1LjQyYTIuNSAyLjUgMCAxIDAtLjM0NSAxLjQ2MWw2LjM1MiAxLjU4OGEyLjUgMi41IDAgMSAwIC4zODQtMS40NWwtNi4zOTItMS41OThabS0xLjU2LjUzOGExIDEgMCAxIDAtMS44Ny0uNzA4IDEgMSAwIDAgMCAxLjg3LjcwOFptMTAuNDIgMS40NjFhMSAxIDAgMSAxLS43MDkgMS44NyAxIDEgMCAwIDEgLjcwOC0xLjg3WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjc4OC41ODNhMi42MyAyLjYzIDAgMCAwLTEuODYuNzdMOS41NDQgMi43MzhhLjc1Ny43NTcgMCAwIDAtLjE0LjE0TDIuMDMyIDEwLjI1di4wMDFjLS4yNDIuMjQxLS40Mi41MzgtLjUyLjg2NGwtLjAwMi4wMDItLjg4IDIuOTAyLS4wMDEuMDAzYTEuMDgzIDEuMDgzIDAgMCAwIDEuMzUgMS4zNDdoLjAwMWwyLjkwMi0uODhoLjAwMWMuMzI2LS4xLjYyMy0uMjc3Ljg2NS0uNTE4di0uMDAxbDcuMzc1LTcuMzc2YS43NjMuNzYzIDAgMCAwIC4xMzktLjEzOWwxLjM4NC0xLjM4NEEyLjYzIDIuNjMgMCAwIDAgMTIuNzg4LjU4M1ptLS4xMjYgNC4zNTIuOTI0LS45MjRhMS4xMyAxLjEzIDAgMCAwLTEuNTk3LTEuNTk3bC0uOTI0LjkyNCAxLjU5NyAxLjU5N1ptLTIuNjU3LS41MzYtNi45MTMgNi45MTRIMy4wOWEuNTgzLjU4MyAwIDAgMC0uMTQ2LjI0MmwtLjY1MyAyLjE1MyAyLjE1NS0uNjU0YS41ODMuNTgzIDAgMCAwIC4yNDEtLjE0NGw2LjkxNC02LjkxNC0xLjU5Ny0xLjU5N1oiIGZpbGw9IiMwMDAiLz48L2c+PGRlZnM+PGNsaXBQYXRoIGlkPSJhIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDE2djE2SDB6Ii8+PC9jbGlwUGF0aD48L2RlZnM+PC9zdmc+)}.ag-charts-icon-delete-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA4MyAyLjY2N2MwLS4wOS4wNTMtLjI0Mi4xOTctLjM4Ny4xNDUtLjE0NC4yOTctLjE5Ny4zODctLjE5N2gyLjY2N2MuMDg5IDAgLjI0MS4wNTMuMzg2LjE5Ny4xNDUuMTQ1LjE5Ny4yOTcuMTk3LjM4N3YuNTgzSDYuMDg0di0uNTgzWk01LjMzIDQuNzVIMTEuOTE3djguNTgzYzAgLjA5LS4wNTIuMjQyLS4xOTcuMzg3LS4xNDUuMTQ0LS4yOTcuMTk3LS4zODYuMTk3SDQuNjY3Yy0uMDkgMC0uMjQyLS4wNTMtLjM4Ny0uMTk3LS4xNDQtLjE0NS0uMTk3LS4yOTctLjE5Ny0uMzg3VjQuNzVINS4zM1ptLS43NDUtMS41di0uNTgzYzAtLjU3OC4yOC0xLjA5Mi42MzYtMS40NDcuMzU1LS4zNTYuODctLjYzNyAxLjQ0Ny0uNjM3aDIuNjY3Yy41NzcgMCAxLjA5MS4yODEgMS40NDcuNjM3LjM1NS4zNTUuNjM2Ljg3LjYzNiAxLjQ0N3YuNTgzSDE0YS43NS43NSAwIDAgMSAwIDEuNWgtLjU4M3Y4LjU4M2MwIC41NzgtLjI4MSAxLjA5Mi0uNjM2IDEuNDQ3LS4zNTYuMzU2LS44Ny42MzctMS40NDcuNjM3SDQuNjY3Yy0uNTc3IDAtMS4wOTItLjI4MS0xLjQ0Ny0uNjM3LS4zNTUtLjM1NS0uNjM3LS44Ny0uNjM3LTEuNDQ3VjQuNzVIMmEuNzUuNzUgMCAwIDEgMC0xLjVoMi41ODNabTIuMDgzIDMuMzMzYS43NS43NSAwIDAgMSAuNzUuNzV2NGEuNzUuNzUgMCAxIDEtMS41IDB2LTRhLjc1Ljc1IDAgMCAxIC43NS0uNzVabTMuNDE3Ljc1YS43NS43NSAwIDAgMC0xLjUgMHY0YS43NS43NSAwIDEgMCAxLjUgMHYtNFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-lock-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjE3MyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDQuNDEgMS44Mjd2MS45MTZINS40MTZWNC42NjdjMC0uNjg1LjI3My0xLjM0My43NTctMS44MjdaTTMuOTE3IDYuNTgzVjQuNjY3YTQuMDgzIDQuMDgzIDAgMCAxIDguMTY2IDB2MS45MTZoLjU4NGMxLjE1IDAgMi4wODMuOTMzIDIuMDgzIDIuMDg0djQuNjY2YzAgMS4xNS0uOTMzIDIuMDg0LTIuMDgzIDIuMDg0SDMuMzMzYTIuMDgzIDIuMDgzIDAgMCAxLTIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEuOTMzLTIuMDg0IDIuMDgzLTIuMDg0aC41ODNabTcuNDE2IDEuNWgtOGEuNTgzLjU4MyAwIDAgMC0uNTgzLjU4NHY0LjY2NmMwIC4zMjIuMjYxLjU4NC41ODMuNTg0aDkuMzM0YS41ODMuNTgzIDAgMCAwIC41ODMtLjU4NFY4LjY2N2EuNTgzLjU4MyAwIDAgMC0uNTgzLS41ODRoLTEuMzM0WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjkyMyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDMuNjUzIDAgMyAzIDAgMCAxIC41Ny43OThjLjEzNC4yNzguMTcuNDc0LjE3LjU0NWEuNzUuNzUgMCAwIDAgMS41IDBjMC0uMzgxLS4xMzItLjgwOS0uMzItMS4xOThhNC41MDEgNC41MDEgMCAwIDAtLjg1OS0xLjIwNiA0LjA4MyA0LjA4MyAwIDAgMC02Ljk3IDIuODg4djEuOTE2aC0uNTg0QzIuOTMzIDYuNTgzIDIgNy41MTYgMiA4LjY2N3Y0LjY2NmMwIDEuMTUuOTMzIDIuMDg0IDIuMDgzIDIuMDg0aDkuMzM0YzEuMTUgMCAyLjA4My0uOTMzIDIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEtLjkzMy0yLjA4NC0yLjA4My0yLjA4NGgtNy4yNVY0LjY2N2MwLS42ODUuMjcyLTEuMzQzLjc1Ni0xLjgyN1pNNS40MTcgOC4wODNINC4wODJhLjU4My41ODMgMCAwIDAtLjU4My41ODR2NC42NjZjMCAuMzIyLjI2MS41ODQuNTgzLjU4NGg5LjMzNGEuNTgzLjU4MyAwIDAgMCAuNTgzLS41ODRWOC42NjdhLjU4My41ODMgMCAwIDAtLjU4My0uNTg0aC04WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-plus-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXBsdXMiPjxwYXRoIGQ9Ik01IDEyaDE0Ii8+PHBhdGggZD0iTTEyIDV2MTQiLz48L3N2Zz4=)}.ag-charts-icon-crossline-add-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43NSA0LjVhLjc1Ljc1IDAgMCAwLTEuNSAwdjIuNzVINC41YS43NS43NSAwIDAgMCAwIDEuNWgyLjc1djIuNzVhLjc1Ljc1IDAgMCAwIDEuNSAwVjguNzVoMi43NWEuNzUuNzUgMCAwIDAgMC0xLjVIOC43NXoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-input{--input-layer-active: 1;--input-layer-focus: 2;color:inherit;font-family:var(--ag-charts-input-font-family);font-size:var(--ag-charts-input-font-size);transition-duration:var(--ag-charts-input-transition-duration);transition-property:none;transition-timing-function:var(--ag-charts-input-transition-timing-function)}.ag-charts-input:focus-visible{outline:var(--ag-charts-input-focus-outline);box-shadow:var(--ag-charts-input-focus-box-shadow);z-index:var(--input-layer-focus)}.ag-charts-button{background:var(--ag-charts-input-background-color);border:1px solid var(--ag-charts-input-border-color);border-radius:var(--ag-charts-input-border-radius);cursor:pointer;padding:var(--ag-charts-input-padding);transition-property:background,border-color}.ag-charts-button:hover{background:var(--ag-charts-input-background-color--hover)}.ag-charts-button:has(.ag-charts-icon){padding:2px}.ag-charts-checkbox{appearance:none;background:var(--ag-charts-input-checkbox-background-color);border-radius:9px;cursor:pointer;height:18px;margin:0;transition-duration:var(--ag-charts-input-transition-duration--fast);transition-property:margin;width:29px}.ag-charts-checkbox:before{display:block;background:var(--ag-charts-input-background-color);border-radius:7px;content:" ";height:14px;margin:2px;transition-duration:var(--ag-charts-input-transition-duration--fast);transition-property:margin;transition-timing-function:var(--ag-charts-input-transition-easing);width:14px}.ag-charts-checkbox:checked{background:var(--ag-charts-input-checkbox-background-color--checked)}.ag-charts-checkbox:checked:before{margin-left:13px}.ag-charts-select{background:var(--ag-charts-input-background-color);border:1px solid var(--ag-charts-input-border-color);border-radius:var(--ag-charts-input-border-radius);padding:3px 2px 4px;font-size:inherit}.ag-charts-textarea{--line-height: 1.38;background:var(--ag-charts-input-background-color);border:1px solid var(--ag-charts-input-border-color);border-radius:var(--ag-charts-input-border-radius);line-height:var(--line-height);font-family:var(--ag-charts-input-font-family);font-size:var(--ag-charts-input-font-size);padding:var(--ag-charts-input-padding-large) var(--ag-charts-input-padding)}.ag-charts-textarea[placeholder]:empty:before{color:var(--ag-charts-input-placeholder);content:attr(placeholder)}.ag-charts-proxy-container{pointer-events:none;position:absolute}.ag-charts-proxy-elem{-webkit-appearance:none;appearance:none;background:none;border:none;color:#0000;overflow:hidden;pointer-events:none;position:absolute}.ag-charts-proxy-elem::-moz-range-thumb,.ag-charts-proxy-elem::-moz-range-track{opacity:0}.ag-charts-proxy-elem::-webkit-slider-runnable-track,.ag-charts-proxy-elem::-webkit-slider-thumb{opacity:0}.ag-charts-proxy-elem:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus-indicator{position:absolute;display:block;pointer-events:none;user-select:none;width:100%;height:100%}.ag-charts-focus-indicator>div{position:absolute;outline:var(--ag-charts-focus-border);outline-width:2px;box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus-indicator>svg{width:100%;height:100%;fill:none;stroke:var(--ag-charts-focus-border-color);stroke-width:2px}.ag-charts-toolbar{align-items:center;background:none;border:none;display:flex;flex-wrap:nowrap;opacity:1;position:absolute;transform:translateY(0);transition:opacity .2s ease-in-out,transform .2s ease-in-out}.ag-charts-toolbar--hidden,.ag-charts-toolbar--prevent-flash{visibility:hidden}.ag-charts-toolbar--floating-hidden{opacity:0;transition:opacity .4s ease-in-out}.ag-charts-toolbar--small{--ag-charts-toolbar-size: var(--ag-charts-toolbar-size-small);--ag-charts-toolbar-font-size: var(--ag-charts-toolbar-font-size-small);--ag-charts-toolbar-button-padding: var(--ag-charts-toolbar-button-padding-small)}.ag-charts-toolbar--top,.ag-charts-toolbar--bottom{flex-direction:row;width:100%}.ag-charts-toolbar--left,.ag-charts-toolbar--right{flex-direction:column}.ag-charts-toolbar--floating,.ag-charts-toolbar--floating-top,.ag-charts-toolbar--floating-bottom{background:none;border:none;flex-direction:row;pointer-events:none;width:100%}.ag-charts-toolbar--floating{padding:0;width:auto;z-index:var(--ag-charts-layer-toolbar)}.ag-charts-toolbar--floating-top{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-top:10px}.ag-charts-toolbar--floating-bottom{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-bottom:10px;overflow:hidden}.ag-charts-toolbar__align{display:flex;flex-direction:inherit;flex-wrap:inherit;gap:var(--ag-charts-toolbar-gap);max-width:100%;width:100%}.ag-charts-toolbar__align--start{justify-content:start}.ag-charts-toolbar__align--center{justify-content:center}.ag-charts-toolbar__align--end{justify-content:end}.ag-charts-toolbar__align--center,.ag-charts-toolbar__align--end{margin-left:auto}.ag-charts-toolbar--left .ag-charts-toolbar__align--center,.ag-charts-toolbar--left .ag-charts-toolbar__align--end,.ag-charts-toolbar--right .ag-charts-toolbar__align--center,.ag-charts-toolbar--right .ag-charts-toolbar__align--end{margin-left:0;margin-top:auto}.ag-charts-toolbar--floating-top .ag-charts-toolbar__align,.ag-charts-toolbar--floating-bottom .ag-charts-toolbar__align{transition:transform .4s ease-in-out;width:auto}.ag-charts-toolbar__section{display:inherit;flex-direction:inherit;flex-wrap:inherit;justify-content:inherit;max-width:inherit;width:inherit}.ag-charts-toolbar__button{align-items:center;background:var(--ag-charts-toolbar-background-color);border:var(--ag-charts-toolbar-border);color:var(--ag-charts-toolbar-foreground-color);display:flex;font:var(--ag-charts-toolbar-font-size) var(--ag-charts-font-family);justify-content:center;margin:0 0 0 -1px;min-height:var(--ag-charts-toolbar-size);min-width:var(--ag-charts-toolbar-size);padding:var(--ag-charts-toolbar-button-padding);pointer-events:all;position:relative;white-space:nowrap;--stroke-width-color: var(--ag-charts-toolbar-foreground-color)}.ag-charts-toolbar__no-pointer-events{pointer-events:none}.ag-charts-toolbar__button--drag-handle{min-width:24px;padding-left:0;padding-right:0}.ag-charts-toolbar__button--with-transition{transition:background-color .25s ease-in-out,border-color .25s ease-in-out,color .25s ease-in-out}.ag-charts-toolbar__button[data-toolbar-group=ranges]{padding:var(--ag-charts-toolbar-button-padding) calc(var(--ag-charts-toolbar-button-padding) * 1.5)}.ag-charts-toolbar--top,.ag-charts-toolbar--bottom,.ag-charts-toolbar--floating,.ag-charts-toolbar--floating-top,.ag-charts-toolbar--floating-bottom{.ag-charts-toolbar__button--first{border-bottom-left-radius:var(--ag-charts-button-radius);border-top-left-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-right-radius:var(--ag-charts-button-radius);border-top-right-radius:var(--ag-charts-button-radius)}}.ag-charts-toolbar--left,.ag-charts-toolbar--right{.ag-charts-toolbar__button{border-radius:0;margin:-1px 0 0;max-width:100%}.ag-charts-toolbar__button--first{border-top-left-radius:var(--ag-charts-button-radius);border-top-right-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-left-radius:var(--ag-charts-button-radius);border-bottom-right-radius:var(--ag-charts-button-radius)}}.ag-charts-toolbar__button--hidden-value,.ag-charts-toolbar__button--hidden-toggled{display:none}.ag-charts-toolbar__button:hover:not([aria-disabled=true],.ag-charts-toolbar__button--drag-handle){background:var(--ag-charts-toolbar-hover-color);z-index:1}.ag-charts-toolbar__button:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:calc(var(--ag-charts-layer-ui-overlay) + 1)}.ag-charts-toolbar__button.ag-charts-toolbar__button--active{background:var(--ag-charts-toolbar-active-background-color);border-color:var(--ag-charts-toolbar-active-color);color:var(--ag-charts-toolbar-active-color);z-index:2;--stroke-width-color: var(--ag-charts-toolbar-active-color)}.ag-charts-toolbar__button[aria-disabled=true]{background:var(--ag-charts-toolbar-disabled-background-color);color:var(--ag-charts-toolbar-disabled-foreground-color)}.ag-charts-toolbar__button:not([aria-disabled=true]){cursor:pointer}.ag-charts-toolbar__button.ag-charts-toolbar__button--drag-handle{cursor:grab}.ag-charts-toolbar__button.ag-charts-toolbar__button--dragging{cursor:grabbing}.ag-charts-toolbar__button--fill-visible:after{content:"";display:block;position:absolute;bottom:3px;left:5px;right:5px;height:4px;border-radius:99px;box-shadow:inset 0 0 0 1px color-mix(in srgb,var(--ag-charts-foreground-color) 10%,transparent);background:var(--fill)}.ag-charts-toolbar__button--fill-visible[aria-disabled=true]:after{filter:grayscale(1);opacity:.5}.ag-charts-toolbar__button--stroke-width-visible:before{content:"";height:min(var(--strokeWidth),20px);width:12px;background:var(--stroke-width-color);margin-right:var(--ag-charts-toolbar-button-padding)}.ag-charts-toolbar__button--stroke-width-visible[aria-disabled=true]:before{filter:grayscale(1);opacity:.5}.ag-charts-toolbar__icon+.ag-charts-toolbar__label{margin-left:var(--ag-charts-toolbar-gap)}.ag-charts-toolbar__icon,.ag-charts-toolbar__label{pointer-events:none}.ag-chart-overlay{color:#181d1f;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay{color:#fff}.ag-chart-overlay--loading{color:#8c8c8c}.ag-chart-overlay__loading-background{background:#fff;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay .ag-chart-overlay__loading-background{background:#192232}.ag-chart-tooltip{transition:transform .1s ease;width:max-content;z-index:99999;font:12px Verdana,sans-serif;color:#464646;box-shadow:0 4px 8px #00000014}.ag-chart-tooltip-wrap-always{overflow-wrap:break-word;word-break:break-word;hyphens:none}.ag-chart-tooltip-wrap-hyphenate{overflow-wrap:break-word;word-break:break-word;hyphens:auto}.ag-chart-tooltip-wrap-on-space{overflow-wrap:normal;word-break:normal}.ag-chart-tooltip-wrap-never{white-space:pre;text-overflow:ellipsis}.ag-chart-tooltip-no-interaction{pointer-events:none;user-select:none}.ag-chart-tooltip-no-animation{transition:none!important}.ag-chart-tooltip-hidden{visibility:hidden}.ag-chart-tooltip-title{overflow:hidden;position:relative;padding:8px 14px;border-top-left-radius:2px;border-top-right-radius:2px;color:#fff;background-color:#888;z-index:1;text-overflow:inherit}.ag-chart-tooltip-title:only-child{border-bottom-left-radius:2px;border-bottom-right-radius:2px}.ag-chart-tooltip-content{overflow:hidden;padding:6px 14px;line-height:1.7em;background:#fff;border-bottom-left-radius:2px;border-bottom-right-radius:2px;border:1px solid rgba(0,0,0,.15);text-overflow:inherit}.ag-chart-tooltip-arrow:before{content:"";position:absolute;top:100%;left:50%;transform:translate(-50%);border:5px solid #d9d9d9;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}.ag-chart-tooltip-arrow:after{content:"";position:absolute;top:calc(100% - 1px);left:50%;transform:translate(-50%);border:5px solid white;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}\n';

// packages/ag-charts-community/src/util/keynavUtil.ts
function addRemovableEventListener(destroyFns, elem, type, listener) {
  elem.addEventListener(type, listener);
  const remover = () => elem.removeEventListener(type, listener);
  destroyFns.push(remover);
  return remover;
}
function addEscapeEventListener(destroyFns, elem, onEscape) {
  addRemovableEventListener(destroyFns, elem, "keydown", (event) => {
    if (event.key === "Escape") {
      onEscape(event);
    }
  });
}
function hasNoModifiers(event) {
  return !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey);
}
function matchesKey(event, key, ...morekeys) {
  return hasNoModifiers(event) && (event.key === key || morekeys.some((altkey) => event.key === altkey));
}
function linkTwoButtons(destroyFns, src, dst, key) {
  if (!dst)
    return;
  addRemovableEventListener(destroyFns, src, "keydown", (event) => {
    if (matchesKey(event, key)) {
      dst.focus();
    }
  });
}
function linkThreeButtons(destroyFns, curr, next, nextKey, prev, prevKey) {
  linkTwoButtons(destroyFns, curr, prev, prevKey);
  linkTwoButtons(destroyFns, curr, next, nextKey);
  addRemovableEventListener(destroyFns, curr, "keydown", (event) => {
    if (matchesKey(event, nextKey, prevKey)) {
      event.preventDefault();
    }
  });
}
var PREV_NEXT_KEYS = {
  horizontal: { nextKey: "ArrowRight", prevKey: "ArrowLeft" },
  vertical: { nextKey: "ArrowDown", prevKey: "ArrowUp" }
};
function initToolbarKeyNav(opts) {
  opts.toolbar.role = "toolbar";
  opts.toolbar.ariaOrientation = opts.orientation;
  opts.toolbar.ariaHidden = (opts.buttons.length === 0).toString();
  return initRovingTabIndex(opts);
}
function initRovingTabIndex(opts) {
  const { orientation, buttons, wrapAround = false, onEscape, onFocus, onBlur } = opts;
  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];
  const setTabIndices = (event) => {
    if (event.target && "tabIndex" in event.target) {
      buttons.forEach((b) => b.tabIndex = -1);
      event.target.tabIndex = 0;
    }
  };
  const [c, m] = wrapAround ? [buttons.length, buttons.length] : [0, Infinity];
  const destroyFns = [];
  for (let i = 0; i < buttons.length; i++) {
    const prev = buttons[(c + i - 1) % m];
    const curr = buttons[i];
    const next = buttons[(c + i + 1) % m];
    addRemovableEventListener(destroyFns, curr, "focus", setTabIndices);
    if (onFocus)
      addRemovableEventListener(destroyFns, curr, "focus", onFocus);
    if (onBlur)
      addRemovableEventListener(destroyFns, curr, "blur", onBlur);
    if (onEscape)
      addEscapeEventListener(destroyFns, curr, onEscape);
    linkThreeButtons(destroyFns, curr, prev, prevKey, next, nextKey);
    curr.tabIndex = i === 0 ? 0 : -1;
  }
  return destroyFns;
}
function makeAccessibleClickListener(element2, onclick) {
  return (event) => {
    if (element2.ariaDisabled === "true") {
      return event.preventDefault();
    }
    onclick(event);
  };
}
function stopPageScrolling(element2) {
  const handler = (event) => {
    if (event.defaultPrevented)
      return;
    const shouldPrevent = getAttribute(event.target, "data-preventdefault", true);
    if (shouldPrevent && matchesKey(event, "ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp")) {
      event.preventDefault();
    }
  };
  element2.addEventListener("keydown", handler);
  return () => element2.removeEventListener("keydown", handler);
}

// packages/ag-charts-community/src/util/sizeMonitor.ts
var SizeMonitor = class {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
    this.documentReady = false;
    this.queuedObserveRequests = [];
    this.onLoad = () => {
      this.documentReady = true;
      this.queuedObserveRequests.forEach(([el, cb]) => this.observe(el, cb));
      this.queuedObserveRequests = [];
    };
    if (typeof ResizeObserver === "undefined")
      return;
    this.resizeObserver = new ResizeObserver((entries) => {
      for (const {
        target,
        contentRect: { width, height }
      } of entries) {
        const entry = this.elements.get(target);
        this.checkSize(entry, target, width, height);
      }
    });
    this.documentReady = getDocument("readyState") === "complete";
    if (!this.documentReady) {
      getWindow()?.addEventListener("load", this.onLoad);
    }
  }
  destroy() {
    getWindow()?.removeEventListener("load", this.onLoad);
    this.resizeObserver?.disconnect();
    this.resizeObserver = null;
  }
  checkSize(entry, element2, width, height) {
    if (!entry)
      return;
    if (width !== entry.size?.width || height !== entry.size?.height) {
      entry.size = { width, height };
      entry.cb(entry.size, element2);
    }
  }
  // Only a single callback is supported.
  observe(element2, cb) {
    if (!this.documentReady) {
      this.queuedObserveRequests.push([element2, cb]);
      return;
    }
    if (this.elements.has(element2)) {
      this.removeFromQueue(element2);
    } else {
      this.resizeObserver?.observe(element2);
    }
    const entry = { cb };
    this.elements.set(element2, entry);
  }
  unobserve(element2) {
    this.resizeObserver?.unobserve(element2);
    this.elements.delete(element2);
    this.removeFromQueue(element2);
    if (!this.elements.size) {
      this.destroy();
    }
  }
  removeFromQueue(element2) {
    this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el !== element2);
  }
};

// packages/ag-charts-community/src/dom/domLayout.html
var domLayout_default = '<div role="presentation" class="ag-charts-wrapper ag-charts-styles" data-ag-charts><div role="presentation" class="ag-charts-canvas-center"><div role="presentation" class="ag-charts-canvas-container"><div role="presentation" class="ag-charts-canvas" aria-hidden="true"></div><div role="figure" class="ag-charts-canvas-proxy"><div role="img" class="ag-charts-series-area" tabindex="-1"></div></div><div role="presentation" class="ag-charts-canvas-overlay"></div></div></div></div>';

// packages/ag-charts-community/src/dom/domManager.ts
var DOM_ELEMENT_CLASSES = [
  "styles",
  "canvas",
  "canvas-center",
  "canvas-overlay",
  "canvas-proxy",
  "series-area"
];
var domElementConfig = /* @__PURE__ */ new Map([
  ["styles", { childElementType: "style" }],
  ["canvas", { childElementType: "canvas" }],
  ["canvas-proxy", { childElementType: "div" }],
  ["canvas-overlay", { childElementType: "div" }],
  ["canvas-center", { childElementType: "div" }],
  ["series-area", { childElementType: "div" }]
]);
function setupObserver(element2, cb) {
  if (typeof IntersectionObserver === "undefined")
    return;
  const observer = new IntersectionObserver(
    (entries) => {
      for (const entry of entries) {
        if (entry.target === element2) {
          cb(entry.intersectionRatio);
        }
      }
    },
    { root: element2 }
  );
  observer.observe(element2);
  return observer;
}
var NULL_DOMRECT = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  bottom: 0,
  left: 0,
  right: 0,
  toJSON() {
    return NULL_DOMRECT;
  }
};
var DOMManager = class extends BaseManager {
  constructor(container, styleContainer) {
    super();
    this.styles = /* @__PURE__ */ new Map();
    this.container = void 0;
    this.containerSize = void 0;
    this.sizeMonitor = new SizeMonitor();
    const templateEl = createElement("div");
    templateEl.innerHTML = domLayout_default;
    this.element = templateEl.children.item(0);
    this.styleRootElement = styleContainer;
    this.rootElements = DOM_ELEMENT_CLASSES.reduce(
      (r, c) => {
        const cssClass = `ag-charts-${c}`;
        const el = this.element.classList.contains(cssClass) ? this.element : this.element.querySelector(`.${cssClass}`);
        if (!el)
          throw new Error(`AG Charts - unable to find DOM element ${cssClass}`);
        r[c] = { element: el, children: /* @__PURE__ */ new Map(), listeners: [] };
        return r;
      },
      {}
    );
    let hidden = false;
    this.observer = setupObserver(this.element, (intersectionRatio) => {
      if (intersectionRatio === 0 && !hidden) {
        this.listeners.dispatch("hidden", { type: "hidden" });
      }
      hidden = intersectionRatio === 0;
    });
    this.setSizeOptions();
    this.addStyles("ag-charts-community", styles_default);
    if (container) {
      this.setContainer(container);
    }
    this.destroyFns.push(stopPageScrolling(this.element));
  }
  destroy() {
    super.destroy();
    this.observer?.unobserve(this.element);
    if (this.container) {
      this.sizeMonitor.unobserve(this.container);
    }
    Object.values(this.rootElements).forEach((el) => {
      el.children.forEach((c) => c.remove());
      el.element.remove();
    });
    this.element.remove();
  }
  setSizeOptions(minWidth = 300, minHeight = 300, optionsWidth, optionsHeight) {
    const { style } = this.element;
    style.width = `${optionsWidth ?? minWidth}px`;
    style.height = `${optionsHeight ?? minHeight}px`;
  }
  updateContainerSize() {
    const { style: centerStyle } = this.rootElements["canvas-center"].element;
    centerStyle.width = `${this.containerSize?.width ?? 0}px`;
    centerStyle.height = `${this.containerSize?.height ?? 0}px`;
  }
  setContainer(newContainer) {
    if (newContainer === this.container)
      return;
    if (this.container) {
      this.container.removeChild(this.element);
      this.sizeMonitor.unobserve(this.container);
    }
    const isShadowDom = this.getShadowDocumentRoot(newContainer) != null;
    if (!isShadowDom) {
      for (const id of this.rootElements["styles"].children.keys()) {
        this.removeChild("styles", id);
      }
    }
    this.container = newContainer;
    for (const [id, styles] of this.styles) {
      this.addStyles(id, styles);
    }
    newContainer.appendChild(this.element);
    this.sizeMonitor.observe(newContainer, (size) => {
      this.containerSize = size;
      this.updateContainerSize();
      this.listeners.dispatch("resize", { type: "resize" });
    });
    this.listeners.dispatch("container-changed", { type: "container-changed" });
  }
  setThemeClass(themeClassName) {
    const themeClassNamePrefix = "ag-charts-theme-";
    this.element.classList.forEach((className) => {
      if (className.startsWith(themeClassNamePrefix) && className !== themeClassName) {
        this.element.classList.remove(className);
      }
    });
    this.element.classList.add(themeClassName);
  }
  setTabIndex(tabIndex) {
    this.rootElements["series-area"].element.tabIndex = tabIndex;
  }
  updateCanvasLabel(ariaLabel) {
    setAttribute(this.rootElements["canvas-proxy"].element, "aria-label", ariaLabel);
  }
  getEventElement(defaultElem, eventType) {
    const events = ["focus", "blur", "keydown", "keyup"];
    return events.includes(eventType) ? this.rootElements["series-area"].element : defaultElem;
  }
  addEventListener(type, listener, options) {
    this.getEventElement(this.element, type).addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    this.getEventElement(this.element, type).removeEventListener(type, listener, options);
  }
  /** Get the main chart area client bound rect. */
  getBoundingClientRect() {
    return this.rootElements["canvas"].element.getBoundingClientRect();
  }
  /**
   * Get the client bounding rect for overlay elements that might float outside the bounds of the
   * main chart area.
   */
  getOverlayClientRect() {
    const window2 = getWindow();
    const windowBBox = new BBox(0, 0, window2.innerWidth, window2.innerHeight);
    const container = this.getRawOverlayClientRect();
    const containerBBox = BBox.fromDOMRect(container ?? this.getBoundingClientRect());
    return windowBBox.intersection(containerBBox)?.toDOMRect() ?? NULL_DOMRECT;
  }
  getRawOverlayClientRect() {
    let element2 = this.element;
    while (element2 != null) {
      const styleMap = element2.computedStyleMap?.();
      const overflowX = styleMap?.get("overflow-x")?.toString();
      const overflowY = styleMap?.get("overflow-y")?.toString();
      if (overflowX != null && overflowX !== "visible" || overflowY && overflowY !== "visible") {
        return element2.getBoundingClientRect();
      }
      element2 = element2.parentElement;
    }
    const docRoot = this.getShadowDocumentRoot();
    if (docRoot) {
      return docRoot.getBoundingClientRect();
    }
  }
  getShadowDocumentRoot(current = this.container) {
    const docRoot = current?.ownerDocument?.body ?? getDocument("body");
    while (current != null) {
      if (current === docRoot) {
        return void 0;
      }
      if (current.parentNode instanceof DocumentFragment) {
        return current;
      }
      current = current.parentNode;
    }
    return this.container;
  }
  getChildBoundingClientRect(type) {
    const { children } = this.rootElements[type];
    const childRects = [];
    for (const child of children.values()) {
      childRects.push(BBox.fromDOMRect(child.getBoundingClientRect()));
    }
    return BBox.merge(childRects);
  }
  calculateCanvasPosition(el) {
    let x = 0;
    let y = 0;
    const { x: cx = 0, y: cy = 0 } = this.getChildBoundingClientRect("canvas") ?? {};
    const elRect = el.getBoundingClientRect();
    x = elRect.x - cx;
    y = elRect.y - cy;
    return { x, y };
  }
  isManagedChildDOMElement(el, domElementClass, id) {
    const { children } = this.rootElements[domElementClass];
    const search = children?.get(id);
    return search != null && el.contains(search);
  }
  isEventOverElement(event) {
    const element2 = event.target;
    return element2 != null && this.element.contains(element2);
  }
  addStyles(id, styles) {
    const dataAttribute = "data-ag-charts";
    this.styles.set(id, styles);
    if (this.container == null)
      return;
    const checkId = (el) => {
      return el.getAttribute(dataAttribute) === id;
    };
    const addStyleElement = (el) => {
      for (const child of el.children) {
        if (checkId(child))
          return;
      }
      const styleEl = createElement("style");
      el.appendChild(styleEl);
      return styleEl;
    };
    let styleElement;
    if (this.styleRootElement) {
      styleElement = addStyleElement(this.styleRootElement);
    } else {
      const documentRoot = this.getShadowDocumentRoot(this.container);
      if (documentRoot != null) {
        styleElement = this.addChild("styles", id);
      } else {
        styleElement = addStyleElement(getDocument("head"));
      }
    }
    if (styleElement == null || checkId(styleElement))
      return;
    styleElement.setAttribute(dataAttribute, id);
    styleElement.innerHTML = styles;
  }
  removeStyles(id) {
    this.removeChild("styles", id);
  }
  updateCursor(style) {
    this.element.style.cursor = style;
  }
  getCursor() {
    return this.element.style.cursor;
  }
  addChild(domElementClass, id, child, insert) {
    const { element: element2, children, listeners } = this.rootElements[domElementClass];
    if (!children) {
      throw new Error("AG Charts - unable to create DOM elements after destroy()");
    }
    if (children.has(id)) {
      return children.get(id);
    }
    const { childElementType = "div" } = domElementConfig.get(domElementClass) ?? {};
    if (child && child.tagName.toLowerCase() !== childElementType.toLowerCase()) {
      throw new Error("AG Charts - mismatching DOM element type");
    }
    const newChild = child ?? createElement(childElementType);
    for (const [type, fn, opts] of listeners) {
      newChild.addEventListener(type, fn, opts);
    }
    children.set(id, newChild);
    if (insert) {
      const queryResult = element2.querySelector(insert.query);
      if (queryResult == null) {
        throw new Error(`AG Charts - addChild query failed ${insert.query}`);
      }
      queryResult.insertAdjacentElement(insert.where, newChild);
    } else {
      element2?.appendChild(newChild);
    }
    return newChild;
  }
  removeChild(domElementClass, id) {
    const { children } = this.rootElements[domElementClass];
    if (!children)
      return;
    children.get(id)?.remove();
    children.delete(id);
  }
  incrementDataCounter(name) {
    const { dataset } = this.element;
    dataset[name] ?? (dataset[name] = "0");
    dataset[name] = String(Number(dataset[name]) + 1);
  }
  setDataBoolean(name, value) {
    this.element.dataset[name] = String(value);
  }
  getIconClassNames(icon) {
    return `ag-charts-icon ag-charts-icon-${icon}`;
  }
};

// packages/ag-charts-community/src/scene/polyRoots.ts
function linearRoot(a, b) {
  const t = -b / a;
  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];
}
function quadraticRoots(a, b, c) {
  if (a === 0) {
    return linearRoot(b, c);
  }
  const D = b * b - 4 * a * c;
  const roots = [];
  if (D === 0) {
    const t = -b / (2 * a);
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
  } else if (D > 0) {
    const rD = Math.sqrt(D);
    const t1 = (-b - rD) / (2 * a);
    const t2 = (-b + rD) / (2 * a);
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
  }
  return roots;
}
function cubicRoots(a, b, c, d) {
  if (a === 0) {
    return quadraticRoots(b, c, d);
  }
  const A = b / a;
  const B = c / a;
  const C = d / a;
  const Q = (3 * B - A * A) / 9;
  const R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;
  const D = Q * Q * Q + R * R;
  const third = 1 / 3;
  const roots = [];
  if (D >= 0) {
    const rD = Math.sqrt(D);
    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);
    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);
    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);
    const t = -third * A + (S + T);
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
    if (Im === 0) {
      const t2 = -third * A - (S + T) / 2;
      if (t2 >= 0 && t2 <= 1) {
        roots.push(t2);
      }
    }
  } else {
    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));
    const thirdA = third * A;
    const twoSqrtQ = 2 * Math.sqrt(-Q);
    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;
    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;
    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
    if (t3 >= 0 && t3 <= 1) {
      roots.push(t3);
    }
  }
  return roots;
}

// packages/ag-charts-community/src/scene/intersection.ts
function segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);
  if (d === 0) {
    return 0;
  }
  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;
  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    return 1;
  }
  return 0;
}
function cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {
  let intersections = 0;
  const A = y1 - y2;
  const B = x2 - x1;
  const C = x1 * (y2 - y1) - y1 * (x2 - x1);
  const bx = bezierCoefficients(px1, px2, px3, px4);
  const by = bezierCoefficients(py1, py2, py3, py4);
  const a = A * bx[0] + B * by[0];
  const b = A * bx[1] + B * by[1];
  const c = A * bx[2] + B * by[2];
  const d = A * bx[3] + B * by[3] + C;
  const roots = cubicRoots(a, b, c, d);
  for (const t of roots) {
    const tt = t * t;
    const ttt = t * tt;
    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];
    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];
    let s;
    if (x1 === x2) {
      s = (y - y1) / (y2 - y1);
    } else {
      s = (x - x1) / (x2 - x1);
    }
    if (s >= 0 && s <= 1) {
      intersections++;
    }
  }
  return intersections;
}
function bezierCoefficients(P1, P2, P3, P4) {
  return [
    // Bézier expressed as matrix operations:
    -P1 + 3 * P2 - 3 * P3 + P4,
    //                 |-1  3 -3  1| |P1|
    3 * P1 - 6 * P2 + 3 * P3,
    //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|
    -3 * P1 + 3 * P2,
    //                 |-3  3  0  0| |P3|
    P1
    //                 | 1  0  0  0| |P4|
  ];
}
function arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {
  if (isNaN(cx) || isNaN(cy)) {
    return 0;
  }
  if (counterClockwise) {
    [endAngle, startAngle] = [startAngle, endAngle];
  }
  const k = (y2 - y1) / (x2 - x1);
  const y0 = y1 - k * x1;
  const a = Math.pow(k, 2) + 1;
  const b = 2 * (k * (y0 - cy) - cx);
  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);
  const d = Math.pow(b, 2) - 4 * a * c;
  if (d < 0) {
    return 0;
  }
  const i1x = (-b + Math.sqrt(d)) / 2 / a;
  const i2x = (-b - Math.sqrt(d)) / 2 / a;
  let intersections = 0;
  [i1x, i2x].forEach((x) => {
    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);
    if (!isXInsideLine) {
      return;
    }
    const y = k * x + y0;
    const adjacent = x - cx;
    const opposite = y - cy;
    const angle2 = Math.atan2(opposite, adjacent);
    if (isBetweenAngles(angle2, startAngle, endAngle)) {
      intersections++;
    }
  });
  return intersections;
}

// packages/ag-charts-community/src/scene/util/bezier.ts
function evaluateBezier(p0, p1, p2, p3, t) {
  return (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) * t ** 2 * p2 + t ** 3 * p3;
}
function solveBezier(p0, p1, p2, p3, value) {
  if (value <= Math.min(p0, p3)) {
    return p0 < p3 ? 0 : 1;
  } else if (value >= Math.max(p0, p3)) {
    return p0 < p3 ? 1 : 0;
  }
  let t0 = 0;
  let t1 = 1;
  let t = NaN;
  for (let i = 0; i < 12; i += 1) {
    t = (t0 + t1) / 2;
    const curveValue = evaluateBezier(p0, p1, p2, p3, t);
    if (curveValue < value) {
      t0 = t;
    } else {
      t1 = t;
    }
  }
  return t;
}
function splitBezier(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t) {
  const x01 = (1 - t) * p0x + t * p1x;
  const y01 = (1 - t) * p0y + t * p1y;
  const x12 = (1 - t) * p1x + t * p2x;
  const y12 = (1 - t) * p1y + t * p2y;
  const x23 = (1 - t) * p2x + t * p3x;
  const y23 = (1 - t) * p2y + t * p3y;
  const x012 = (1 - t) * x01 + t * x12;
  const y012 = (1 - t) * y01 + t * y12;
  const x123 = (1 - t) * x12 + t * x23;
  const y123 = (1 - t) * y12 + t * y23;
  const x0123 = (1 - t) * x012 + t * x123;
  const y0123 = (1 - t) * y012 + t * y123;
  return [
    [
      { x: p0x, y: p0y },
      { x: x01, y: y01 },
      { x: x012, y: y012 },
      { x: x0123, y: y0123 }
    ],
    [
      { x: x0123, y: y0123 },
      { x: x123, y: y123 },
      { x: x23, y: y23 },
      { x: p3x, y: p3y }
    ]
  ];
}
function calculateDerivativeExtrema(p0, p1, p2, p3) {
  const a = -p0 + 3 * p1 - 3 * p2 + p3;
  const b = 3 * p0 - 6 * p1 + 3 * p2;
  const c = -3 * p0 + 3 * p1;
  if (a === 0) {
    if (b !== 0) {
      const t = -c / b;
      if (t > 0 && t < 1) {
        return [t];
      }
    }
    return [];
  }
  const discriminant = b * b - 4 * a * c;
  if (discriminant >= 0) {
    const sqrtDiscriminant = Math.sqrt(discriminant);
    const t1 = (-b + sqrtDiscriminant) / (2 * a);
    const t2 = (-b - sqrtDiscriminant) / (2 * a);
    return [t1, t2].filter((t) => t > 0 && t < 1);
  }
  return [];
}
function calculateDerivativeExtremaXY(sx, sy, cp1x, cp1y, cp2x, cp2y, x, y) {
  const tx = calculateDerivativeExtrema(sx, cp1x, cp2x, x);
  const ty = calculateDerivativeExtrema(sy, cp1y, cp2y, y);
  return [...tx, ...ty];
}

// packages/ag-charts-community/src/scene/extendedPath2D.ts
var ExtendedPath2D = class {
  constructor() {
    // The methods of this class will likely be called many times per animation frame,
    // and any allocation can trigger a GC cycle during animation, so we attempt
    // to minimize the number of allocations.
    this.path2d = new Path2D();
    this.previousCommands = [];
    this.previousParams = [];
    this.previousClosedPath = false;
    this.commands = [];
    this.params = [];
    this.openedPath = false;
    this.closedPath = false;
  }
  isDirty() {
    return this.closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length || this.previousCommands.toString() !== this.commands.toString() || this.previousParams.toString() !== this.params.toString();
  }
  getPath2D() {
    return this.path2d;
  }
  moveTo(x, y) {
    this.openedPath = true;
    this.path2d.moveTo(x, y);
    this.commands.push(0 /* Move */);
    this.params.push(x, y);
  }
  lineTo(x, y) {
    if (this.openedPath) {
      this.path2d.lineTo(x, y);
      this.commands.push(1 /* Line */);
      this.params.push(x, y);
    } else {
      this.moveTo(x, y);
    }
  }
  rect(x, y, width, height) {
    this.moveTo(x, y);
    this.lineTo(x + width, y);
    this.lineTo(x + width, y + height);
    this.lineTo(x, y + height);
    this.closePath();
  }
  roundRect(x, y, width, height, radii) {
    radii = Math.min(radii, width / 2, height / 2);
    this.moveTo(x, y + radii);
    this.arc(x + radii, y + radii, radii, Math.PI, 1.5 * Math.PI);
    this.lineTo(x + radii, y);
    this.lineTo(x + width - radii, y);
    this.arc(x + width - radii, y + radii, radii, 1.5 * Math.PI, 2 * Math.PI);
    this.lineTo(x + width, y + radii);
    this.lineTo(x + width, y + height - radii);
    this.arc(x + width - radii, y + height - radii, radii, 0, Math.PI / 2);
    this.lineTo(x + width - radii, y + height);
    this.lineTo(x + radii, y + height);
    this.arc(x + +radii, y + height - radii, radii, Math.PI / 2, Math.PI);
    this.lineTo(x, y + height - radii);
    this.closePath();
  }
  arc(x, y, r, sAngle, eAngle, counterClockwise) {
    this.openedPath = true;
    this.path2d.arc(x, y, r, sAngle, eAngle, counterClockwise);
    this.commands.push(2 /* Arc */);
    this.params.push(x, y, r, sAngle, eAngle, counterClockwise ? 1 : 0);
  }
  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {
    if (!this.openedPath) {
      this.moveTo(cx1, cy1);
    }
    this.path2d.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);
    this.commands.push(3 /* Curve */);
    this.params.push(cx1, cy1, cx2, cy2, x, y);
  }
  closePath() {
    if (this.openedPath) {
      this.path2d.closePath();
      this.commands.push(4 /* ClosePath */);
      this.openedPath = false;
      this.closedPath = true;
    }
  }
  clear(trackChanges) {
    if (trackChanges) {
      this.previousCommands = this.commands;
      this.previousParams = this.params;
      this.previousClosedPath = this.closedPath;
    }
    this.path2d = new Path2D();
    this.openedPath = false;
    this.closedPath = false;
    this.commands = [];
    this.params = [];
  }
  isPointInPath(x, y) {
    const commands = this.commands;
    const params = this.params;
    const cn = commands.length;
    const ox = -1e4;
    const oy = -1e4;
    let sx = NaN;
    let sy = NaN;
    let px = 0;
    let py = 0;
    let intersectionCount = 0;
    for (let ci = 0, pi = 0; ci < cn; ci++) {
      switch (commands[ci]) {
        case 0 /* Move */:
          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);
          px = params[pi++];
          sx = px;
          py = params[pi++];
          sy = py;
          break;
        case 1 /* Line */:
          intersectionCount += segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y);
          px = params[pi - 2];
          py = params[pi - 1];
          break;
        case 3 /* Curve */:
          intersectionCount += cubicSegmentIntersections(
            px,
            py,
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            ox,
            oy,
            x,
            y
          );
          px = params[pi - 2];
          py = params[pi - 1];
          break;
        case 2 /* Arc */: {
          const cx = params[pi++];
          const cy = params[pi++];
          const r = params[pi++];
          const startAngle = params[pi++];
          const endAngle = params[pi++];
          const counterClockwise = Boolean(params[pi++]);
          intersectionCount += arcIntersections(
            cx,
            cy,
            r,
            startAngle,
            endAngle,
            counterClockwise,
            ox,
            oy,
            x,
            y
          );
          if (!isNaN(sx)) {
            const startX = cx + Math.cos(startAngle) * r;
            const startY = cy + Math.sin(startAngle) * r;
            intersectionCount += segmentIntersection(px, py, startX, startY, ox, oy, x, y);
          }
          px = cx + Math.cos(endAngle) * r;
          py = cy + Math.sin(endAngle) * r;
          break;
        }
        case 4 /* ClosePath */:
          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);
          break;
      }
    }
    return intersectionCount % 2 === 1;
  }
  distanceSquared(x, y) {
    let best = Infinity;
    const commands = this.commands;
    const params = this.params;
    const cn = commands.length;
    let sx = NaN;
    let sy = NaN;
    let px = 0;
    let py = 0;
    for (let ci = 0, pi = 0; ci < cn; ci++) {
      switch (commands[ci]) {
        case 0 /* Move */:
          px = sx = params[pi++];
          py = sy = params[pi++];
          break;
        case 1 /* Line */: {
          const nx = params[pi++];
          const ny = params[pi++];
          best = lineDistanceSquared(x, y, px, py, nx, ny, best);
          break;
        }
        case 3 /* Curve */:
          Logger.error("Command.Curve distanceSquare not implemented");
          break;
        case 2 /* Arc */: {
          const cx = params[pi++];
          const cy = params[pi++];
          const r = params[pi++];
          const startAngle = params[pi++];
          const endAngle = params[pi++];
          const startX = cx + Math.cos(startAngle) * r;
          const startY = cy + Math.sin(startAngle) * r;
          const counterClockwise = Boolean(params[pi++]);
          best = lineDistanceSquared(x, y, px, py, startX, startY, best);
          best = arcDistanceSquared(x, y, cx, cy, r, startAngle, endAngle, counterClockwise, best);
          px = cx + Math.cos(endAngle) * r;
          py = cy + Math.sin(endAngle) * r;
          break;
        }
        case 4 /* ClosePath */:
          best = lineDistanceSquared(x, y, px, py, sx, sy, best);
          break;
      }
    }
    return best;
  }
  getPoints() {
    const { commands, params } = this;
    const coords = [];
    let pi = 0;
    for (const command of commands) {
      switch (command) {
        case 0 /* Move */:
        case 1 /* Line */:
          coords.push({ x: params[pi++], y: params[pi++] });
          break;
        case 3 /* Curve */:
          pi += 4;
          coords.push({ x: params[pi++], y: params[pi++] });
          break;
        case 2 /* Arc */:
          coords.push({ x: params[pi++], y: params[pi++] });
          pi += 4;
          break;
        case 4 /* ClosePath */:
          break;
      }
    }
    return coords;
  }
  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
  toSVG(transform = (x, y) => ({ x, y })) {
    const buffer = [];
    const { commands, params } = this;
    const addCommand = (command, ...points) => {
      buffer.push(command);
      for (let i = 0; i < points.length; i += 2) {
        const { x, y } = transform(points[i], points[i + 1]);
        buffer.push(x, y);
      }
    };
    let pi = 0;
    for (const command of commands) {
      switch (command) {
        case 0 /* Move */:
          addCommand("M", params[pi++], params[pi++]);
          break;
        case 1 /* Line */:
          addCommand("L", params[pi++], params[pi++]);
          break;
        case 3 /* Curve */:
          addCommand("C", params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], params[pi++]);
          break;
        case 2 /* Arc */: {
          const cx = params[pi++];
          const cy = params[pi++];
          const r = params[pi++];
          const A0 = params[pi++];
          const A1 = params[pi++];
          const ccw = params[pi++];
          let sweep = ccw ? A0 - A1 : A1 - A0;
          if (sweep < 0) {
            sweep += Math.ceil(-sweep / (2 * Math.PI)) * 2 * Math.PI;
          }
          if (ccw) {
            sweep = -sweep;
          }
          const arcSections = Math.max(Math.ceil(Math.abs(sweep) / (Math.PI / 2)), 1);
          const step = sweep / arcSections;
          const h = 4 / 3 * Math.tan(step / 4);
          const move = buffer.length === 0 ? "M" : "L";
          addCommand(move, cx + Math.cos(A0) * r, cy + Math.sin(A0) * r);
          for (let i = 0; i < arcSections; i += 1) {
            const a0 = A0 + step * (i + 0);
            const a1 = A0 + step * (i + 1);
            const rSinStart = r * Math.sin(a0);
            const rCosStart = r * Math.cos(a0);
            const rSinEnd = r * Math.sin(a1);
            const rCosEnd = r * Math.cos(a1);
            addCommand(
              "C",
              cx + rCosStart - h * rSinStart,
              cy + rSinStart + h * rCosStart,
              cx + rCosEnd + h * rSinEnd,
              cy + rSinEnd - h * rCosEnd,
              cx + rCosEnd,
              cy + rSinEnd
            );
          }
          break;
        }
        case 4 /* ClosePath */:
          buffer.push("Z");
          break;
      }
    }
    return buffer.join(" ");
  }
  computeBBox() {
    const { commands, params } = this;
    let [top, left, right, bot] = [Infinity, Infinity, -Infinity, -Infinity];
    let [sx, sy] = [NaN, NaN];
    let [mx, my] = [NaN, NaN];
    const joinPoint = (x, y, updatestart) => {
      top = Math.min(y, top);
      left = Math.min(x, left);
      right = Math.max(x, right);
      bot = Math.max(y, bot);
      if (updatestart) {
        [sx, sy] = [x, y];
      }
    };
    let pi = 0;
    for (const command of commands) {
      switch (command) {
        case 0 /* Move */:
          joinPoint(params[pi++], params[pi++], true);
          [mx, my] = [sx, sy];
          break;
        case 1 /* Line */:
          joinPoint(params[pi++], params[pi++], true);
          break;
        case 3 /* Curve */: {
          const cp1x = params[pi++];
          const cp1y = params[pi++];
          const cp2x = params[pi++];
          const cp2y = params[pi++];
          const x = params[pi++];
          const y = params[pi++];
          joinPoint(x, y, true);
          const Ts = calculateDerivativeExtremaXY(sx, sy, cp1x, cp1y, cp2x, cp2y, x, y);
          Ts.forEach((t) => {
            const px = evaluateBezier(sx, cp1x, cp2x, x, t);
            const py = evaluateBezier(sy, cp1y, cp2y, y, t);
            joinPoint(px, py);
          });
          break;
        }
        case 2 /* Arc */: {
          const cx = params[pi++];
          const cy = params[pi++];
          const r = params[pi++];
          let A0 = normalizeAngle360(params[pi++]);
          let A1 = normalizeAngle360(params[pi++]);
          const ccw = params[pi++];
          if (ccw) {
            [A0, A1] = [A1, A0];
          }
          const joinAngle = (angle2, updatestart) => {
            const px = cx + r * Math.cos(angle2);
            const py = cy + r * Math.sin(angle2);
            joinPoint(px, py, updatestart);
          };
          joinAngle(A0);
          joinAngle(A1, true);
          const criticalAngles = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2];
          for (const crit of criticalAngles) {
            if (A0 < A1 && A0 <= crit && crit <= A1 || A0 > A1 && (A0 <= crit || crit <= A1)) {
              joinAngle(crit);
            }
          }
          break;
        }
        case 4 /* ClosePath */:
          [sx, sy] = [mx, my];
          break;
      }
    }
    return new BBox(left, top, right - left, bot - top);
  }
};

// packages/ag-charts-community/src/scene/shape/path.ts
function ScenePathChangeDetection(opts) {
  const { redraw = 3 /* MAJOR */, changeCb, convertor } = opts ?? {};
  return SceneChangeDetection({ redraw, type: "path", convertor, changeCb });
}
var Path = class extends Shape {
  constructor() {
    super(...arguments);
    /**
     * Declare a path to retain for later rendering and hit testing
     * using custom Path2D class. Think of it as a TypeScript version
     * of the native Path2D (with some differences) that works in all browsers.
     */
    this.path = new ExtendedPath2D();
    this._clipX = NaN;
    this._clipY = NaN;
    this.clip = false;
    /**
     * The path only has to be updated when certain attributes change.
     * For example, if transform attributes (such as `translationX`)
     * are changed, we don't have to update the path. The `dirtyPath` flag
     * is how we keep track if the path has to be updated or not.
     */
    this._dirtyPath = true;
  }
  set clipX(value) {
    this._clipX = value;
    this.dirtyPath = true;
  }
  set clipY(value) {
    this._clipY = value;
    this.dirtyPath = true;
  }
  set dirtyPath(value) {
    if (this._dirtyPath !== value) {
      this._dirtyPath = value;
      if (value) {
        this.markDirty(3 /* MAJOR */);
      }
    }
  }
  get dirtyPath() {
    return this._dirtyPath;
  }
  checkPathDirty() {
    if (this._dirtyPath) {
      return;
    }
    this.dirtyPath = this.path.isDirty() || (this.fillShadow?.isDirty() ?? false) || (this._clipPath?.isDirty() ?? false);
  }
  isPointInPath(x, y) {
    this.updatePathIfDirty();
    return this.path.closedPath && this.path.isPointInPath(x, y);
  }
  distanceSquared(x, y) {
    return this.distanceSquaredTransformedPoint(x, y);
  }
  svgPathData(transform) {
    if (this.dirtyPath) {
      this.updatePath();
      this.dirtyPath = false;
    }
    return this.path.toSVG(transform);
  }
  distanceSquaredTransformedPoint(x, y) {
    this.updatePathIfDirty();
    if (this.path.closedPath && this.path.isPointInPath(x, y)) {
      return 0;
    }
    return this.path.distanceSquared(x, y);
  }
  isDirtyPath() {
    return false;
  }
  updatePath() {
  }
  updatePathIfDirty() {
    if (this.dirtyPath || this.isDirtyPath()) {
      this.updatePath();
      this.dirtyPath = false;
    }
  }
  preRender() {
    this.updatePathIfDirty();
    return super.preRender();
  }
  render(renderCtx) {
    const { ctx, forceRender, stats } = renderCtx;
    if (this.dirty === 0 /* NONE */ && !forceRender) {
      if (stats)
        stats.nodesSkipped += nodeCount(this).count;
      return;
    }
    if (this.clip && !isNaN(this._clipX) && !isNaN(this._clipY)) {
      ctx.save();
      const margin = this.strokeWidth / 2;
      this._clipPath ?? (this._clipPath = new ExtendedPath2D());
      this._clipPath.clear();
      this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);
      ctx.clip(this._clipPath?.getPath2D());
      if (this._clipX > 0 && this._clipY > 0) {
        this.drawPath(ctx);
      }
      ctx.restore();
    } else {
      this._clipPath = void 0;
      this.drawPath(ctx);
    }
    this.fillShadow?.markClean();
    super.render(renderCtx);
  }
  drawPath(ctx) {
    this.fillStroke(ctx, this.path.getPath2D());
  }
  toSVG() {
    if (!this.visible)
      return;
    const element2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    element2.setAttribute("d", this.svgPathData());
    element2.setAttribute("fill", typeof this.fill === "string" ? this.fill : "none");
    element2.setAttribute("fill-opacity", String(this.fillOpacity));
    if (this.stroke != null) {
      element2.setAttribute("stroke", this.stroke);
      element2.setAttribute("stroke-opacity", String(this.strokeOpacity));
      element2.setAttribute("stroke-width", String(this.strokeWidth));
    }
    return {
      elements: [element2]
    };
  }
};
Path.className = "Path";
__decorateClass([
  ScenePathChangeDetection()
], Path.prototype, "clip", 2);
__decorateClass([
  ScenePathChangeDetection()
], Path.prototype, "clipX", 1);
__decorateClass([
  ScenePathChangeDetection()
], Path.prototype, "clipY", 1);

// packages/ag-charts-community/src/dom/focusIndicator.ts
var FOCUS_INDICATOR_CSS_CLASS = "ag-charts-focus-indicator";
var FocusIndicator = class {
  constructor(domManager) {
    this.domManager = domManager;
    this.div = getDocument().createElement("div");
    this.svg = getDocument().createElementNS("http://www.w3.org/2000/svg", "svg");
    this.path = getDocument().createElementNS("http://www.w3.org/2000/svg", "path");
    this.svg.append(this.path);
    this.element = domManager.addChild("series-area", FOCUS_INDICATOR_CSS_CLASS);
    this.element.classList.add(FOCUS_INDICATOR_CSS_CLASS);
    this.element.ariaHidden = "true";
    this.element.append(this.svg);
  }
  destroy() {
    this.domManager.removeStyles(FOCUS_INDICATOR_CSS_CLASS);
    this.domManager.removeChild("series-area", FOCUS_INDICATOR_CSS_CLASS);
  }
  updateBounds(bounds) {
    if (bounds === void 0) {
    } else if (bounds instanceof Path) {
      const transform = (x, y) => Transformable.toCanvasPoint(bounds, x, y);
      this.path.setAttribute("d", bounds.svgPathData(transform));
      this.show(this.svg);
    } else {
      setElementBBox(this.div, bounds);
      this.show(this.div);
    }
  }
  show(child) {
    this.element.innerHTML = "";
    this.element.append(child);
  }
  getFocusableElement() {
    const focusable = this.element.parentElement;
    if (focusable == null || focusable.tabIndex !== 0 && focusable.tabIndex !== -1)
      throw new Error("AG Charts - the focus indicator must be a child of a focusable element");
    return focusable;
  }
  // Use with caution! The focus must be visible when using the keyboard.
  overrideFocusVisible(focusVisible) {
    const opacity = { true: "1", false: "0", undefined: "" };
    this.getFocusableElement().style.setProperty("opacity", opacity[`${focusVisible}`]);
  }
  // Get the `:focus-visible` CSS state.
  isFocusVisible() {
    const focusable = this.getFocusableElement();
    return focusable != null && getWindow().getComputedStyle(focusable).opacity === "1";
  }
};

// packages/ag-charts-community/src/dom/boundedText.ts
var BoundedText = class {
  set textContent(text) {
    this.textElement.textContent = text;
    const bboxCalculator = this.textElement;
    const bbox = bboxCalculator.getBBox?.();
    if (bbox) {
      this.svgElement.setAttribute("viewBox", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);
    }
  }
  get textContent() {
    return this.textElement.textContent;
  }
  constructor() {
    this.textElement = createElementNS("http://www.w3.org/2000/svg", "text");
    this.textElement.role = "presentation";
    this.svgElement = createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svgElement.appendChild(this.textElement);
    this.svgElement.style.width = "100%";
    this.svgElement.style.opacity = "0";
    this.svgElement.role = "presentation";
    this.boundedContainer = createElement("div");
    this.boundedContainer.appendChild(this.svgElement);
    this.boundedContainer.role = "presentation";
  }
  remove() {
    this.boundedContainer.remove();
  }
  getContainer() {
    return this.boundedContainer;
  }
  updateBounds(bounds) {
    setElementBBox(this.boundedContainer, bounds);
  }
};

// packages/ag-charts-community/src/dom/proxyInteractionService.ts
function checkType(type, meta) {
  return meta.params?.type === type;
}
function allocateResult(type) {
  if ("button" === type) {
    return createElement("button");
  } else if ("slider" === type) {
    return createElement("input");
  } else if (["toolbar", "group", "list"].includes(type)) {
    return createElement("div");
  } else if ("text" === type) {
    return new BoundedText();
  } else if ("listswitch" === type) {
    return { button: createElement("button"), listitem: createElement("div") };
  } else {
    throw Error("AG Charts - error allocating meta");
  }
}
function allocateMeta(params) {
  const meta = { params, result: void 0 };
  meta.result = allocateResult(meta.params.type);
  return meta;
}
var ProxyInteractionService = class {
  constructor(localeManager, domManager) {
    this.localeManager = localeManager;
    this.domManager = domManager;
    this.destroyFns = [];
  }
  destroy() {
    this.destroyFns.forEach((fn) => fn());
  }
  addLocalisation(fn) {
    fn();
    this.destroyFns.push(this.localeManager.addListener("locale-changed", fn));
  }
  createProxyContainer(args) {
    const meta = allocateMeta(args);
    const { params, result: div } = meta;
    this.domManager.addChild("canvas-proxy", params.id, div);
    div.classList.add(...params.classList, "ag-charts-proxy-container");
    div.role = params.type;
    if ("ariaOrientation" in params) {
      div.ariaOrientation = params.ariaOrientation;
    }
    if (typeof params.ariaHidden === "boolean") {
      div.ariaHidden = params.ariaHidden.toString();
    }
    this.addLocalisation(() => {
      div.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);
    });
    return div;
  }
  createProxyElement(args) {
    const meta = allocateMeta(args);
    if (checkType("button", meta)) {
      const { params, result: button } = meta;
      this.initInteract(params, button);
      button.style.pointerEvents = "auto";
      if (typeof params.textContent === "string") {
        button.textContent = params.textContent;
      } else {
        const { textContent } = params;
        this.addLocalisation(() => {
          button.textContent = this.localeManager.t(textContent.id, textContent.params);
        });
      }
      this.setParent(params, button);
    }
    if (checkType("slider", meta)) {
      const { params, result: slider } = meta;
      this.initInteract(params, slider);
      slider.type = "range";
      slider.role = "presentation";
      slider.style.margin = "0px";
      slider.ariaOrientation = params.ariaOrientation;
      this.addLocalisation(() => {
        slider.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);
      });
      this.setParent(params, slider);
    }
    if (checkType("text", meta)) {
      const { params, result: text } = meta;
      this.initElement(params, text.getContainer());
      this.setParent(params, text.getContainer());
    }
    if (checkType("listswitch", meta)) {
      const {
        params,
        result: { button, listitem }
      } = meta;
      this.initInteract(params, button);
      button.style.width = "100%";
      button.style.height = "100%";
      button.textContent = params.textContent;
      button.role = "switch";
      button.ariaChecked = params.ariaChecked.toString();
      button.style.pointerEvents = "auto";
      button.setAttribute("aria-describedby", params.ariaDescribedBy);
      listitem.role = "listitem";
      listitem.style.position = "absolute";
      listitem.replaceChildren(button);
      this.setParent(params, listitem);
    }
    return meta.result;
  }
  initElement(params, element2) {
    const { id } = params;
    element2.id = id;
    element2.classList.toggle("ag-charts-proxy-elem", true);
  }
  initInteract(params, element2) {
    const { onclick, ondblclick, onmouseenter, onmouseleave, oncontextmenu, onchange, onfocus, onblur, tabIndex } = params;
    this.initElement(params, element2);
    if (tabIndex !== void 0) {
      element2.tabIndex = tabIndex;
    }
    if (onclick) {
      element2.addEventListener("click", onclick);
    }
    if (ondblclick) {
      element2.addEventListener("dblclick", ondblclick);
    }
    if (onmouseenter) {
      element2.addEventListener("mouseenter", onmouseenter);
    }
    if (onmouseleave) {
      element2.addEventListener("mouseleave", onmouseleave);
    }
    if (oncontextmenu) {
      element2.addEventListener("contextmenu", oncontextmenu);
    }
    if (onfocus) {
      element2.addEventListener("focus", onfocus);
    }
    if (onblur) {
      element2.addEventListener("blur", onblur);
    }
    if (onchange) {
      element2.addEventListener("change", onchange);
    }
  }
  setParent(params, element2) {
    const { id, parent } = params;
    if (typeof parent === "string") {
      const insert = { where: parent, query: ".ag-charts-series-area" };
      this.domManager.addChild("canvas-proxy", id, element2, insert);
    } else {
      parent.appendChild(element2);
    }
  }
};

// packages/ag-charts-locale/src/en-US.ts
var AG_CHARTS_LOCALE_EN_US = {
  // Screen reader announcement when focusing an item in the chart
  ariaAnnounceHoverDatum: "${datum}",
  // Screen reader announcement when focusing a chart
  ariaAnnounceChart: "chart, ${seriesCount}[number] series",
  // Screen reader announcement when focusing a hierarchy chart
  ariaAnnounceHierarchyChart: "hierarchy chart, ${caption}",
  // Screen reader announcement when focusing a gauge chart
  ariaAnnounceGaugeChart: "gauge chart, ${caption}",
  // Screen reader announcement when focusing an item in a treemap or sunburst chart
  ariaAnnounceHierarchyDatum: "level ${level}[number], ${count}[number] children, ${description}",
  // Screen reader announcement when focusing a link in a Sankey or chord chart
  ariaAnnounceFlowProportionLink: "link ${index} of ${count}, from ${from} to ${to}, ${sizeName} ${size}",
  // Screen reader announcement when focusing a node in a Sankey or chord chart
  ariaAnnounceFlowProportionNode: "node ${index} of ${count}, ${description}",
  // Screen reader description for legend items
  ariaDescriptionLegendItem: "Press Space or Enter to toggle visibility",
  // Screen reader text for annotation-options toolbar
  ariaLabelAnnotationOptionsToolbar: "Annotation Options",
  // Screen reader text for annotation-settings dialog
  ariaLabelAnnotationSettingsDialog: "Annotation Settings",
  // Screen reader text for the color picker dialog
  ariaLabelColorPicker: "Color picker",
  // Screen reader text for the financial charts toolbar
  ariaLabelFinancialCharts: "Financial Charts",
  // Screen reader text for the legend toolbar
  ariaLabelLegend: "Legend",
  // Screen reader text for the legend pagination button
  ariaLabelLegendPagination: "Legend Pagination",
  // Screen reader text for the previous legend page button
  ariaLabelLegendPagePrevious: "Previous Legend Page",
  // Screen reader text for the next legend page button
  ariaLabelLegendPageNext: "Next Legend Page",
  // Screen reader text for the an item in the legend
  ariaLabelLegendItem: "${label}, Legend item ${index}[number] of ${count}[number]",
  // Screen reader text for the an unknown item in the legend
  ariaLabelLegendItemUnknown: "Unknown legend item",
  // Screen reader text for the navigator element
  ariaLabelNavigator: "Navigator",
  // Screen reader text for an accessibility control that changes the position of the navigator's range
  ariaLabelNavigatorRange: "Range",
  // Screen reader text for an accessibility control that changes the start of the navigator's range
  ariaLabelNavigatorMinimum: "Minimum",
  // Screen reader text for an accessibility control that changes the end of the navigator's range
  ariaLabelNavigatorMaximum: "Maximum",
  // Screen reader text for ranges toolbar
  ariaLabelRangesToolbar: "Ranges",
  // Screen reader text for the settings dialog tab-bar
  ariaLabelSettingsTabBar: "Settings",
  // Screen reader text for zoom toolbar
  ariaLabelZoomToolbar: "Zoom",
  // Screen reader text for the value of the navigator's range
  ariaValuePanRange: "${min}[percent] to ${max}[percent]",
  // Alt-text for the solid line dash style menu item icon
  iconAltTextLineStyleSolid: "Solid",
  // Alt-text for the long-dashed line dash style menu item icon
  iconAltTextLineStyleDashed: "Long-dashed",
  // Alt-text for the short-dashed line dash style menu item icon
  iconAltTextLineStyleDotted: "Short-dashed",
  // Alt-text for the 'position-top' icon
  iconAltTextPositionTop: "Top",
  // Alt-text for the 'position-center' icon
  iconAltTextPositionCenter: "Center",
  // Alt-text for the 'position-bottom' icon
  iconAltTextPositionBottom: "Bottom",
  // Alt-text for the 'position-left' icon
  iconAltTextAlignLeft: "Left",
  // Alt-text for the 'align-center' icon
  iconAltTextAlignCenter: "Center",
  // Alt-text for the 'position-right' icon
  iconAltTextAlignRight: "Right",
  // Alt-text for the 'close' icon
  iconAltTextClose: "Close",
  // Default text for the 'loading data' overlay
  overlayLoadingData: "Loading data...",
  // Default text for the 'no data' overlay
  overlayNoData: "No data to display",
  // Default text for the 'no visible series' overlay
  overlayNoVisibleSeries: "No visible series",
  // Text for the series type toolbar's chart type button
  toolbarSeriesTypeDropdown: "Chart Type",
  // Text for the series type toolbar's OHLC chart type button
  toolbarSeriesTypeOHLC: "OHLC",
  // Text for the series type toolbar's HLC chart type button
  toolbarSeriesTypeHLC: "HLC",
  // Text for the series type toolbar's high low chart type button
  toolbarSeriesTypeHighLow: "High Low",
  // Text for the series type toolbar's candles chart type button
  toolbarSeriesTypeCandles: "Candles",
  // Text for the series type toolbar's hollow candles chart type button
  toolbarSeriesTypeHollowCandles: "Hollow Candles",
  // Text for the series type toolbar's line chart type button
  toolbarSeriesTypeLine: "Line",
  // Text for the series type toolbar's line with markers chart type button
  toolbarSeriesTypeLineWithMarkers: "Line with Markers",
  // Text for the series type toolbar's line with step line chart type button
  toolbarSeriesTypeStepLine: "Step Line",
  // Text for the annotation toolbar's trend line button
  toolbarAnnotationsTrendLine: "Trend Line",
  // Text for the annotation toolbar's horizontal line button
  toolbarAnnotationsHorizontalLine: "Horizontal Line",
  // Text for the annotation toolbar's vertical line button
  toolbarAnnotationsVerticalLine: "Vertical Line",
  // Text for the annotation toolbar's parallel channel button
  toolbarAnnotationsParallelChannel: "Parallel Channel",
  // Text for the annotation toolbar's disjoint channel button
  toolbarAnnotationsDisjointChannel: "Disjoint Channel",
  // Text for the annotation toolbar's clear all button
  toolbarAnnotationsClearAll: "Clear All",
  /**
   * Text for the annotation toolbar's color picker annotation button
   * @deprecated v10.1.0 use `toolbarAnnotationsLineColor` instead.
   */
  toolbarAnnotationsColor: "Color",
  // Text for the annotation toolbar's fill color picker annotation button
  toolbarAnnotationsFillColor: "Fill Color",
  // Text for the annotation toolbar's line color picker annotation button
  toolbarAnnotationsLineColor: "Line Color",
  // Text for the annotation toolbar's line style type button
  toolbarAnnotationsLineStyle: "Line Style",
  // Text for the annotation toolbar's line stroke width button
  toolbarAnnotationsLineStrokeWidth: "Line Stroke Width",
  // Text for the annotation toolbar's settings annotation button
  toolbarAnnotationsSettings: "Settings",
  // Text for the annotation toolbar's text color picker annotation button
  toolbarAnnotationsTextColor: "Text Color",
  // Text for the annotation toolbar's text size picker annotation button
  toolbarAnnotationsTextSize: "Text Size",
  // Text for the annotation toolbar's lock annotation button
  toolbarAnnotationsLock: "Lock",
  // Text for the annotation toolbar's unlock annotation button
  toolbarAnnotationsUnlock: "Unlock",
  // Text for the annotation toolbar's delete annotation button
  toolbarAnnotationsDelete: "Delete",
  // Text for the annotation toolbar's drag handle
  toolbarAnnotationsDragHandle: "Drag Toolbar",
  // Text for the annotation toolbar's line drawings menu button
  toolbarAnnotationsLineAnnotations: "Trend Lines",
  // Text for the annotation toolbar's text annotations menu button
  toolbarAnnotationsTextAnnotations: "Text Annotations",
  // Text for the annotation toolbar's shapes menu button
  toolbarAnnotationsShapeAnnotations: "Arrows",
  // Text for the annotation toolbar's measurers menu button
  toolbarAnnotationsMeasurerAnnotations: "Measurers",
  // Text for the annotation toolbar's callout button
  toolbarAnnotationsCallout: "Callout",
  // Text for the annotation toolbar's comment button
  toolbarAnnotationsComment: "Comment",
  // Text for the annotation toolbar's note button
  toolbarAnnotationsNote: "Note",
  // Text for the annotation toolbar's text button
  toolbarAnnotationsText: "Text",
  // Text for the annotation toolbar's arrow button
  toolbarAnnotationsArrow: "Arrow",
  // Text for the annotation toolbar's arrow up button
  toolbarAnnotationsArrowUp: "Arrow Up",
  // Text for the annotation toolbar's arrow down button
  toolbarAnnotationsArrowDown: "Arrow Down",
  // Text for the annotation toolbar's date range button
  toolbarAnnotationsDateRange: "Date Range",
  // Text for the annotation toolbar's price range button
  toolbarAnnotationsPriceRange: "Price Range",
  // Text for the annotation toolbar's date and price range button
  toolbarAnnotationsDatePriceRange: "Date and Price",
  // Text for the annotation toolbar's quick date and price range button
  toolbarAnnotationsQuickDatePriceRange: "Measure",
  // Text for the range toolbar's 1 month button
  toolbarRange1Month: "1M",
  // Aria label for the range toolbar's 1 month button
  toolbarRange1MonthAria: "1 month",
  // Text for the range toolbar's 3 month button
  toolbarRange3Months: "3M",
  // Aria label for the range toolbar's 3 month button
  toolbarRange3MonthsAria: "3 months",
  // Text for the range toolbar's 6 month button
  toolbarRange6Months: "6M",
  // Aria label for the range toolbar's 6 month button
  toolbarRange6MonthsAria: "6 months",
  // Text for the range toolbar's year to date button
  toolbarRangeYearToDate: "YTD",
  // Aria label for the range toolbar's year to date month button
  toolbarRangeYearToDateAria: "Year to date",
  // Text for the range toolbar's 1 year button
  toolbarRange1Year: "1Y",
  // Aria label for the range toolbar's 1 year button
  toolbarRange1YearAria: "1 year",
  // Text for the range toolbar's full range button
  toolbarRangeAll: "All",
  // Aria label for the range toolbar's full range button
  toolbarRangeAllAria: "All",
  // Text for the zoom toolbar's zoom out button
  toolbarZoomZoomOut: "Zoom out",
  // Text for the zoom toolbar's zoom in button
  toolbarZoomZoomIn: "Zoom in",
  // Text for the zoom toolbar's pan left button
  toolbarZoomPanLeft: "Pan left",
  // Text for the zoom toolbar's pan right button
  toolbarZoomPanRight: "Pan right",
  // Text for the zoom toolbar's pan to the start button
  toolbarZoomPanStart: "Pan to the start",
  // Text for the zoom toolbar's pan to the end button
  toolbarZoomPanEnd: "Pan to the end",
  // Text for the zoom toolbar's pan reset button
  toolbarZoomReset: "Reset the zoom",
  // Text for the context menu's download button
  contextMenuDownload: "Download",
  // Text for the context menu's toggle series visibility button
  contextMenuToggleSeriesVisibility: "Toggle Visibility",
  // Text for the context menu's toggle other series visibility button
  contextMenuToggleOtherSeries: "Toggle Other Series",
  // Text for the context menu's zoom to point button
  contextMenuZoomToCursor: "Zoom to here",
  // Text for the context menu's pan to point button
  contextMenuPanToCursor: "Pan to here",
  // Text for the annotation dialog's header channel tab label
  dialogHeaderChannel: "Channel",
  // Text for the annotation dialog's header line tab label
  dialogHeaderLine: "Line",
  // Text for the annotation dialog's header date range tab label
  dialogHeaderDateRange: "Date Range",
  // Text for the annotation dialog's header price range tab label
  dialogHeaderPriceRange: "Price Range",
  // Text for the annotation dialog's header date and price range tab label
  dialogHeaderDatePriceRange: "Date and Price",
  // Text for the annotation dialog's header text tab label
  dialogHeaderText: "Text",
  // Text for the annotation dialog's text alignment radio label
  dialogInputAlign: "Align",
  // Text for the annotation dialog's color picker label
  dialogInputColorPicker: "Color",
  // Text for the annotation dialog's color picker alt text
  dialogInputColorPickerAltText: "Text Color",
  // Text for the annotation dialog's fill color picker label
  dialogInputFillColorPicker: "Fill",
  // Text for the annotation dialog's fill color picker alt text
  dialogInputFillColorPickerAltText: "Fill Color",
  // Text for the annotation dialog's extend channel start checkbox
  dialogInputExtendChannelStart: "Extend channel start",
  // Text for the annotation dialog's extend channel end checkbox
  dialogInputExtendChannelEnd: "Extend channel end",
  // Text for the annotation dialog's extend line start checkbox
  dialogInputExtendLineStart: "Extend line start",
  // Text for the annotation dialog's extend line end checkbox
  dialogInputExtendLineEnd: "Extend line end",
  // Text for the annotation dialog's extend above checkbox
  dialogInputExtendAbove: "Extend above",
  // Text for the annotation dialog's extend below checkbox
  dialogInputExtendBelow: "Extend below",
  // Text for the annotation dialog's extend left checkbox
  dialogInputExtendLeft: "Extend left",
  // Text for the annotation dialog's extend right checkbox
  dialogInputExtendRight: "Extend right",
  // Text for the annotation dialog's font size select box label
  dialogInputFontSize: "Size",
  // Text for the annotation dialog's font size select box alt text
  dialogInputFontSizeAltText: "Font Size",
  // Text for the annotation dialog's line style radio label
  dialogInputLineStyle: "Dash",
  // Text for the annotation dialog's text position radio label
  dialogInputPosition: "Position",
  // Text for the annotation dialog's stroke width label
  dialogInputStrokeWidth: "Weight",
  // Text for the annotation dialog's stroke width label
  dialogInputStrokeWidthAltText: "Line Weight",
  // Text for text area input placeholders
  inputTextareaPlaceholder: "Add Text",
  // Text for the measurer statistics date range bars value
  measurerDateRangeBars: "${value}[number] bars",
  // Text for the measurer statistics price range value
  measurerPriceRangeValue: "${value}[number]",
  // Text for the measurer statistics price range percentage
  measurerPriceRangePercent: "${value}[percent]",
  // Text for the measurer statistics volume value
  measurerVolume: "Vol ${value}"
};

// packages/ag-charts-community/src/locale/defaultMessageFormatter.ts
var messageRegExp = /\$\{(\w+)}(?:\[(\w+)])?/gi;
var formatters = {
  number: new Intl.NumberFormat("en-US"),
  percent: new Intl.NumberFormat("en-US", { style: "percent", minimumFractionDigits: 2, maximumFractionDigits: 2 }),
  date: new Intl.DateTimeFormat("en-US", { dateStyle: "full" }),
  time: new Intl.DateTimeFormat("en-US", { timeStyle: "full" }),
  datetime: new Intl.DateTimeFormat("en-US", { dateStyle: "full", timeStyle: "full" })
};
var defaultMessageFormatter = ({ defaultValue, variables }) => {
  return defaultValue?.replaceAll(messageRegExp, (_, match, format) => {
    const value = variables[match];
    const formatter = format != null ? formatters[format] : null;
    if (format != null && formatter == null) {
      Logger.warnOnce(`Format style [${format}] is not supported`);
    }
    if (formatter != null) {
      return formatter.format(value);
    } else if (typeof value === "number") {
      return formatters.number.format(value);
    } else if (value instanceof Date) {
      return formatters.datetime.format(value);
    }
    return String(value);
  });
};

// packages/ag-charts-community/src/locale/localeManager.ts
var LocaleManager = class extends Listeners {
  constructor() {
    super(...arguments);
    this.localeText = void 0;
    this.getLocaleText = void 0;
  }
  setLocaleText(localeText) {
    if (this.localeText !== localeText) {
      this.localeText = localeText;
      this.dispatch("locale-changed");
    }
  }
  setLocaleTextFormatter(getLocaleText) {
    this.getLocaleText = getLocaleText;
    if (this.getLocaleText !== getLocaleText) {
      this.getLocaleText = getLocaleText;
      this.dispatch("locale-changed");
    }
  }
  t(key, variables = {}) {
    const { localeText = AG_CHARTS_LOCALE_EN_US, getLocaleText } = this;
    const defaultValue = localeText[key];
    return getLocaleText?.({ key, defaultValue, variables }) ?? defaultMessageFormatter({ key, defaultValue, variables }) ?? key;
  }
};

// packages/ag-charts-community/src/util/userAgent.ts
function hasConstrainedCanvasMemory() {
  if (typeof navigator === "undefined") {
    return false;
  }
  const iPhoneOSMatch = /\(iPhone; CPU iPhone OS (\d+_\d+_\d+) like Mac OS X\)/.exec(navigator.userAgent);
  if (iPhoneOSMatch == null) {
    return false;
  }
  const [major, minor] = iPhoneOSMatch[1].split("_").map(Number);
  return major < 16 || major === 16 && minor < 6;
}

// packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts
var _HdpiCanvas = class _HdpiCanvas {
  constructor(options) {
    this.enabled = true;
    this.width = 600;
    this.height = 300;
    const { width, height, pixelRatio, canvasElement, willReadFrequently = false } = options;
    this.pixelRatio = hasConstrainedCanvasMemory() ? 1 : pixelRatio ?? getWindow("devicePixelRatio");
    this.element = canvasElement ?? createElement("canvas");
    this.element.style.display = "block";
    this.element.style.width = (width ?? this.width) + "px";
    this.element.style.height = (height ?? this.height) + "px";
    this.element.width = Math.round((width ?? this.width) * this.pixelRatio);
    this.element.height = Math.round((height ?? this.height) * this.pixelRatio);
    this.context = this.element.getContext("2d", { willReadFrequently });
    this.onEnabledChange();
    this.resize(width ?? 0, height ?? 0);
    _HdpiCanvas.debugContext(this.context);
  }
  static is(value) {
    return value instanceof _HdpiCanvas;
  }
  drawImage(context, dx = 0, dy = 0) {
    return context.drawImage(this.context.canvas, dx, dy);
  }
  toDataURL(type) {
    return this.element.toDataURL(type);
  }
  resize(width, height) {
    if (!(width > 0 && height > 0))
      return;
    const { element: element2, context, pixelRatio } = this;
    element2.width = Math.round(width * pixelRatio);
    element2.height = Math.round(height * pixelRatio);
    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    element2.style.width = width + "px";
    element2.style.height = height + "px";
    this.width = width;
    this.height = height;
  }
  clear() {
    this.context.save();
    this.context.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
    this.context.clearRect(0, 0, this.width, this.height);
    this.context.restore();
  }
  destroy() {
    this.element.remove();
    this.element.width = 0;
    this.element.height = 0;
    this.context.clearRect(0, 0, 0, 0);
    Object.freeze(this);
  }
  onEnabledChange() {
    if (this.element) {
      this.element.style.display = this.enabled ? "" : "none";
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
  static debugContext(ctx) {
    if (Debug.check("canvas")) {
      const save = ctx.save.bind(ctx);
      const restore = ctx.restore.bind(ctx);
      let depth = 0;
      Object.assign(ctx, {
        save() {
          save();
          depth++;
        },
        restore() {
          if (depth === 0) {
            throw new Error("AG Charts - Unable to restore() past depth 0");
          }
          restore();
          depth--;
        },
        verifyDepthZero() {
          if (depth !== 0) {
            throw new Error(`AG Charts - Save/restore depth is non-zero: ${depth}`);
          }
        }
      });
    }
  }
};
__decorateClass([
  ObserveChanges((target) => target.onEnabledChange())
], _HdpiCanvas.prototype, "enabled", 2);
var HdpiCanvas = _HdpiCanvas;

// packages/ag-charts-community/src/scene/layersManager.ts
var LayersManager = class _LayersManager {
  constructor(canvas, markDirty) {
    this.canvas = canvas;
    this.markDirty = markDirty;
    this.debug = Debug.create(true, "scene");
    this.layersMap = /* @__PURE__ */ new Map();
    this.nextZIndex = 0;
    this.nextLayerId = 0;
  }
  static sortLayers(a, b) {
    return compoundAscending(
      [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.id],
      [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.id],
      ascendingStringNumberUndefined
    );
  }
  get size() {
    return this.layersMap.size;
  }
  forEach(callback2) {
    Array.from(this.layersMap.values()).sort(_LayersManager.sortLayers).forEach(callback2);
  }
  resize(width, height) {
    this.canvas.resize(width, height);
    this.layersMap.forEach(({ canvas }) => canvas.resize(width, height));
  }
  addLayer(opts) {
    const { width, height, pixelRatio } = this.canvas;
    const { zIndex = this.nextZIndex++, name, zIndexSubOrder, getComputedOpacity, getVisibility } = opts;
    const canvas = new HdpiCanvas({ width, height, pixelRatio });
    if (zIndex >= this.nextZIndex) {
      this.nextZIndex = zIndex + 1;
    }
    this.layersMap.set(canvas, {
      id: this.nextLayerId++,
      name,
      canvas,
      zIndex,
      zIndexSubOrder,
      getComputedOpacity,
      getVisibility
    });
    this.debug("Scene.addLayer() - layers", this.layersMap);
    return canvas;
  }
  removeLayer(canvas) {
    if (this.layersMap.has(canvas)) {
      this.layersMap.delete(canvas);
      canvas.destroy();
      this.markDirty();
      this.debug("Scene.removeLayer() -  layers", this.layersMap);
    }
  }
  moveLayer(canvas, newZIndex, newZIndexSubOrder) {
    const layer = this.layersMap.get(canvas);
    if (layer) {
      layer.zIndex = newZIndex;
      layer.zIndexSubOrder = newZIndexSubOrder;
      this.markDirty();
      this.debug("Scene.moveLayer() -  layers", this.layersMap);
    }
  }
  clear() {
    this.layersMap.clear();
  }
};

// packages/ag-charts-community/src/scene/spriteRenderer.ts
var _SpriteRenderer = class _SpriteRenderer {
  constructor() {
    this.offscreenCanvas = new OffscreenCanvas(1, 1);
    _SpriteRenderer.offscreenCanvasCount++;
    const ctx = this.offscreenCanvas.getContext("2d");
    if (ctx == null)
      throw new TypeError(`AG Charts - invalid 2d context`);
    this.renderCtx = {
      ctx,
      devicePixelRatio: 1,
      forceRender: true,
      resized: false,
      debugNodes: {}
    };
  }
  resize({ spritePixelRatio, spriteWidth, spriteHeight }) {
    this.offscreenCanvas.width = Math.max(spriteWidth, 0) * spritePixelRatio;
    this.offscreenCanvas.height = Math.max(spriteHeight, 0) * spritePixelRatio;
  }
  renderSprite(nodes, opts) {
    nodes = toIterable(nodes);
    const {
      renderCtx,
      renderCtx: { ctx },
      offscreenCanvas
    } = this;
    const { scale: scale2 = 1, translateX = 0, translateY = 0 } = opts ?? {};
    ctx.resetTransform();
    ctx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
    ctx.save();
    ctx.beginPath();
    ctx.setTransform(scale2, 0, 0, scale2, translateX, translateY);
    for (const node of nodes) {
      node.preRender();
      node.render(renderCtx);
    }
    ctx.closePath();
    ctx.restore();
    return offscreenCanvas.transferToImageBitmap();
  }
};
_SpriteRenderer.offscreenCanvasCount = 0;
var SpriteRenderer = _SpriteRenderer;

// packages/ag-charts-community/src/scene/sceneDebug.ts
function debugStats(layersManager, debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}, seriesRect = BBox.zero) {
  if (!Debug.check("scene:stats" /* SCENE_STATS */, "scene:stats:verbose" /* SCENE_STATS_VERBOSE */))
    return;
  const { layersRendered = 0, layersSkipped = 0, nodesRendered = 0, nodesSkipped = 0 } = renderCtxStats ?? {};
  const end = performance.now();
  const { start, ...durations } = debugSplitTimes;
  const splits = Object.entries(durations).map(([n, t]) => {
    return time(n, t);
  }).filter((v) => v != null).join(" + ");
  const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${v}`).join(" ; ");
  const detailedStats = Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */);
  const stats = [
    `${time("\u23F1\uFE0F", start, end)} (${splits})`,
    `${extras}`,
    `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : layersManager.size}; Sprites: ${SpriteRenderer.offscreenCanvasCount}`,
    detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null
  ].filter(isString);
  const measurer = new SimpleTextMeasurer((t) => ctx.measureText(t));
  const statsSize = new Map(stats.map((t) => [t, measurer.measureLines(t)]));
  const width = Math.max(...Array.from(statsSize.values(), (s) => s.width));
  const height = accumulate(statsSize.values(), (s) => s.height);
  const x = 2 + seriesRect.x;
  ctx.save();
  ctx.fillStyle = "white";
  ctx.fillRect(x, 0, width, height);
  ctx.fillStyle = "black";
  let y = 0;
  for (const [stat, size] of statsSize.entries()) {
    y += size.height;
    ctx.fillText(stat, x, y);
  }
  ctx.restore();
}
function prepareSceneNodeHighlight(ctx) {
  const config = toArray(getWindow("agChartsSceneDebug"));
  const result = [];
  for (const name of config) {
    if (name === "layout") {
      result.push("seriesRoot", "legend", "root", /.*Axis-\d+-axis.*/);
    } else {
      result.push(name);
    }
  }
  ctx.debugNodeSearch = result;
}
function debugSceneNodeHighlight(ctx, debugNodes) {
  ctx.save();
  for (const [name, node] of Object.entries(debugNodes)) {
    const bbox = Transformable.toCanvas(node);
    if (!bbox) {
      Logger.log(`Scene.render() - no bbox for debugged node [${name}].`);
      continue;
    }
    ctx.globalAlpha = 0.8;
    ctx.strokeStyle = "red";
    ctx.lineWidth = 1;
    ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
    ctx.fillStyle = "red";
    ctx.strokeStyle = "white";
    ctx.font = "16px sans-serif";
    ctx.textBaseline = "top";
    ctx.textAlign = "left";
    ctx.lineWidth = 2;
    ctx.strokeText(name, bbox.x, bbox.y, bbox.width);
    ctx.fillText(name, bbox.x, bbox.y, bbox.width);
  }
  ctx.restore();
}
var skippedProperties = /* @__PURE__ */ new Set();
var allowedProperties = /* @__PURE__ */ new Set([
  "gradient",
  // '_datum',
  "zIndex",
  "clipRect",
  "cachedBBox",
  "childNodeCounts",
  "path",
  "__zIndex",
  "name",
  "__scalingCenterX",
  "__scalingCenterY",
  "__rotationCenterX",
  "__rotationCenterY",
  "_previousDatum",
  "__fill",
  "__lineDash",
  "borderPath",
  "borderClipPath",
  "_clipPath"
]);
function nodeProps(node) {
  const { ...allProps } = node;
  for (const prop in allProps) {
    if (allowedProperties.has(prop))
      continue;
    if (typeof allProps[prop] === "number")
      continue;
    if (typeof allProps[prop] === "string")
      continue;
    if (typeof allProps[prop] === "boolean")
      continue;
    skippedProperties.add(prop);
    delete allProps[prop];
  }
  return allProps;
}
function buildTree(node, mode) {
  if (!Debug.check(true, "scene" /* SCENE */)) {
    return {};
  }
  const { parentNode } = node;
  let order = 0;
  return {
    node: mode === "json" ? nodeProps(node) : node,
    name: node.name ?? node.id,
    dirty: RedrawType[node.dirty],
    ...parentNode?.isVirtual ? {
      virtualParentDirty: RedrawType[parentNode.dirty],
      virtualParent: parentNode
    } : {},
    ...Array.from(node.children(false), (c) => buildTree(c, mode)).reduce(
      (result, childTree) => {
        let { name: treeNodeName } = childTree;
        const {
          node: {
            visible,
            opacity,
            zIndex,
            zIndexSubOrder,
            translationX,
            translationY,
            rotation,
            scalingX,
            scalingY
          },
          node: childNode,
          virtualParent
        } = childTree;
        if (!visible || opacity <= 0) {
          treeNodeName = `(${treeNodeName})`;
        }
        if (Layer.is(childNode)) {
          treeNodeName = `*${treeNodeName}*`;
        }
        const subOrder = zIndexSubOrder?.map((v) => typeof v === "function" ? `${v()} (fn)` : v).join(" / ");
        const key = [
          `${(order++).toString().padStart(3, "0")}|`,
          `${treeNodeName ?? "<unknown>"}`,
          `z: ${zIndex}`,
          subOrder && `zo: ${subOrder}`,
          virtualParent && `(virtual parent)`,
          translationX && `x: ${translationX}`,
          translationY && `y: ${translationY}`,
          rotation && `r: ${rotation}`,
          scalingX != null && scalingX !== 1 && `sx: ${scalingX}`,
          scalingY != null && scalingY !== 1 && `sy: ${scalingY}`
        ].filter((v) => !!v).join(" ");
        let selectedKey = key;
        let index = 1;
        while (result[selectedKey] != null && index < 100) {
          selectedKey = `${key} (${index++})`;
        }
        result[selectedKey] = childTree;
        return result;
      },
      {}
    )
  };
}
function buildDirtyTree(node) {
  if (node.dirty === 0 /* NONE */) {
    return { dirtyTree: {}, paths: [] };
  }
  const childrenDirtyTree = Array.from(node.children(), (c) => buildDirtyTree(c)).filter((c) => c.paths.length > 0);
  const name = Group.is(node) ? node.name ?? node.id : node.id;
  const paths = childrenDirtyTree.length ? childrenDirtyTree.flatMap((c) => c.paths).map((p) => `${name}.${p}`) : [name];
  return {
    dirtyTree: {
      name,
      node,
      dirty: RedrawType[node.dirty],
      ...childrenDirtyTree.map((c) => c.dirtyTree).filter((t) => t.dirty != null).reduce((result, childTree) => {
        result[childTree.name ?? "<unknown>"] = childTree;
        return result;
      }, {})
    },
    paths
  };
}
function pct(rendered, skipped) {
  const total = rendered + skipped;
  return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;
}
function time(name, start, end) {
  const duration = end != null ? end - start : start;
  return `${name}: ${Math.round(duration * 100) / 100}ms`;
}
function accumulate(iterator, mapper) {
  let sum = 0;
  for (const item of iterator) {
    sum += mapper(item);
  }
  return sum;
}

// packages/ag-charts-community/src/scene/scene.ts
var Scene = class {
  constructor(canvasOptions) {
    this.debug = Debug.create(true, "scene" /* SCENE */);
    this.id = createId(this);
    this.root = null;
    this.pendingSize = null;
    this.isDirty = false;
    this.canvas = new HdpiCanvas(canvasOptions);
    this.layersManager = new LayersManager(this.canvas, () => {
      this.isDirty = true;
    });
  }
  get width() {
    return this.pendingSize?.[0] ?? this.canvas.width;
  }
  get height() {
    return this.pendingSize?.[1] ?? this.canvas.height;
  }
  /** @deprecated v10.2.0 Only used by AG Grid Sparklines */
  setContainer(value) {
    const { element: element2 } = this.canvas;
    element2.parentElement?.removeChild(element2);
    value.appendChild(element2);
    return this;
  }
  setRoot(node) {
    if (this.root === node) {
      return this;
    }
    this.isDirty = true;
    this.root?._setLayerManager();
    this.root = node;
    if (node) {
      node.visible = true;
      node._setLayerManager(this.layersManager);
    }
    return this;
  }
  attachNode(node) {
    this.appendChild(node);
    return () => this.removeChild(node);
  }
  appendChild(node) {
    this.root?.appendChild(node);
    return this;
  }
  removeChild(node) {
    this.root?.removeChild(node);
    return this;
  }
  download(fileName, fileFormat) {
    downloadUrl(this.canvas.toDataURL(fileFormat), fileName?.trim() ?? "image");
  }
  /** NOTE: Integrated Charts undocumented image download method. */
  getDataURL(fileFormat) {
    return this.canvas.toDataURL(fileFormat);
  }
  resize(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    if (width > 0 && height > 0 && (width !== this.width || height !== this.height)) {
      this.pendingSize = [width, height];
      this.isDirty = true;
      return true;
    }
    return false;
  }
  async render(opts) {
    const { debugSplitTimes = { start: performance.now() }, extraDebugStats, seriesRect } = opts ?? {};
    const { canvas, canvas: { context: ctx } = {}, root, pendingSize } = this;
    if (!ctx) {
      return;
    }
    const renderStartTime = performance.now();
    if (pendingSize) {
      this.layersManager.resize(...pendingSize);
      this.pendingSize = null;
    }
    if (root && !root.visible) {
      this.isDirty = false;
      return;
    }
    if (root && !this.isDirty) {
      if (this.debug.check()) {
        this.debug("Scene.render() - no-op", {
          redrawType: RedrawType[root.dirty],
          tree: buildTree(root, "console")
        });
      }
      debugStats(this.layersManager, debugSplitTimes, ctx, void 0, extraDebugStats, seriesRect);
      return;
    }
    const renderCtx = {
      ctx,
      devicePixelRatio: this.canvas.pixelRatio ?? 1,
      forceRender: true,
      resized: Boolean(pendingSize),
      debugNodes: {}
    };
    if (Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */)) {
      renderCtx.stats = { layersRendered: 0, layersSkipped: 0, nodesRendered: 0, nodesSkipped: 0 };
    }
    prepareSceneNodeHighlight(renderCtx);
    let canvasCleared = false;
    if (!root || root.dirty >= 1 /* TRIVIAL */) {
      canvasCleared = true;
      canvas.clear();
    }
    if (root && Debug.check("scene:dirtyTree" /* SCENE_DIRTY_TREE */)) {
      const { dirtyTree, paths } = buildDirtyTree(root);
      Debug.create("scene:dirtyTree" /* SCENE_DIRTY_TREE */)("Scene.render() - dirtyTree", { dirtyTree, paths });
    }
    if (root && canvasCleared) {
      if (root.visible) {
        root.preRender();
      }
      if (this.debug.check()) {
        const tree = buildTree(root, "console");
        this.debug("Scene.render() - before", {
          redrawType: RedrawType[root.dirty],
          canvasCleared,
          tree
        });
      }
      if (root.visible) {
        ctx.save();
        root.render(renderCtx);
        ctx.restore();
      }
    }
    debugSplitTimes["\u270D\uFE0F"] = performance.now() - renderStartTime;
    if (this.layersManager.size && canvasCleared) {
      const layerRenderStart = performance.now();
      ctx.save();
      ctx.resetTransform();
      this.layersManager.forEach((layer) => {
        if (layer.canvas.enabled && layer.getVisibility()) {
          ctx.globalAlpha = layer.getComputedOpacity();
          layer.canvas.drawImage(ctx);
        }
      });
      ctx.restore();
      debugSplitTimes["\u26D9"] = performance.now() - layerRenderStart;
    }
    ctx.verifyDepthZero?.();
    this.isDirty = false;
    debugStats(this.layersManager, debugSplitTimes, ctx, renderCtx.stats, extraDebugStats, seriesRect);
    debugSceneNodeHighlight(ctx, renderCtx.debugNodes);
    if (root && this.debug.check()) {
      this.debug("Scene.render() - after", {
        redrawType: RedrawType[root.dirty],
        tree: buildTree(root, "console"),
        canvasCleared
      });
    }
  }
  toSVG() {
    const svg = this.root?.toSVG();
    if (svg == null)
      return;
    const root = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    root.setAttribute("width", String(this.width));
    root.setAttribute("height", String(this.height));
    if (svg.defs != null) {
      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      defs.append(...svg.defs);
      root.append(defs);
    }
    root.append(...svg.elements);
    return root.outerHTML;
  }
  /** Alternative to destroy() that preserves re-usable resources. */
  strip() {
    const { context, pixelRatio } = this.canvas;
    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    this.layersManager.clear();
    this.setRoot(null);
    this.isDirty = false;
  }
  destroy() {
    this.strip();
    this.canvas.destroy();
    Object.assign(this, { canvas: void 0 });
  }
};
Scene.className = "Scene";

// packages/ag-charts-community/src/util/callbackCache.ts
var CallbackCache = class {
  constructor() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
  call(fn, ...params) {
    let serialisedParams;
    let paramCache = this.cache.get(fn);
    try {
      serialisedParams = JSON.stringify(params);
    } catch (e) {
      return this.invoke(fn, params, paramCache);
    }
    if (paramCache == null) {
      paramCache = /* @__PURE__ */ new Map();
      this.cache.set(fn, paramCache);
    }
    if (!paramCache.has(serialisedParams)) {
      return this.invoke(fn, params, paramCache, serialisedParams);
    }
    return paramCache.get(serialisedParams);
  }
  invoke(fn, params, paramCache, serialisedParams) {
    try {
      const result = fn(...params);
      if (paramCache && serialisedParams != null) {
        paramCache.set(serialisedParams, result);
      }
      return result;
    } catch (e) {
      Logger.warnOnce(`User callback errored, ignoring`, e);
      return;
    }
  }
  invalidateCache() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
};

// packages/ag-charts-community/src/chart/annotation/annotationManager.ts
var AnnotationManager = class extends BaseManager {
  constructor(annotationRoot) {
    super();
    this.annotationRoot = annotationRoot;
    this.mementoOriginatorKey = "annotations";
    this.annotations = [];
  }
  createMemento() {
    return this.annotations;
  }
  guardMemento(blob) {
    return isArray(blob);
  }
  restoreMemento(_version, _mementoVersion, memento) {
    this.annotations = this.cleanData(memento).map((annotation) => {
      const annotationTheme = this.getAnnotationTypeStyles(annotation.type);
      return mergeDefaults(annotation, annotationTheme);
    });
    this.listeners.dispatch("restore-annotations", {
      type: "restore-annotations",
      annotations: this.annotations
    });
  }
  updateData(annotations2) {
    this.annotations = this.cleanData(annotations2 ?? []);
  }
  attachNode(node) {
    this.annotationRoot.append(node);
    return () => {
      this.annotationRoot?.removeChild(node);
      return this;
    };
  }
  setAnnotationStyles(styles) {
    this.styles = styles;
  }
  getAnnotationTypeStyles(type) {
    return this.styles?.[type];
  }
  cleanData(annotations2) {
    for (const annotation of annotations2) {
      if ("textAlign" in annotation)
        delete annotation.textAlign;
    }
    return annotations2;
  }
};

// packages/ag-charts-community/src/chart/axis/axisManager.ts
var AxisManager = class {
  constructor(sceneRoot) {
    this.sceneRoot = sceneRoot;
    this.axes = /* @__PURE__ */ new Map();
    this.axisGridGroup = new Layer({ name: "Axes-Grids", zIndex: 1 /* AXIS_GRID */ });
    this.axisGroup = new Layer({ name: "Axes", zIndex: 2 /* AXIS */ });
    this.sceneRoot.appendChild(this.axisGroup);
    this.sceneRoot.appendChild(this.axisGridGroup);
  }
  updateAxes(oldAxes, newAxes) {
    for (const axis of oldAxes) {
      if (newAxes.includes(axis))
        continue;
      axis.detachAxis(this.axisGroup, this.axisGridGroup);
      axis.destroy();
    }
    for (const axis of newAxes) {
      if (oldAxes?.includes(axis))
        continue;
      axis.attachAxis(this.axisGroup, this.axisGridGroup);
    }
    this.axes.clear();
    for (const axis of newAxes) {
      const ctx = axis.createAxisContext();
      if (this.axes.has(ctx.direction)) {
        this.axes.get(ctx.direction)?.push(ctx);
      } else {
        this.axes.set(ctx.direction, [ctx]);
      }
    }
  }
  getAxisContext(direction) {
    return this.axes.get(direction) ?? [];
  }
  destroy() {
    this.axes.clear();
    this.sceneRoot.removeChild(this.axisGroup);
    this.sceneRoot.removeChild(this.axisGridGroup);
  }
};

// packages/ag-charts-community/src/chart/data/dataService.ts
var DataService = class extends Listeners {
  constructor(animationManager) {
    super();
    this.animationManager = animationManager;
    this.dispatchOnlyLatest = true;
    this.dispatchThrottle = 0;
    this.requestThrottle = 300;
    this.isLoadingInitialData = false;
    this.isLoadingData = false;
    this.freshRequests = [];
    this.requestCounter = 0;
    this.debug = Debug.create(true, "data-model", "data-source");
    this.throttledFetch = this.createThrottledFetch(this.requestThrottle);
    this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);
  }
  updateCallback(dataSourceCallback) {
    if (typeof dataSourceCallback !== "function")
      return;
    this.debug("DataService - updated data source callback");
    this.dataSourceCallback = dataSourceCallback;
    this.isLoadingInitialData = true;
    this.animationManager.skip();
    this.dispatch("data-source-change");
  }
  clearCallback() {
    this.dataSourceCallback = void 0;
  }
  load(params) {
    this.isLoadingData = true;
    this.throttledFetch(params);
  }
  isLazy() {
    return this.dataSourceCallback != null;
  }
  isLoading() {
    return this.isLazy() && (this.isLoadingInitialData || this.isLoadingData);
  }
  createThrottledFetch(requestThrottle) {
    return throttle((params) => this.fetch(params), requestThrottle, {
      leading: false,
      trailing: true
    });
  }
  createThrottledDispatch(dispatchThrottle) {
    return throttle(
      (id, data) => {
        this.debug(`DataService - dispatching 'data-load' | ${id}`);
        this.dispatch("data-load", { type: "data-load", data });
      },
      dispatchThrottle,
      {
        leading: true,
        trailing: true
      }
    );
  }
  async fetch(params) {
    if (!this.dataSourceCallback) {
      throw new Error("DataService - [dataSource.getData] callback not initialised");
    }
    const start = performance.now();
    const id = this.requestCounter++;
    this.debug(`DataService - requesting | ${id}`);
    this.freshRequests.push(id);
    let response;
    try {
      response = await this.dataSourceCallback(params);
      this.debug(`DataService - response | ${performance.now() - start}ms | ${id}`);
    } catch (error) {
      this.debug(`DataService - request failed | ${id}`);
      Logger.errorOnce(`DataService - request failed | [${error}]`);
    }
    this.isLoadingInitialData = false;
    const requestIndex = this.freshRequests.findIndex((rid) => rid === id);
    if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {
      this.debug(`DataService - discarding stale request | ${id}`);
      return;
    }
    this.freshRequests = this.freshRequests.slice(requestIndex + 1);
    if (this.freshRequests.length === 0) {
      this.isLoadingData = false;
    }
    if (Array.isArray(response)) {
      this.throttledDispatch(id, response);
    } else {
      this.dispatch("data-error");
    }
  }
};
__decorateClass([
  ActionOnSet({
    newValue(dispatchThrottle) {
      this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);
    }
  })
], DataService.prototype, "dispatchThrottle", 2);
__decorateClass([
  ActionOnSet({
    newValue(requestThrottle) {
      this.throttledFetch = this.createThrottledFetch(requestThrottle);
    }
  })
], DataService.prototype, "requestThrottle", 2);

// packages/ag-charts-community/src/chart/interaction/animationBatch.ts
var AnimationBatch = class {
  constructor(maxAnimationTime) {
    this.maxAnimationTime = maxAnimationTime;
    this.debug = Debug.create(true, "animation");
    this.controllers = /* @__PURE__ */ new Map();
    this.stoppedCbs = /* @__PURE__ */ new Set();
    this.currentPhase = 0;
    this.phases = new Map(PHASE_ORDER.map((p) => [p, []]));
    this.skipAnimations = false;
    this.animationTimeConsumed = 0;
    /** Guard against premature animation execution. */
    this.isReady = false;
  }
  get size() {
    return this.controllers.size;
  }
  get consumedTimeMs() {
    return this.animationTimeConsumed;
  }
  isActive() {
    return this.controllers.size > 0;
  }
  getActiveControllers() {
    return this.phases.get(PHASE_ORDER[this.currentPhase]) ?? [];
  }
  checkOverlappingId(id) {
    if (id != null && this.controllers.has(id)) {
      this.controllers.get(id).stop();
      this.debug(`Skipping animation batch due to update of existing animation: ${id}`);
      this.skip();
    }
  }
  addAnimation(animation) {
    if (animation.isComplete)
      return;
    const animationPhaseIdx = PHASE_ORDER.indexOf(animation.phase);
    if (animationPhaseIdx < this.currentPhase) {
      this.debug(`Skipping animation due to being for an earlier phase`, animation.id);
      animation.stop();
      return;
    }
    this.controllers.set(animation.id, animation);
    this.phases.get(animation.phase)?.push(animation);
  }
  removeAnimation(animation) {
    this.controllers.delete(animation.id);
    const phase = this.phases.get(animation.phase);
    const index = phase?.indexOf(animation);
    if (index != null && index >= 0) {
      phase?.splice(index, 1);
    }
  }
  progress(deltaTime) {
    if (!this.isReady)
      return;
    let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;
    const refresh = () => {
      const phase2 = PHASE_ORDER[this.currentPhase];
      return {
        phaseControllers: [...this.getActiveControllers()],
        phase: phase2,
        phaseMeta: PHASE_METADATA[phase2]
      };
    };
    let { phase, phaseControllers, phaseMeta } = refresh();
    const arePhasesComplete = () => PHASE_ORDER[this.currentPhase] == null;
    const progressPhase = () => {
      ({ phase, phaseControllers, phaseMeta } = refresh());
      while (!arePhasesComplete() && phaseControllers.length === 0) {
        this.currentPhase++;
        ({ phase, phaseControllers, phaseMeta } = refresh());
        this.debug(`AnimationBatch - phase changing to ${phase}`, { unusedTime }, phaseControllers);
      }
    };
    const total = this.controllers.size;
    this.debug(`AnimationBatch - ${deltaTime}ms; phase ${phase} with ${phaseControllers?.length} of ${total}`);
    do {
      const phaseDeltaTime = unusedTime;
      const skipPhase = phaseMeta.skipIfNoEarlierAnimations && this.animationTimeConsumed === 0;
      let completeCount = 0;
      for (const controller of phaseControllers) {
        if (skipPhase) {
          controller.stop();
        } else {
          unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);
        }
        if (controller.isComplete) {
          completeCount++;
          this.removeAnimation(controller);
        }
      }
      this.animationTimeConsumed += phaseDeltaTime - unusedTime;
      this.debug(`AnimationBatch - updated ${phaseControllers.length} controllers; ${completeCount} completed`);
      this.debug(`AnimationBatch - animationTimeConsumed: ${this.animationTimeConsumed}`);
      progressPhase();
    } while (unusedTime > 0 && !arePhasesComplete());
    if (this.animationTimeConsumed > this.maxAnimationTime) {
      this.debug(`Animation batch exceeded max animation time, skipping`, [...this.controllers]);
      this.stop();
    }
  }
  ready() {
    if (this.isReady)
      return;
    this.isReady = true;
    this.debug(`AnimationBatch - ready; skipped: ${this.skipAnimations}`, [...this.controllers]);
    let skipAll = true;
    for (const [, controller] of this.controllers) {
      if (controller.duration > 0 && PHASE_METADATA[controller.phase].skipIfNoEarlierAnimations !== true) {
        skipAll = false;
        break;
      }
    }
    if (!skipAll) {
      for (const [, controller] of this.controllers) {
        if (controller.autoplay) {
          controller.play(true);
        }
      }
    }
  }
  skip(skip = true) {
    if (this.skipAnimations === false && skip === true) {
      for (const controller of this.controllers.values()) {
        controller.stop();
      }
      this.controllers.clear();
    }
    this.skipAnimations = skip;
  }
  play() {
    for (const controller of this.controllers.values()) {
      controller.play();
    }
  }
  pause() {
    for (const controller of this.controllers.values()) {
      controller.pause();
    }
  }
  stop() {
    for (const controller of this.controllers.values()) {
      try {
        controller.stop();
        this.removeAnimation(controller);
      } catch (error) {
        Logger.error("Error during animation stop", error);
      }
    }
    this.dispatchStopped();
  }
  stopByAnimationId(id) {
    if (id != null && this.controllers.has(id)) {
      const controller = this.controllers.get(id);
      if (controller) {
        controller.stop();
        this.removeAnimation(controller);
      }
    }
  }
  stopByAnimationGroupId(id) {
    for (const controller of this.controllers.values()) {
      if (controller.groupId === id) {
        this.stopByAnimationId(controller.id);
      }
    }
  }
  dispatchStopped() {
    this.stoppedCbs.forEach((cb) => cb());
    this.stoppedCbs.clear();
  }
  isSkipped() {
    return this.skipAnimations;
  }
  destroy() {
    this.stop();
    this.controllers.clear();
  }
};

// packages/ag-charts-community/src/chart/interaction/preventableEvent.ts
function buildPreventable(obj) {
  const self = {
    ...obj,
    preventDefault() {
      self.sourceEvent?.preventDefault();
    }
  };
  return self;
}
function dispatchTypedEvent(listeners, event) {
  listeners.dispatchWrapHandlers(event.type, (handler, e) => handler(e), buildPreventable(event));
}

// packages/ag-charts-community/src/chart/interaction/interactionManager.ts
var DRAG_INTERACTION_TYPES = ["drag-start", "drag", "drag-end"];
var POINTER_INTERACTION_TYPES = [
  ...DRAG_INTERACTION_TYPES,
  "click",
  "dblclick",
  "contextmenu",
  "hover",
  "leave",
  "enter",
  "page-left",
  "wheel"
];
var FOCUS_INTERACTION_TYPES = ["blur", "focus"];
var KEY_INTERACTION_TYPES = ["keydown", "keyup"];
var SHADOW_DOM_HANDLERS = ["mousemove", "mouseup"];
var WINDOW_EVENT_HANDLERS = ["pagehide", "mousemove", "mouseup"];
var EVENT_HANDLERS = [
  "dblclick",
  "contextmenu",
  "mousedown",
  "mouseleave",
  "mouseenter",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "wheel",
  "blur",
  "focus",
  "keydown",
  "keyup"
];
function isPointerEvent(type) {
  return POINTER_INTERACTION_TYPES.includes(type);
}
function isFocusEvent(type) {
  return FOCUS_INTERACTION_TYPES.includes(type);
}
function isKeyEvent(type) {
  return KEY_INTERACTION_TYPES.includes(type);
}
var _InteractionManager = class _InteractionManager extends InteractionStateListener {
  constructor(keyboardOptions, domManager) {
    super();
    this.keyboardOptions = keyboardOptions;
    this.domManager = domManager;
    this.debug = Debug.create(true, "interaction");
    this.eventHandler = (event) => this.processEvent(event);
    this.mouseDown = false;
    this.touchDown = false;
    this.clickHistory = [{ offsetX: NaN, offsetY: NaN, type: "mousedown" }];
    this.dblclickHistory = [
      { offsetX: NaN, offsetY: NaN, type: "mousedown" },
      { offsetX: NaN, offsetY: NaN, type: "mouseup" },
      { offsetX: NaN, offsetY: NaN, type: "mousedown" }
    ];
    this.stateQueue = 32 /* Default */ | 2 /* Animation */;
    this.rootElement = this.domManager.getShadowDocumentRoot();
    for (const type of EVENT_HANDLERS) {
      if (type.startsWith("touch") || type === "wheel") {
        this.domManager.addEventListener(type, this.eventHandler, { passive: false });
      } else {
        this.domManager.addEventListener(type, this.eventHandler);
      }
    }
    for (const type of WINDOW_EVENT_HANDLERS) {
      getWindow().addEventListener(type, this.eventHandler);
    }
    this.containerChanged(true);
    this.domManager.addListener("container-changed", () => this.containerChanged());
  }
  containerChanged(force = false) {
    const newRoot = this.domManager.getShadowDocumentRoot();
    if (!force && newRoot === this.rootElement)
      return;
    for (const type of SHADOW_DOM_HANDLERS) {
      this.rootElement?.removeEventListener(type, this.eventHandler);
    }
    this.rootElement = newRoot;
    this.debug("[InteractionManager] Switching rootElement to:", this.rootElement);
    for (const type of SHADOW_DOM_HANDLERS) {
      this.rootElement?.addEventListener(type, this.eventHandler);
    }
  }
  destroy() {
    super.destroy();
    for (const type of WINDOW_EVENT_HANDLERS) {
      getWindow().removeEventListener(type, this.eventHandler);
    }
    for (const type of SHADOW_DOM_HANDLERS) {
      this.rootElement?.removeEventListener(type, this.eventHandler);
    }
    for (const type of EVENT_HANDLERS) {
      this.domManager.removeEventListener(type, this.eventHandler);
    }
    this.domManager.removeStyles("interactionManager");
  }
  pushState(state) {
    this.stateQueue |= state;
  }
  popState(state) {
    this.stateQueue &= ~state;
  }
  getState() {
    return this.stateQueue & -this.stateQueue;
  }
  processEvent(event) {
    this.debug("Received raw event", event);
    let types = this.decideInteractionEventTypes(event);
    if (types != null && !Array.isArray(types)) {
      types = [types];
    }
    for (const type of types ?? []) {
      this.dispatchEvent(event, type).catch((e) => Logger.errorOnce(e));
    }
  }
  async dispatchEvent(event, type) {
    if (isPointerEvent(type)) {
      this.dispatchPointerEvent(event, type);
      return;
    }
    const { relatedElement, targetElement } = this.extractElements(event);
    if (isFocusEvent(type)) {
      const sourceEvent = event;
      this.dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });
    } else if (isKeyEvent(type)) {
      const sourceEvent = event;
      this.dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });
    }
  }
  dispatchTypedEvent(listeners, event) {
    const preventableEvent = buildPreventable(event);
    this.debug("Dispatching typed event", preventableEvent, this.getState());
    listeners.dispatchWrapHandlers(event.type, (handler, e) => handler(e), preventableEvent);
  }
  extractElements(event) {
    let relatedElement;
    let targetElement;
    if ("relatedTarget" in event && event["relatedTarget"] instanceof HTMLElement) {
      relatedElement = event["relatedTarget"];
    }
    if ("target" in event && event["target"] instanceof HTMLElement) {
      targetElement = event["target"];
    }
    return { relatedElement, targetElement };
  }
  dispatchPointerEvent(event, type) {
    const coords = this.calculateCoordinates(event);
    if (coords == null)
      return;
    const pointerEvent = this.buildPointerEvent({ type, event, ...coords });
    this.debug("Dispatching pointer event", pointerEvent, this.getState());
    dispatchTypedEvent(this.listeners, pointerEvent);
  }
  getEventHTMLTarget(event) {
    if (event.target instanceof HTMLElement) {
      return event.target;
    } else if (event.currentTarget instanceof HTMLElement) {
      return event.currentTarget;
    }
    return void 0;
  }
  recordDown(event) {
    if (event instanceof MouseEvent) {
      partialAssign(["offsetX", "offsetY"], this.clickHistory[0], event);
      partialAssign(["offsetX", "offsetY"], this.dblclickHistory[2], this.dblclickHistory[0]);
      partialAssign(["offsetX", "offsetY"], this.dblclickHistory[0], event);
    }
    this.dragPreStartElement = this.getEventHTMLTarget(event);
  }
  recordUp(event) {
    if (event instanceof MouseEvent) {
      partialAssign(["offsetX", "offsetY"], this.dblclickHistory[1], event);
    }
    this.dragPreStartElement = void 0;
    if (this.dragStartElement) {
      this.dragStartElement = void 0;
      return true;
    }
    return false;
  }
  decideInteractionEventTypes(event) {
    const dragStart = "drag-start";
    switch (event.type) {
      case "blur":
      case "focus":
      case "keydown":
      case "keyup":
        return this.keyboardOptions.enabled ? event.type : void 0;
      case "dblclick":
        return event.type;
      case "contextmenu":
      case "wheel":
        return event.type;
      case "mousedown":
        if (!this.isEventOverElement(event)) {
          return;
        }
        this.mouseDown = true;
        this.recordDown(event);
        return;
      case "touchstart":
        if (!this.isEventOverElement(event)) {
          return;
        }
        this.touchDown = true;
        this.recordDown(event);
        return;
      case "touchmove":
      case "mousemove":
        if (!this.mouseDown && !this.touchDown && !this.isEventOverElement(event)) {
          return;
        }
        if (!this.mouseDown && !this.touchDown)
          return "hover";
        if (this.dragStartElement)
          return "drag";
        this.dragStartElement = this.dragPreStartElement;
        this.dragPreStartElement = void 0;
        return [dragStart, "drag"];
      case "mouseup":
        if (!this.mouseDown && !this.isEventOverElement(event)) {
          return;
        }
        this.mouseDown = false;
        return this.recordUp(event) ? "drag-end" : "click";
      case "touchend":
        if (!this.touchDown && !this.isEventOverElement(event)) {
          return;
        }
        this.touchDown = false;
        return this.recordUp(event) ? "drag-end" : "click";
      case "mouseleave":
      case "touchcancel":
        return "leave";
      case "mouseenter":
        return "enter";
      case "pagehide":
        return "page-left";
    }
  }
  isEventOverElement(event) {
    return this.domManager.isEventOverElement(event);
  }
  calculateCoordinates(event) {
    if (event instanceof MouseEvent) {
      return this.getMouseEventCoords(event);
    } else if (typeof TouchEvent !== "undefined" && event instanceof TouchEvent) {
      const lastTouch = event.touches[0] ?? event.changedTouches[0];
      const { clientX, clientY, pageX, pageY } = lastTouch;
      return { ..._InteractionManager.NULL_COORDS, clientX, clientY, pageX, pageY };
    } else if (event instanceof PageTransitionEvent) {
      if (event.persisted) {
        return;
      }
      return _InteractionManager.NULL_COORDS;
    }
  }
  getMouseEventCoords(event) {
    const { clientX, clientY, pageX, pageY } = event;
    let { offsetX, offsetY } = event;
    const target = this.getEventHTMLTarget(event);
    const { x = 0, y = 0 } = target ? this.domManager.calculateCanvasPosition(target) : {};
    if (this.dragStartElement != null && event.target !== this.dragStartElement) {
      const offsetDragStart = this.domManager.calculateCanvasPosition(this.dragStartElement);
      offsetX -= offsetDragStart.x - x;
      offsetY -= offsetDragStart.y - y;
    } else {
      offsetX += x;
      offsetY += y;
    }
    return { clientX, clientY, pageX, pageY, offsetX, offsetY };
  }
  isWheelEvent(event) {
    return event.type === "wheel";
  }
  buildPointerEvent(opts) {
    const { type, event, clientX, clientY } = opts;
    let { offsetX, offsetY, pageX, pageY } = opts;
    if (!isFiniteNumber(offsetX) || !isFiniteNumber(offsetY)) {
      const rect = this.domManager.getBoundingClientRect();
      offsetX = clientX - rect.left;
      offsetY = clientY - rect.top;
    }
    if (!isFiniteNumber(pageX) || !isFiniteNumber(pageY)) {
      const pageRect = this.rootElement?.getBoundingClientRect();
      pageX = clientX - (pageRect?.left ?? 0);
      pageY = clientY - (pageRect?.top ?? 0);
    }
    let [deltaX, deltaY] = [NaN, NaN];
    if (this.isWheelEvent(event)) {
      const factor = event.deltaMode === 0 ? 0.01 : 1;
      deltaX = event.deltaX * factor;
      deltaY = event.deltaY * factor;
    }
    let pointerHistory = [];
    if (event.type === "click") {
      pointerHistory = this.clickHistory;
    } else if (event.type === "dblclick") {
      pointerHistory = this.dblclickHistory;
    }
    const { relatedElement, targetElement } = this.extractElements(event);
    const button = "button" in event ? Number(event.button) : 0;
    const builtEvent = {
      type,
      offsetX,
      offsetY,
      pageX,
      pageY,
      deltaX,
      deltaY,
      button,
      pointerHistory,
      sourceEvent: event,
      relatedElement,
      targetElement
    };
    this.debug("InteractionManager - builtEvent: ", builtEvent, this.getState());
    return builtEvent;
  }
};
_InteractionManager.NULL_COORDS = {
  clientX: -Infinity,
  clientY: -Infinity,
  pageX: -Infinity,
  pageY: -Infinity,
  offsetX: -Infinity,
  offsetY: -Infinity
};
var InteractionManager = _InteractionManager;

// packages/ag-charts-community/src/chart/interaction/animationManager.ts
function validAnimationDuration(testee) {
  if (testee == null)
    return true;
  return !isNaN(testee) && testee >= 0 && testee <= 2;
}
var AnimationManager = class {
  constructor(interactionManager, chartUpdateMutex) {
    this.interactionManager = interactionManager;
    this.chartUpdateMutex = chartUpdateMutex;
    this.defaultDuration = 1e3;
    this.batch = new AnimationBatch(this.defaultDuration * 1.5);
    this.debug = Debug.create(true, "animation");
    this.events = new EventEmitter();
    this.rafAvailable = typeof requestAnimationFrame !== "undefined";
    this.isPlaying = true;
    this.requestId = null;
    this.skipAnimations = true;
    this.currentAnonymousAnimationId = 0;
  }
  addListener(eventName, listener) {
    return this.events.on(eventName, listener);
  }
  /**
   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists
   * with the same `id`, immediately stop it.
   */
  animate(opts) {
    const batch = this.batch;
    try {
      batch.checkOverlappingId(opts.id);
    } catch (error) {
      this.failsafeOnError(error);
      return;
    }
    let { id } = opts;
    if (id == null) {
      id = `__${this.currentAnonymousAnimationId}`;
      this.currentAnonymousAnimationId += 1;
    }
    const skip = this.isSkipped() || opts.phase === "none";
    if (skip) {
      this.debug("AnimationManager - skipping animation");
    }
    const { delay, duration } = opts;
    if (!validAnimationDuration(delay)) {
      throw new Error(`Animation delay of ${delay} is unsupported (${id})`);
    }
    if (!validAnimationDuration(duration)) {
      throw new Error(`Animation duration of ${duration} is unsupported (${id})`);
    }
    const animation = new Animation({
      ...opts,
      id,
      skip,
      autoplay: this.isPlaying ? opts.autoplay : false,
      phase: opts.phase,
      defaultDuration: this.defaultDuration
    });
    if (this.forceTimeJump(animation, this.defaultDuration)) {
      return;
    }
    this.batch.addAnimation(animation);
    return animation;
  }
  play() {
    if (this.isPlaying) {
      return;
    }
    this.isPlaying = true;
    this.debug("AnimationManager.play()");
    try {
      this.batch.play();
    } catch (error) {
      this.failsafeOnError(error);
    }
    this.requestAnimation();
  }
  pause() {
    if (!this.isPlaying) {
      return;
    }
    this.isPlaying = false;
    this.cancelAnimation();
    this.debug("AnimationManager.pause()");
    try {
      this.batch.pause();
    } catch (error) {
      this.failsafeOnError(error);
    }
  }
  stop() {
    this.isPlaying = false;
    this.cancelAnimation();
    this.debug("AnimationManager.stop()");
    this.batch.stop();
  }
  stopByAnimationId(id) {
    try {
      this.batch.stopByAnimationId(id);
    } catch (error) {
      this.failsafeOnError(error);
    }
  }
  stopByAnimationGroupId(id) {
    try {
      this.batch.stopByAnimationGroupId(id);
    } catch (error) {
      this.failsafeOnError(error);
    }
  }
  reset() {
    if (this.isPlaying) {
      this.stop();
      this.play();
    } else {
      this.stop();
    }
  }
  skip(skip = true) {
    this.skipAnimations = skip;
  }
  isSkipped() {
    return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();
  }
  isActive() {
    return this.isPlaying && this.batch.isActive();
  }
  skipCurrentBatch() {
    if (this.debug.check()) {
      this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });
    }
    this.batch.skip();
  }
  /** Mocking point for tests to guarantee that animation updates happen. */
  isSkippingFrames() {
    return true;
  }
  /** Mocking point for tests to capture requestAnimationFrame callbacks. */
  scheduleAnimationFrame(cb) {
    this.requestId = getWindow().requestAnimationFrame(cb);
  }
  /** Mocking point for tests to skip animations to a specific point in time. */
  forceTimeJump(_animation, _defaultDuration) {
    return false;
  }
  requestAnimation() {
    if (!this.rafAvailable)
      return;
    if (!this.batch.isActive() || this.requestId !== null)
      return;
    let prevTime;
    const onAnimationFrame = async (time2) => {
      const executeAnimationFrame = async () => {
        const deltaTime = time2 - (prevTime ?? time2);
        prevTime = time2;
        this.debug("AnimationManager - onAnimationFrame()", {
          controllersCount: this.batch.size,
          deltaTime
        });
        this.interactionManager.pushState(2 /* Animation */);
        try {
          this.batch.progress(deltaTime);
        } catch (error) {
          this.failsafeOnError(error);
        }
        this.events.emit("animation-frame", {
          type: "animation-frame",
          deltaMs: deltaTime
        });
      };
      if (this.isSkippingFrames()) {
        await this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);
      } else {
        await this.chartUpdateMutex.acquire(executeAnimationFrame);
      }
      if (this.batch.isActive()) {
        this.scheduleAnimationFrame(onAnimationFrame);
      } else {
        this.batch.stop();
        this.events.emit("animation-stop", {
          type: "animation-stop",
          deltaMs: this.batch.consumedTimeMs
        });
      }
    };
    this.events.emit("animation-start", {
      type: "animation-start",
      deltaMs: 0
    });
    this.scheduleAnimationFrame(onAnimationFrame);
  }
  cancelAnimation() {
    if (this.requestId === null)
      return;
    cancelAnimationFrame(this.requestId);
    this.requestId = null;
    this.startBatch();
  }
  failsafeOnError(error, cancelAnimation = true) {
    Logger.error("Error during animation, skipping animations", error);
    if (cancelAnimation) {
      this.cancelAnimation();
    }
  }
  startBatch(skipAnimations) {
    this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);
    this.reset();
    this.batch.destroy();
    this.batch = new AnimationBatch(this.defaultDuration * 1.5);
    if (skipAnimations === true) {
      this.batch.skip();
    }
  }
  endBatch() {
    if (this.batch.isActive()) {
      this.batch.ready();
      this.requestAnimation();
    } else {
      this.interactionManager.popState(2 /* Animation */);
      if (this.batch.isSkipped()) {
        this.batch.skip(false);
      }
    }
  }
  onBatchStop(cb) {
    this.batch.stoppedCbs.add(cb);
  }
  destroy() {
    this.stop();
    this.events.clear();
  }
};

// packages/ag-charts-community/src/chart/interaction/chartEventManager.ts
var ChartEventManager = class extends BaseManager {
  legendItemClick(series, itemId, enabled, legendItemName) {
    const event = {
      type: "legend-item-click",
      series,
      itemId,
      enabled,
      legendItemName
    };
    this.listeners.dispatch("legend-item-click", event);
  }
  legendItemDoubleClick(series, itemId, enabled, numVisibleItems, legendItemName) {
    const event = {
      type: "legend-item-double-click",
      series,
      itemId,
      enabled,
      legendItemName,
      numVisibleItems
    };
    this.listeners.dispatch("legend-item-double-click", event);
  }
  axisHover(axisId, direction) {
    const event = {
      type: "axis-hover",
      axisId,
      direction
    };
    this.listeners.dispatch("axis-hover", event);
  }
};

// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts
var ContextMenuRegistry = class _ContextMenuRegistry {
  constructor(regionManager) {
    this.defaultActions = [];
    this.disabledActions = /* @__PURE__ */ new Set();
    this.hiddenActions = /* @__PURE__ */ new Set();
    this.listeners = new Listeners();
    const { Default: Default2, ContextMenu } = InteractionState;
    this.destroyFns = [regionManager.listenAll("contextmenu", (e) => this.onContextMenu(e), Default2 | ContextMenu)];
  }
  destroy() {
    this.destroyFns.forEach((d) => d());
  }
  onContextMenu(event) {
    const type = _ContextMenuRegistry.toContextType(event.region);
    if (type === "all") {
      this.dispatchContext("all", event, {});
    }
  }
  static toContextType(region) {
    if (region === "legend" || region === "series") {
      return region;
    }
    return "all";
  }
  static check(type, event) {
    return event.type === type;
  }
  static checkCallback(desiredType, type, _callback) {
    return desiredType === type;
  }
  dispatchContext(type, pointerEvent, context, position) {
    const { sourceEvent } = pointerEvent;
    const x = position?.x ?? pointerEvent.offsetX;
    const y = position?.y ?? pointerEvent.offsetY;
    sourceEvent.stopPropagation();
    this.listeners.dispatch("", buildPreventable({ type, x, y, context, sourceEvent }));
  }
  addListener(handler) {
    return this.listeners.addListener("", handler);
  }
  filterActions(type) {
    return this.defaultActions.filter((action) => {
      return action.id && !this.hiddenActions.has(action.id) && ["all", type].includes(action.type);
    });
  }
  registerDefaultAction(action) {
    const didAdd = action.id != null && !this.defaultActions.some(({ id }) => id === action.id);
    if (didAdd) {
      this.defaultActions.push(action);
    }
    return () => {
      const index = didAdd ? this.defaultActions.findIndex(({ id }) => id === action.id) : -1;
      if (index !== -1) {
        this.defaultActions.splice(index, 1);
      }
    };
  }
  enableAction(actionId) {
    this.disabledActions.delete(actionId);
  }
  disableAction(actionId) {
    this.disabledActions.add(actionId);
  }
  showAction(actionId) {
    this.hiddenActions.add(actionId);
  }
  hideAction(actionId) {
    this.hiddenActions.delete(actionId);
  }
  isDisabled(actionId) {
    return this.disabledActions.has(actionId);
  }
};

// packages/ag-charts-community/src/util/stateTracker.ts
var StateTracker = class extends Map {
  constructor(defaultValue, defaultState) {
    super();
    this.defaultValue = defaultValue;
    this.defaultState = defaultState;
  }
  set(key, value) {
    this.delete(key);
    if (typeof value !== "undefined") {
      super.set(key, value);
    }
    return this;
  }
  stateId() {
    return Array.from(this.keys()).pop() ?? this.defaultState;
  }
  stateValue() {
    return Array.from(this.values()).pop() ?? this.defaultValue;
  }
};

// packages/ag-charts-community/src/chart/interaction/cursorManager.ts
var CursorManager = class {
  constructor(domManager) {
    this.domManager = domManager;
    this.stateTracker = new StateTracker("default");
  }
  updateCursor(callerId, style) {
    this.stateTracker.set(callerId, style);
    this.domManager.updateCursor(this.stateTracker.stateValue());
  }
  getCursor() {
    return this.domManager.getCursor();
  }
};

// packages/ag-charts-community/src/chart/interaction/gestureDetector.ts
function distanceSquared(finger1, finger2) {
  const dx = finger1.screenX - finger2.screenX;
  const dy = finger1.screenY - finger2.screenY;
  return dx * dx + dy * dy;
}
function distance(finger1, finger2) {
  return Math.sqrt(distanceSquared(finger1, finger2));
}
var MIN_DISTANCE_TO_START_PINCH = 1;
var GestureDetector = class extends BaseManager {
  constructor(domManager) {
    super();
    this.domManager = domManager;
    this.touchstart = (event) => this.onTouchStart(event);
    this.touchmove = (event) => this.onTouchMove(event);
    this.touchend = (event) => this.onTouchEnd(event);
    this.touchcancel = (event) => this.onTouchCancel(event);
    this.pinch = {
      finger1: { identifier: NaN, screenX: NaN, screenY: NaN },
      finger2: { identifier: NaN, screenX: NaN, screenY: NaN },
      origin: { x: NaN, y: NaN },
      distance: NaN,
      status: 0 /* Off */
    };
    this.domManager.addEventListener("touchstart", this.touchstart, { passive: true });
    this.domManager.addEventListener("touchmove", this.touchmove, { passive: false });
    this.domManager.addEventListener("touchend", this.touchend);
    this.domManager.addEventListener("touchcancel", this.touchcancel);
  }
  destroy() {
    this.domManager.removeEventListener("touchstart", this.touchstart);
    this.domManager.removeEventListener("touchmove", this.touchmove);
    this.domManager.removeEventListener("touchend", this.touchend);
    this.domManager.removeEventListener("touchcancel", this.touchcancel);
  }
  findPinchTouches(moveEvent) {
    const { touches } = moveEvent;
    const { finger1, finger2 } = this.pinch;
    if (this.pinch.status !== 0 /* Off */ && touches.length === 2) {
      if (touches[0].identifier === finger1.identifier && touches[1].identifier === finger2.identifier) {
        return [touches[0], touches[1]];
      }
      if (touches[0].identifier === finger2.identifier && touches[1].identifier === finger1.identifier) {
        return [touches[1], touches[0]];
      }
    }
  }
  copyTouchData(event) {
    const keys = ["identifier", "screenX", "screenY"];
    partialAssign(keys, this.pinch.finger1, event.touches[0]);
    partialAssign(keys, this.pinch.finger2, event.touches[1]);
    this.pinch.distance = distance(this.pinch.finger1, this.pinch.finger2);
  }
  dispatchPinchEvent(type, deltaDistance, sourceEvent) {
    const { finger1, finger2, origin: origin2 } = this.pinch;
    this.listeners.dispatch(type, buildPreventable({ sourceEvent, type, finger1, finger2, deltaDistance, origin: origin2 }));
  }
  onTouchStart(event) {
    this.stopPinchTracking(event);
    const { pinch } = this;
    if (event.touches.length === 2) {
      pinch.status = 1 /* Initialized */;
      this.copyTouchData(event);
      pinch.origin.x = (event.touches[0].clientX + event.touches[1].clientX) / 2;
      pinch.origin.y = (event.touches[0].clientY + event.touches[1].clientY) / 2;
    }
  }
  onTouchMove(event) {
    const pinchTouches = this.findPinchTouches(event);
    if (pinchTouches !== void 0) {
      const [touch1, touch2] = pinchTouches;
      const { pinch } = this;
      const newDistance = distance(touch1, touch2);
      const deltaDistance = newDistance - pinch.distance;
      if (pinch.status === 1 /* Initialized */) {
        if (Math.abs(deltaDistance) > MIN_DISTANCE_TO_START_PINCH) {
          pinch.status = 2 /* Running */;
          this.copyTouchData(event);
          this.dispatchPinchEvent("pinch-start", 0, event);
        }
      } else if (pinch.status === 2 /* Running */) {
        pinch.distance = newDistance;
        this.copyTouchData(event);
        this.dispatchPinchEvent("pinch-move", deltaDistance, event);
      } else {
        Logger.error(`unexpected pinch.status: ${pinch.status}`);
      }
    }
  }
  onTouchEnd(event) {
    this.stopPinchTracking(event);
  }
  onTouchCancel(event) {
    this.stopPinchTracking(event);
  }
  stopPinchTracking(event) {
    const { pinch } = this;
    if (pinch.status === 2 /* Running */) {
      this.dispatchPinchEvent("pinch-end", 0, event);
    }
    this.pinch.status = 0 /* Off */;
  }
};

// packages/ag-charts-community/src/chart/interaction/highlightManager.ts
var HighlightManager = class extends BaseManager {
  constructor() {
    super(...arguments);
    this.highlightStates = new StateTracker();
  }
  updateHighlight(callerId, highlightedDatum) {
    const { activeHighlight: previousHighlight } = this;
    this.highlightStates.set(callerId, highlightedDatum);
    this.activeHighlight = this.highlightStates.stateValue();
    if (!this.isEqual(this.activeHighlight, previousHighlight)) {
      this.listeners.dispatch("highlight-change", {
        type: "highlight-change",
        currentHighlight: this.activeHighlight,
        previousHighlight,
        callerId
      });
    }
  }
  getActiveHighlight() {
    return this.activeHighlight;
  }
  isEqual(a, b) {
    return a === b || a != null && b != null && a?.series === b?.series && a?.itemId === b?.itemId && a?.datum === b?.datum;
  }
};

// packages/ag-charts-community/src/chart/interaction/keyNavManager.ts
var KeyNavManager = class extends InteractionStateListener {
  constructor(focusIndicator, interactionManager, mode) {
    super();
    this.focusIndicator = focusIndicator;
    this.interactionManager = interactionManager;
    // This is the "second last" input event. It can be useful for keydown
    // events that for which don't to set the isFocusVisible state
    // (e.g. Backspace/Delete key on FC annotations, see AG-13041).
    //
    // Use with caution! The focus indicator must ALWAYS be visible for
    // keyboard-only users.
    this.previousInputDevice = "keyboard";
    const mouseStates = 32 /* Default */ | 8 /* Annotations */ | 1 /* AnnotationsSelected */;
    this.destroyFns.push(
      interactionManager.addListener("click", () => this.onClick(), mouseStates),
      interactionManager.addListener("hover", () => this.onMouse(), mouseStates),
      interactionManager.addListener("drag-start", () => this.onMouse(), mouseStates),
      interactionManager.addListener("blur", (e) => this.onBlur(e), 63 /* All */),
      interactionManager.addListener("focus", (e) => this.onFocus(e), 63 /* All */),
      interactionManager.addListener("keydown", (e) => this.onKeyDown(e), 63 /* All */)
    );
    this.focusIndicator.overrideFocusVisible(mode === "integrated" ? false : void 0);
  }
  getState() {
    return this.interactionManager.getState();
  }
  destroy() {
    super.destroy();
  }
  onClick() {
    this.focusIndicator.overrideFocusVisible(false);
    this.previousInputDevice = "mouse";
  }
  onMouse() {
    this.previousInputDevice = "mouse";
  }
  onBlur(event) {
    this.focusIndicator.overrideFocusVisible(void 0);
    this.dispatch("blur", 0, event);
  }
  onFocus(event) {
    this.dispatch("focus", 0, event);
  }
  onKeyDown(event) {
    const state = this.getState();
    const { key, code, altKey, shiftKey, metaKey, ctrlKey } = event.sourceEvent;
    if (ctrlKey || metaKey) {
      if (key === "y" || key === "z" && shiftKey) {
        this.focusIndicator.overrideFocusVisible(this.previousInputDevice === "keyboard");
        return this.dispatch("redo", 0, event);
      } else if (key === "z") {
        this.focusIndicator.overrideFocusVisible(this.previousInputDevice === "keyboard");
        return this.dispatch("undo", 0, event);
      }
    }
    if (state & (8 /* Annotations */ | 1 /* AnnotationsSelected */)) {
      this.focusIndicator.overrideFocusVisible(false);
      return;
    }
    switch (key) {
      case "+":
        return this.dispatch("nav-zoom", 1, event);
      case "-":
        return this.dispatch("nav-zoom", -1, event);
    }
    if (altKey || shiftKey || metaKey || ctrlKey)
      return;
    this.focusIndicator.overrideFocusVisible(true);
    switch (code) {
      case "ArrowDown":
        return this.dispatch("nav-vert", 1, event);
      case "ArrowUp":
        return this.dispatch("nav-vert", -1, event);
      case "ArrowLeft":
        return this.dispatch("nav-hori", -1, event);
      case "ArrowRight":
        return this.dispatch("nav-hori", 1, event);
      case "ZoomIn":
      case "Add":
        return this.dispatch("nav-zoom", 1, event);
      case "ZoomOut":
      case "Substract":
        return this.dispatch("nav-zoom", -1, event);
      case "Space":
      case "Enter":
        return this.dispatch("submit", 0, event);
    }
  }
  dispatch(type, delta3, sourceEvent) {
    const { previousInputDevice } = this;
    dispatchTypedEvent(this.listeners, { type, delta: delta3, sourceEvent, previousInputDevice });
    const sharedKbmTypes = ["redo", "undo", "nav-zoom"];
    if (sourceEvent.type === "keydown" && !sharedKbmTypes.includes(type)) {
      this.previousInputDevice = "keyboard";
    }
  }
};

// packages/ag-charts-community/src/chart/interaction/regions.ts
var NodeRegionBBoxProvider = class {
  constructor(node, overrideId) {
    this.node = node;
    this.overrideId = overrideId;
  }
  get id() {
    return this.overrideId ?? this.node.id;
  }
  get visible() {
    return this.node.visible;
  }
  toCanvasBBox() {
    return Transformable.toCanvas(this.node);
  }
  fromCanvasPoint(x, y) {
    return Transformable.fromCanvasPoint(this.node, x, y);
  }
};
var SimpleRegionBBoxProvider = class extends NodeRegionBBoxProvider {
  constructor(node, bboxFn, overrideId) {
    super(node, overrideId);
    this.bboxFn = bboxFn;
  }
  toCanvasBBox() {
    return this.bboxFn();
  }
};

// packages/ag-charts-community/src/chart/interaction/regionManager.ts
var RegionListeners = class extends Listeners {
};
function addHandler(listeners, interactionManager, type, handler, triggeringStates = 32 /* Default */) {
  return listeners?.addListener(type, (e) => {
    const currentState = interactionManager.getState();
    if (currentState & triggeringStates) {
      handler(e);
    }
  }) ?? (() => {
  });
}
function nodeToBBoxProvider(node) {
  if (node instanceof Node) {
    return new NodeRegionBBoxProvider(node);
  }
  if (node instanceof NodeRegionBBoxProvider) {
    return node;
  }
  return new NodeRegionBBoxProvider(node.node, node.id);
}
function getTooltipContainer(target) {
  if (target == null || !(target instanceof HTMLElement))
    return void 0;
  let current = target;
  while (current != null && !current?.classList.contains("ag-charts-wrapper")) {
    if (current.classList.contains("ag-chart-tooltip")) {
      return current;
    }
    current = current.parentElement;
  }
  return void 0;
}
function shouldIgnore(event) {
  const { type, sourceEvent } = event;
  const { id, className, classList, ariaHidden } = sourceEvent?.target ?? {};
  if (!(classList instanceof DOMTokenList))
    return "leave";
  const dragTypes = DRAG_INTERACTION_TYPES;
  if (
    // Handle drag event on the axis 'add horizontal line annotation' button as canvas events.
    classList.contains("ag-charts-annotations__axis-button-icon") && !dragTypes.includes(type) || className === "ag-charts-series-area" || className === "ag-charts-canvas-proxy" || className === "ag-charts-proxy-elem" && !id?.toString().startsWith("ag-charts-legend-item-") || // legend <buttons>
    sourceEvent?.target instanceof HTMLCanvasElement
  ) {
    return "none";
  }
  if (getTooltipContainer(sourceEvent.target) && ariaHidden !== "true") {
    return "wait";
  }
  return "leave";
}
var RegionManager = class {
  constructor(interactionManager) {
    this.interactionManager = interactionManager;
    this.debug = Debug.create(true, "region");
    this.isDragging = false;
    this.leftCanvas = false;
    this.regions = /* @__PURE__ */ new Map();
    this.destroyFns = [];
    this.allRegionsListeners = new RegionListeners();
    this.destroyFns.push(
      ...POINTER_INTERACTION_TYPES.map(
        (eventName) => interactionManager.addListener(eventName, this.processPointerEvent.bind(this), 63 /* All */)
      )
    );
  }
  destroy() {
    this.destroyFns.forEach((fn) => fn());
    this.current = void 0;
    for (const region of this.regions.values()) {
      region.listeners.destroy();
    }
    this.regions.clear();
  }
  addRegion(name, ...nodes) {
    if (this.regions.has(name)) {
      throw new Error(`AG Charts - Region: ${name} already exists`);
    }
    const region = {
      properties: { name, bboxproviders: nodes.map(nodeToBBoxProvider) },
      listeners: new RegionListeners()
    };
    this.regions.set(name, region);
    return this.makeObserver(region);
  }
  updateRegion(name, ...nodes) {
    const region = this.regions.get(name);
    if (region) {
      region.properties.bboxproviders = nodes.map(nodeToBBoxProvider);
    } else {
      throw new Error("AG Charts - unknown region: " + name);
    }
  }
  getRegion(name) {
    return this.makeObserver(this.regions.get(name));
  }
  listenAll(type, handler, triggeringStates = 32 /* Default */) {
    return addHandler(this.allRegionsListeners, this.interactionManager, type, handler, triggeringStates);
  }
  // This method return a wrapper object that matches the interface of InteractionManager.addListener.
  // The intent is to allow the InteractionManager and RegionManager to be used almost interchangeably.
  makeObserver(region) {
    const { interactionManager } = this;
    class ObservableRegionImplementation {
      addListener(type, handler, triggeringStates = 32 /* Default */) {
        return addHandler(region?.listeners, interactionManager, type, handler, triggeringStates);
      }
    }
    return new ObservableRegionImplementation();
  }
  checkPointerHistory(targetRegion, event) {
    for (const historyEvent of event.pointerHistory) {
      const { region: historyRegion } = this.pickRegion(historyEvent.offsetX, historyEvent.offsetY) ?? {};
      if (targetRegion.properties.name !== historyRegion?.properties.name) {
        return false;
      }
    }
    return true;
  }
  // Create and dispatch a copy of the InteractionEvent.
  dispatch(current, partialEvent) {
    if (current == null)
      return;
    const mainBBoxProvider = current.region.properties.bboxproviders[0];
    let regionOffsetX = 0;
    let regionOffsetY = 0;
    if ("offsetX" in partialEvent && "offsetY" in partialEvent) {
      ({ x: regionOffsetX, y: regionOffsetY } = mainBBoxProvider.fromCanvasPoint(
        partialEvent.offsetX,
        partialEvent.offsetY
      ));
    } else {
      const regionBBox = mainBBoxProvider.toCanvasBBox();
      regionOffsetX = regionBBox.width / 2;
      regionOffsetY = regionBBox.height / 2;
    }
    const event = buildPreventable({
      ...partialEvent,
      region: current.region.properties.name,
      bboxProviderId: current.bboxProvider?.id,
      regionOffsetX,
      regionOffsetY
    });
    this.debug("Dispatching region event: ", event);
    this.allRegionsListeners.dispatch(event.type, event);
    current.region.listeners.dispatch(event.type, event);
  }
  // Process events during a drag action. Returns false if this event should follow the standard
  // RegionManager.processEvent flow, or true if this event already processed by this function.
  handleDragging(event) {
    const { current } = this;
    switch (event.type) {
      case "drag-start":
        this.isDragging = true;
        this.leftCanvas = false;
        break;
      case "leave":
        this.leftCanvas = true;
        return this.isDragging;
      case "enter":
        this.leftCanvas = false;
        return this.isDragging;
      case "drag":
        if (this.isDragging) {
          this.dispatch(current, event);
          return true;
        }
        break;
      case "drag-end":
        if (this.isDragging) {
          this.isDragging = false;
          this.dispatch(current, event);
          if (this.leftCanvas) {
            this.dispatch(current, { ...event, type: "leave" });
          }
          return true;
        }
        break;
    }
    return false;
  }
  processPointerEvent(event) {
    if (this.handleDragging(event)) {
      return;
    }
    const { current } = this;
    const ignore = shouldIgnore(event);
    let newCurrent;
    switch (ignore) {
      case "wait":
        return;
      case "none":
        newCurrent = this.pickRegion(event.offsetX, event.offsetY);
        break;
      case "leave":
        newCurrent = void 0;
        break;
    }
    const newRegion = newCurrent?.region;
    if (current !== void 0 && newRegion?.properties.name !== current.region.properties.name) {
      this.dispatch(current, { ...event, type: "leave" });
    }
    if (newRegion !== void 0 && newRegion.properties.name !== current?.region.properties.name) {
      this.dispatch(newCurrent, { ...event, type: "enter" });
    }
    if (newRegion !== void 0 && this.checkPointerHistory(newRegion, event)) {
      this.dispatch(newCurrent, event);
    }
    this.current = newCurrent;
  }
  pickRegion(x, y) {
    let currentArea = Infinity;
    let currentRegion;
    let currentBBoxProvider;
    for (const region of this.regions.values()) {
      for (const provider of region.properties.bboxproviders) {
        if (provider.visible === false)
          continue;
        const bbox = provider.toCanvasBBox();
        const area2 = bbox.width * bbox.height;
        if (area2 < currentArea && bbox.containsPoint(x, y)) {
          currentArea = area2;
          currentRegion = region;
          currentBBoxProvider = provider;
        }
      }
    }
    return currentRegion ? { region: currentRegion, bboxProvider: currentBBoxProvider } : void 0;
  }
};

// packages/ag-charts-community/src/chart/toolbar/toolbarTypes.ts
var TOOLBAR_ALIGNMENTS = ["start", "center", "end"];
var TOOLBAR_GROUPS = ["seriesType", "annotations", "annotationOptions", "ranges", "zoom"];
var TOOLBAR_GROUP_ORDERING = {
  seriesType: 0,
  annotations: 1,
  annotationOptions: 2,
  ranges: 3,
  zoom: 4
};
var ToolbarPosition = /* @__PURE__ */ ((ToolbarPosition2) => {
  ToolbarPosition2["Top"] = "top";
  ToolbarPosition2["Left"] = "left";
  ToolbarPosition2["Right"] = "right";
  ToolbarPosition2["Bottom"] = "bottom";
  ToolbarPosition2["Floating"] = "floating";
  ToolbarPosition2["FloatingTop"] = "floating-top";
  ToolbarPosition2["FloatingBottom"] = "floating-bottom";
  return ToolbarPosition2;
})(ToolbarPosition || {});
var TOOLBAR_POSITIONS = Object.values(ToolbarPosition);
function isAnimatingFloatingPosition(position) {
  return ["floating-top" /* FloatingTop */, "floating-bottom" /* FloatingBottom */].includes(position);
}

// packages/ag-charts-community/src/chart/interaction/toolbarManager.ts
var ToolbarManager = class extends BaseManager {
  static isGroup(group, event) {
    return event.group === group;
  }
  static isChildElement(domManager, element2) {
    for (const position of TOOLBAR_POSITIONS) {
      if (domManager.isManagedChildDOMElement(element2, "canvas-overlay", `toolbar-${position}`)) {
        return true;
      }
    }
    return false;
  }
  pressButton(group, id, value, rect, sourceEvent) {
    this.listeners.dispatch("button-pressed", { type: "button-pressed", group, id, value, rect, sourceEvent });
  }
  cancel(group) {
    this.listeners.dispatch("cancelled", { type: "cancelled", group });
  }
  toggleButton(group, id, options) {
    const { active = false, enabled = true, visible = true, checked = false } = options;
    this.listeners.dispatch("button-toggled", {
      type: "button-toggled",
      group,
      id,
      active,
      enabled,
      visible,
      checked
    });
  }
  updateButton(group, id, options) {
    this.listeners.dispatch("button-updated", { type: "button-updated", group, id, ...options });
  }
  toggleGroup(caller, group, options) {
    const { active, visible } = options;
    this.listeners.dispatch("group-toggled", { type: "group-toggled", caller, group, active, visible });
  }
  updateGroup(group) {
    this.listeners.dispatch("group-updated", { type: "group-updated", group });
  }
  groupMoved(group) {
    this.listeners.dispatch("group-moved", { type: "group-moved", group });
  }
  changeFloatingAnchor(group, anchor) {
    this.listeners.dispatch("floating-anchor-changed", {
      type: "floating-anchor-changed",
      group,
      anchor
    });
  }
  buttonMoved(group, value, rect, groupRect) {
    this.listeners.dispatch("button-moved", { type: "button-moved", group, value, rect, groupRect });
  }
  proxyGroupOptions(caller, group, options) {
    this.listeners.dispatch("proxy-group-options", { type: "proxy-group-options", caller, group, options });
  }
};

// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts
var TooltipManager = class {
  constructor(domManager, tooltip) {
    this.domManager = domManager;
    this.tooltip = tooltip;
    this.stateTracker = new StateTracker();
    this.suppressState = new StateTracker(false);
    this.appliedState = null;
    tooltip.setup(domManager);
    domManager.addListener("hidden", () => this.tooltip.toggle(false));
  }
  updateTooltip(callerId, meta, content) {
    if (!this.tooltip.enabled)
      return;
    content ?? (content = this.stateTracker.get(callerId)?.content);
    this.stateTracker.set(callerId, { content, meta });
    this.applyStates();
  }
  removeTooltip(callerId) {
    if (!this.tooltip.enabled)
      return;
    this.stateTracker.delete(callerId);
    this.applyStates();
  }
  suppressTooltip(callerId) {
    this.suppressState.set(callerId, true);
  }
  unsuppressTooltip(callerId) {
    this.suppressState.delete(callerId);
  }
  getTooltipMeta(callerId) {
    return this.stateTracker.get(callerId)?.meta;
  }
  destroy() {
    this.domManager.removeStyles("tooltip");
  }
  applyStates() {
    const id = this.stateTracker.stateId();
    const state = id ? this.stateTracker.get(id) : null;
    if (this.suppressState.stateValue() || state?.meta == null || state?.content == null) {
      this.appliedState = null;
      this.tooltip.toggle(false);
      return;
    }
    const canvasRect = this.domManager.getBoundingClientRect();
    const boundingRect = this.tooltip.bounds === "extended" ? this.domManager.getOverlayClientRect() : canvasRect;
    if (this.appliedState?.content === state?.content) {
      const renderInstantly = this.tooltip.isVisible();
      this.tooltip.show(boundingRect, canvasRect, state?.meta, null, renderInstantly);
    } else {
      this.tooltip.show(boundingRect, canvasRect, state?.meta, state?.content);
    }
    this.appliedState = state;
  }
  static makeTooltipMeta(event, datum) {
    const { offsetX, offsetY } = event;
    const tooltip = datum.series.properties.tooltip;
    const meta = {
      offsetX,
      offsetY,
      enableInteraction: tooltip.interaction?.enabled ?? false,
      lastPointerEvent: { type: event.type, offsetX, offsetY },
      showArrow: tooltip.showArrow,
      position: {
        type: tooltip.position.type,
        xOffset: tooltip.position.xOffset,
        yOffset: tooltip.position.yOffset
      }
    };
    const refPoint = datum.yBar?.upperPoint ?? datum.midPoint ?? datum.series.datumMidPoint?.(datum);
    if ((tooltip.position.type === "node" || tooltip.position.type === "sparkline") && refPoint) {
      const { x, y } = refPoint;
      const point = Transformable.toCanvasPoint(datum.series.contentGroup, x, y);
      return {
        ...meta,
        offsetX: Math.round(point.x),
        offsetY: Math.round(point.y)
      };
    }
    return meta;
  }
};

// packages/ag-charts-community/src/chart/interaction/zoomManager.ts
var ZoomManager = class extends BaseManager {
  constructor() {
    super(...arguments);
    this.mementoOriginatorKey = "zoom";
    this.axisZoomManagers = /* @__PURE__ */ new Map();
    this.state = new StateTracker(void 0, "initial");
    this.rejectCallbacks = /* @__PURE__ */ new Map();
  }
  addLayoutListeners(layoutManager) {
    this.destroyFns.push(
      layoutManager.addListener("layout:complete", (event) => {
        this.axes = event.axes;
      })
    );
  }
  createMemento() {
    const zoom2 = this.getDefinedZoom();
    return {
      rangeX: this.getRangeDirection(zoom2, "x" /* X */),
      rangeY: this.getRangeDirection(zoom2, "y" /* Y */),
      ratioX: { start: zoom2.x.min, end: zoom2.x.max },
      ratioY: { start: zoom2.y.min, end: zoom2.y.max }
    };
  }
  guardMemento(blob) {
    return isObject(blob) && (blob.ratioX != null || blob.ratioY != null || blob.rangeX != null || blob.rangeY != null);
  }
  restoreMemento(_version, _mementoVersion, memento) {
    this.listeners.dispatch("restore-zoom", { ...memento, type: "restore-zoom" });
  }
  updateAxes(axes) {
    const zoomManagers = new Map(axes.map((axis) => [axis.id, this.axisZoomManagers.get(axis.id)]));
    this.axisZoomManagers.clear();
    for (const axis of axes) {
      this.axisZoomManagers.set(axis.id, zoomManagers.get(axis.id) ?? new AxisZoomManager(axis));
    }
    if (this.state.size > 0 && axes.length > 0) {
      this.updateZoom(this.state.stateId(), this.state.stateValue());
    }
  }
  updateZoom(callerId, newZoom, canChangeInitial = true, rejectCallback) {
    if (rejectCallback) {
      this.rejectCallbacks.set(callerId, rejectCallback);
    }
    if (this.axisZoomManagers.size === 0) {
      const stateId = this.state.stateId();
      if (stateId === "initial" || stateId === callerId || canChangeInitial) {
        this.state.set(callerId, newZoom);
        if (stateId !== callerId) {
          this.rejectCallbacks.get(stateId)?.(callerId);
        }
      } else {
        rejectCallback?.(stateId);
      }
      return;
    }
    this.state.set(callerId, newZoom);
    this.axisZoomManagers.forEach((axis) => {
      axis.updateZoom(callerId, newZoom?.[axis.getDirection()]);
    });
    this.applyChanges(callerId);
  }
  updateAxisZoom(callerId, axisId, newZoom) {
    this.axisZoomManagers.get(axisId)?.updateZoom(callerId, newZoom);
    this.applyChanges(callerId);
  }
  // Fire this event to signal to listeners that the view is changing through a zoom and/or pan change.
  fireZoomPanStartEvent(callerId) {
    this.listeners.dispatch("zoom-pan-start", { type: "zoom-pan-start", callerId });
  }
  getZoom() {
    let x;
    let y;
    this.axisZoomManagers.forEach((axis) => {
      if (axis.getDirection() === "x" /* X */) {
        x ?? (x = axis.getZoom());
      } else if (axis.getDirection() === "y" /* Y */) {
        y ?? (y = axis.getZoom());
      }
    });
    if (x || y) {
      return { x, y };
    }
  }
  getAxisZoom(axisId) {
    return this.axisZoomManagers.get(axisId)?.getZoom() ?? { min: 0, max: 1 };
  }
  getAxisZooms() {
    const axes = {};
    for (const [axisId, axis] of this.axisZoomManagers.entries()) {
      axes[axisId] = {
        direction: axis.getDirection(),
        zoom: axis.getZoom()
      };
    }
    return axes;
  }
  applyChanges(callerId) {
    const changed = Array.from(this.axisZoomManagers.values(), (axis) => axis.applyChanges()).some(Boolean);
    if (!changed) {
      return;
    }
    const axes = {};
    for (const [axisId, axis] of this.axisZoomManagers.entries()) {
      axes[axisId] = axis.getZoom();
    }
    this.listeners.dispatch("zoom-change", { type: "zoom-change", ...this.getZoom(), axes, callerId });
  }
  getRangeDirection(zoom2, direction) {
    for (const axis of this.axes ?? []) {
      if (axis.direction !== direction)
        continue;
      const domain = axis.scale.getDomain?.();
      const d0 = axis.scale.convert?.(domain?.at(0));
      const d1 = axis.scale.convert?.(domain?.at(-1));
      if (!isFiniteNumber(d0) || !isFiniteNumber(d1))
        return;
      let start;
      let end;
      if (d0 <= d1) {
        const diff2 = d1 - d0;
        start = axis.scale.invert?.(0);
        end = axis.scale.invert?.(d0 + diff2 * zoom2[direction].max);
      } else {
        const diff2 = d0 - d1;
        start = axis.scale.invert?.(d0 - diff2 * zoom2[direction].min);
        end = axis.scale.invert?.(0);
      }
      return { start, end };
    }
  }
  getDefinedZoom() {
    const zoom2 = this.getZoom();
    return {
      x: { min: zoom2?.x?.min ?? 0, max: zoom2?.x?.max ?? 1 },
      y: { min: zoom2?.y?.min ?? 0, max: zoom2?.y?.max ?? 1 }
    };
  }
};
var AxisZoomManager = class {
  constructor(axis) {
    this.axis = axis;
    const [min = 0, max = 1] = axis.visibleRange;
    this.state = new StateTracker({ min, max });
    this.currentZoom = this.state.stateValue();
  }
  getDirection() {
    return this.axis.direction;
  }
  updateZoom(callerId, newZoom) {
    this.state.set(callerId, newZoom);
  }
  getZoom() {
    return deepClone(this.state.stateValue());
  }
  applyChanges() {
    const prevZoom = this.currentZoom;
    this.currentZoom = this.state.stateValue();
    return prevZoom.min !== this.currentZoom.min || prevZoom.max !== this.currentZoom.max;
  }
};

// packages/ag-charts-community/src/chart/series/seriesStateManager.ts
var SeriesStateManager = class {
  constructor() {
    this.groups = {};
  }
  registerSeries({ internalId, seriesGrouping, visible, type }) {
    var _a;
    if (!seriesGrouping)
      return;
    (_a = this.groups)[type] ?? (_a[type] = {});
    this.groups[type][internalId] = { grouping: seriesGrouping, visible };
  }
  updateSeries({ internalId, seriesGrouping, visible, type }) {
    if (!seriesGrouping)
      return;
    const entry = this.groups[type]?.[internalId];
    if (entry) {
      entry.grouping = seriesGrouping;
      entry.visible = visible;
    }
  }
  deregisterSeries({ internalId, type }) {
    if (this.groups[type]) {
      delete this.groups[type][internalId];
    }
    if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {
      delete this.groups[type];
    }
  }
  getVisiblePeerGroupIndex({ type, seriesGrouping, visible }) {
    if (!seriesGrouping)
      return { visibleGroupCount: visible ? 1 : 0, visibleSameStackCount: visible ? 1 : 0, index: 0 };
    const visibleGroupsSet = /* @__PURE__ */ new Set();
    const visibleSameStackSet = /* @__PURE__ */ new Set();
    for (const entry of Object.values(this.groups[type] ?? {})) {
      if (!entry.visible)
        continue;
      visibleGroupsSet.add(entry.grouping.groupIndex);
      if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {
        visibleSameStackSet.add(entry.grouping.stackIndex);
      }
    }
    const visibleGroups = Array.from(visibleGroupsSet);
    visibleGroups.sort((a, b) => a - b);
    return {
      visibleGroupCount: visibleGroups.length,
      visibleSameStackCount: visibleSameStackSet.size,
      index: visibleGroups.indexOf(seriesGrouping.groupIndex)
    };
  }
};

// packages/ag-charts-community/src/chart/chartUpdateType.ts
var ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType2) => {
  ChartUpdateType2[ChartUpdateType2["FULL"] = 0] = "FULL";
  ChartUpdateType2[ChartUpdateType2["UPDATE_DATA"] = 1] = "UPDATE_DATA";
  ChartUpdateType2[ChartUpdateType2["PROCESS_DATA"] = 2] = "PROCESS_DATA";
  ChartUpdateType2[ChartUpdateType2["PERFORM_LAYOUT"] = 3] = "PERFORM_LAYOUT";
  ChartUpdateType2[ChartUpdateType2["SERIES_UPDATE"] = 4] = "SERIES_UPDATE";
  ChartUpdateType2[ChartUpdateType2["PRE_SCENE_RENDER"] = 5] = "PRE_SCENE_RENDER";
  ChartUpdateType2[ChartUpdateType2["SCENE_RENDER"] = 6] = "SCENE_RENDER";
  ChartUpdateType2[ChartUpdateType2["NONE"] = 7] = "NONE";
  return ChartUpdateType2;
})(ChartUpdateType || {});

// packages/ag-charts-community/src/chart/updateService.ts
var UpdateService = class extends Listeners {
  constructor(updateCallback) {
    super();
    this.updateCallback = updateCallback;
  }
  update(type = 0 /* FULL */, options) {
    this.updateCallback(type, options);
  }
  dispatchUpdateComplete(rects) {
    this.dispatch("update-complete", {
      type: "update-complete",
      minRect: rects?.minRect,
      minVisibleRect: rects?.minVisibleRect
    });
  }
  dispatchPreDomUpdate() {
    this.dispatch("pre-dom-update", { type: "pre-dom-update" });
  }
  dispatchPreSceneRender(rects) {
    this.dispatch("pre-scene-render", { type: "pre-scene-render", ...rects });
  }
};

// packages/ag-charts-community/src/chart/chartContext.ts
var ChartContext = class {
  constructor(chart, vars) {
    this.callbackCache = new CallbackCache();
    this.chartEventManager = new ChartEventManager();
    this.highlightManager = new HighlightManager();
    this.layoutManager = new LayoutManager();
    this.localeManager = new LocaleManager();
    this.seriesStateManager = new SeriesStateManager();
    this.stateManager = new StateManager();
    this.toolbarManager = new ToolbarManager();
    this.zoomManager = new ZoomManager();
    const { scene, root, syncManager, container, updateCallback, updateMutex, pixelRatio, styleContainer } = vars;
    this.chartService = chart;
    this.syncManager = syncManager;
    this.domManager = new DOMManager(container, styleContainer);
    const canvasElement = this.domManager.addChild(
      "canvas",
      "scene-canvas",
      scene?.canvas.element
    );
    this.scene = scene ?? new Scene({ pixelRatio, canvasElement });
    this.scene.setRoot(root);
    this.axisManager = new AxisManager(root);
    this.annotationManager = new AnnotationManager(chart.annotationRoot);
    this.cursorManager = new CursorManager(this.domManager);
    this.interactionManager = new InteractionManager(chart.keyboard, this.domManager);
    this.focusIndicator = new FocusIndicator(this.domManager);
    this.keyNavManager = new KeyNavManager(this.focusIndicator, this.interactionManager, chart.mode);
    this.regionManager = new RegionManager(this.interactionManager);
    this.contextMenuRegistry = new ContextMenuRegistry(this.regionManager);
    this.gestureDetector = new GestureDetector(this.domManager);
    this.updateService = new UpdateService(updateCallback);
    this.proxyInteractionService = new ProxyInteractionService(this.localeManager, this.domManager);
    this.historyManager = new HistoryManager(this.keyNavManager);
    this.animationManager = new AnimationManager(this.interactionManager, updateMutex);
    this.dataService = new DataService(this.animationManager);
    this.tooltipManager = new TooltipManager(this.domManager, chart.tooltip);
    this.zoomManager.addLayoutListeners(this.layoutManager);
  }
  destroy() {
    this.animationManager.destroy();
    this.highlightManager.destroy();
    this.axisManager.destroy();
    this.callbackCache.invalidateCache();
    this.chartEventManager.destroy();
    this.contextMenuRegistry.destroy();
    this.domManager.destroy();
    this.highlightManager.destroy();
    this.interactionManager.destroy();
    this.keyNavManager.destroy();
    this.focusIndicator.destroy();
    this.proxyInteractionService.destroy();
    this.regionManager.destroy();
    this.syncManager.destroy();
    this.tooltipManager.destroy();
    this.zoomManager.destroy();
  }
};

// packages/ag-charts-community/src/chart/chartHighlight.ts
var ChartHighlight = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.range = "tooltip";
  }
};
__decorateClass([
  Validate(UNION(["tooltip", "node"], "a range"))
], ChartHighlight.prototype, "range", 2);

// packages/ag-charts-community/src/chart/data/dataDomain.ts
var DiscreteDomain = class _DiscreteDomain {
  constructor() {
    this.domain = /* @__PURE__ */ new Set();
  }
  static is(value) {
    return value instanceof _DiscreteDomain;
  }
  extend(val) {
    this.domain.add(val);
  }
  getDomain() {
    return Array.from(this.domain);
  }
};
var ContinuousDomain = class _ContinuousDomain {
  constructor() {
    this.domain = [Infinity, -Infinity];
  }
  static is(value) {
    return value instanceof _ContinuousDomain;
  }
  static extendDomain(values, domain = [Infinity, -Infinity]) {
    for (const value of values) {
      if (typeof value !== "number") {
        continue;
      }
      if (domain[0] > value) {
        domain[0] = value;
      }
      if (domain[1] < value) {
        domain[1] = value;
      }
    }
    return domain;
  }
  extend(value) {
    if (this.domain[0] > value) {
      this.domain[0] = value;
    }
    if (this.domain[1] < value) {
      this.domain[1] = value;
    }
  }
  getDomain() {
    return [...this.domain];
  }
};

// packages/ag-charts-community/src/chart/data/dataModel.ts
function toKeyString(keys) {
  return keys.map((key) => isObject(key) ? JSON.stringify(key) : key).join("-");
}
function round2(val) {
  const accuracy = 1e4;
  if (Number.isInteger(val)) {
    return val;
  } else if (Math.abs(val) > accuracy) {
    return Math.trunc(val);
  }
  return Math.round(val * accuracy) / accuracy;
}
function fixNumericExtent(extent2) {
  if (extent2 == null) {
    return [];
  }
  const [min, max] = extent2.map(Number);
  if (min === 0 && max === 0) {
    return [0, 1];
  }
  return isFiniteNumber(min) && isFiniteNumber(max) ? [min, max] : [];
}
function getMissCount(scopeProvider, missMap) {
  return missMap?.get(scopeProvider.id) ?? 0;
}
var INVALID_VALUE = Symbol("invalid");
function getPathComponents(path) {
  const components = [];
  let matchIndex = 0;
  let matchGroup;
  const regExp = /((?:(?:^|\.)\s*\w+|\[\s*(?:'(?:[^']|\\')*'|"(?:[^"]|\\")*"|-?\d+)\s*\])\s*)/g;
  while (matchGroup = regExp.exec(path)) {
    if (matchGroup.index !== matchIndex) {
      return;
    }
    matchIndex = matchGroup.index + matchGroup[0].length;
    const match = matchGroup[1].trim();
    if (match.startsWith(".")) {
      components.push(match.slice(1).trim());
    } else if (match.startsWith("[")) {
      const accessor = match.slice(1, -1).trim();
      if (accessor.startsWith(`'`)) {
        components.push(accessor.slice(1, -1).replace(/\\'/g, `'`));
      } else if (accessor.startsWith(`"`)) {
        components.push(accessor.slice(1, -1).replace(/\\"/g, `"`));
      } else {
        components.push(accessor);
      }
    } else {
      components.push(match);
    }
  }
  if (matchIndex !== path.length)
    return;
  return components;
}
function createPathAccessor(components) {
  return (datum) => {
    let current = datum;
    for (const component of components) {
      current = current[component];
    }
    return current;
  };
}
var DataModel = class {
  constructor(opts, mode = "standalone") {
    this.opts = opts;
    this.mode = mode;
    this.debug = Debug.create(true, "data-model");
    this.scopeCache = /* @__PURE__ */ new Map();
    this.keys = [];
    this.values = [];
    this.aggregates = [];
    this.groupProcessors = [];
    this.propertyProcessors = [];
    this.reducers = [];
    this.processors = [];
    let keys = true;
    for (const next of opts.props) {
      if (next.type === "key" && !keys) {
        throw new Error("AG Charts - internal config error: keys must come before values.");
      }
      if (next.type === "value" && keys) {
        keys = false;
      }
    }
    const verifyMatchGroupId = ({ matchGroupIds = [] }) => {
      for (const matchGroupId of matchGroupIds) {
        if (this.values.every((def) => def.groupId !== matchGroupId)) {
          throw new Error(
            `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`
          );
        }
      }
    };
    for (const def of opts.props) {
      switch (def.type) {
        case "key":
          this.keys.push({ ...def, index: this.keys.length, missing: /* @__PURE__ */ new Map() });
          break;
        case "value":
          if (def.property == null) {
            throw new Error(
              `AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(
                def
              )}`
            );
          }
          this.values.push({ ...def, index: this.values.length, missing: /* @__PURE__ */ new Map() });
          break;
        case "aggregate":
          verifyMatchGroupId(def);
          this.aggregates.push({ ...def, index: this.aggregates.length });
          break;
        case "group-value-processor":
          verifyMatchGroupId(def);
          this.groupProcessors.push({ ...def, index: this.groupProcessors.length });
          break;
        case "property-value-processor":
          this.propertyProcessors.push({ ...def, index: this.propertyProcessors.length });
          break;
        case "reducer":
          this.reducers.push({ ...def, index: this.reducers.length });
          break;
        case "processor":
          this.processors.push({ ...def, index: this.processors.length });
          break;
      }
    }
  }
  resolveProcessedDataDefById(scope, searchId) {
    const def = this.scopeCache.get(scope.id)?.get(searchId);
    if (!def) {
      throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${scope.id}]`);
    }
    return { index: def.index, def };
  }
  resolveProcessedDataIndexById(scope, searchId) {
    return this.resolveProcessedDataDefById(scope, searchId).index;
  }
  resolveProcessedDataDefsByIds(scope, searchIds) {
    return searchIds.map((searchId) => [searchId, this.resolveProcessedDataDefById(scope, searchId)]);
  }
  resolveProcessedDataDefsValues(defs, { keys, values }) {
    const result = {};
    for (const [searchId, { index, def }] of defs) {
      const processedData = def.type === "key" ? keys : values;
      result[searchId] = processedData[index];
    }
    return result;
  }
  getDomain(scope, searchId, type = "value", processedData) {
    const domains = this.getDomainsByType(type, processedData);
    return domains?.[this.resolveProcessedDataIndexById(scope, searchId)] ?? [];
  }
  getDomainsByType(type, processedData) {
    switch (type) {
      case "key":
        return processedData.domain.keys;
      case "value":
        return processedData.domain.values;
      case "aggregate":
        return processedData.domain.aggValues;
      case "group-value-processor":
        return processedData.domain.groups;
      default:
        return null;
    }
  }
  processData(data, sources) {
    const {
      opts: { groupByKeys, groupByFn },
      aggregates,
      groupProcessors,
      reducers,
      processors,
      propertyProcessors
    } = this;
    const start = performance.now();
    if (groupByKeys && this.keys.length === 0) {
      return;
    }
    let processedData = this.extractData(data, sources);
    if (groupByKeys) {
      processedData = this.groupData(processedData);
    } else if (groupByFn) {
      processedData = this.groupData(processedData, groupByFn(processedData));
    }
    if (groupProcessors.length > 0) {
      this.postProcessGroups(processedData);
    }
    if (aggregates.length > 0) {
      this.aggregateData(processedData);
    }
    if (propertyProcessors.length > 0) {
      this.postProcessProperties(processedData);
    }
    if (reducers.length > 0) {
      this.reduceData(processedData);
    }
    if (processors.length > 0) {
      this.postProcessData(processedData);
    }
    if (data.length > 0) {
      for (const def of iterate(this.keys, this.values)) {
        for (const [scope, missCount] of def.missing) {
          if (missCount >= data.length) {
            const scopeHint = scope == null ? "" : ` for ${scope}`;
            Logger.warnOnce(`the key '${def.property}' was not found in any data element${scopeHint}.`);
          }
        }
      }
    }
    const end = performance.now();
    processedData.time = end - start;
    if (this.debug.check()) {
      logProcessedData(processedData);
    }
    this.scopeCache.clear();
    for (const def of iterate(this.keys, this.values, this.aggregates)) {
      if (!def.idsMap)
        continue;
      for (const [scope, ids] of def.idsMap) {
        for (const id of ids) {
          if (!this.scopeCache.has(scope)) {
            this.scopeCache.set(scope, /* @__PURE__ */ new Map([[id, def]]));
          } else if (this.scopeCache.get(scope)?.has(id)) {
            throw new Error("duplicate definition ids on the same scope are not allowed.");
          } else {
            this.scopeCache.get(scope).set(id, def);
          }
        }
      }
    }
    return processedData;
  }
  valueGroupIdxLookup({ matchGroupIds }) {
    const result = [];
    for (const [index, def] of this.values.entries()) {
      if (!matchGroupIds || def.groupId && matchGroupIds.includes(def.groupId)) {
        result.push(index);
      }
    }
    return result;
  }
  valueIdxLookup(scopes, prop) {
    const noScopesToMatch = scopes == null || scopes.length === 0;
    const propId = typeof prop === "string" ? prop : prop.id;
    const hasMatchingScopeId = (def) => {
      if (def.idsMap) {
        for (const [scope, ids] of def.idsMap) {
          if (scopes?.includes(scope) && ids.has(propId)) {
            return true;
          }
        }
      }
      return false;
    };
    const result = this.values.findIndex((def) => {
      const validDefScopes = def.scopes == null || noScopesToMatch && !def.scopes.length || def.scopes.some((s) => scopes?.includes(s));
      return validDefScopes && (def.property === propId || def.id === propId || hasMatchingScopeId(def));
    });
    if (result === -1) {
      throw new Error(
        `AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(
          scopes
        )}`
      );
    }
    return result;
  }
  extractData(data, sources) {
    const { dataDomain, processValue, scopes, allScopesHaveSameDefs } = this.initDataDomainProcessor();
    const sourcesById = new Map(sources?.map((s) => [s.id, s]));
    const { keys: keyDefs, values: valueDefs } = this;
    const resultData = new Array(data.length);
    let resultDataIdx = 0;
    let partialValidDataCount = 0;
    for (const [datumIdx, datum] of data.entries()) {
      const sourceDatums = {};
      const validScopes = scopes.size > 0 ? new Set(scopes) : void 0;
      const keys = new Array(keyDefs.length);
      let keyIdx = 0;
      let key;
      for (const def of keyDefs) {
        key = processValue(def, datum, key);
        if (key === INVALID_VALUE)
          break;
        if (keys) {
          keys[keyIdx++] = key;
        }
      }
      if (key === INVALID_VALUE)
        continue;
      const values = valueDefs.length > 0 ? new Array(valueDefs.length) : void 0;
      let value;
      for (const [valueDefIdx, def] of valueDefs.entries()) {
        for (const scope of def.scopes ?? scopes) {
          const source = sourcesById.get(scope);
          const valueDatum = source?.data[datumIdx] ?? datum;
          value = processValue(def, valueDatum, value, scope);
          if (value === INVALID_VALUE || !values)
            continue;
          if (source != null && def.includeProperty !== false) {
            const property = def.includeProperty && def.id != null ? def.id : def.property;
            sourceDatums[scope] ?? (sourceDatums[scope] = {});
            sourceDatums[scope][property] = value;
          }
          values[valueDefIdx] = value;
        }
        if (value === INVALID_VALUE) {
          if (allScopesHaveSameDefs)
            break;
          for (const scope of def.scopes ?? scopes) {
            validScopes?.delete(scope);
          }
          if (validScopes?.size === 0)
            break;
        }
      }
      if (value === INVALID_VALUE && allScopesHaveSameDefs)
        continue;
      if (validScopes?.size === 0)
        continue;
      const result = { datum: { ...datum, ...sourceDatums }, keys, values };
      if (!allScopesHaveSameDefs && validScopes && validScopes.size < scopes.size) {
        partialValidDataCount++;
        result.validScopes = new Set(validScopes);
      }
      resultData[resultDataIdx++] = result;
    }
    resultData.length = resultDataIdx;
    const propertyDomain = (def) => {
      const defDomain = dataDomain.get(def);
      const result = defDomain.getDomain();
      if (ContinuousDomain.is(defDomain) && result[0] > result[1]) {
        return [];
      }
      return result;
    };
    return {
      type: "ungrouped",
      input: { count: data.length },
      data: resultData,
      domain: {
        keys: keyDefs.map(propertyDomain),
        values: valueDefs.map(propertyDomain)
      },
      defs: {
        allScopesHaveSameDefs,
        keys: keyDefs,
        values: valueDefs
      },
      partialValidDataCount,
      time: 0
    };
  }
  groupData(data, groupingFn) {
    const processedData = /* @__PURE__ */ new Map();
    for (const dataEntry of data.data) {
      const { keys, values, datum, validScopes } = dataEntry;
      const group = groupingFn?.(dataEntry) ?? keys;
      const groupStr = toKeyString(group);
      if (processedData.has(groupStr)) {
        const existingData = processedData.get(groupStr);
        existingData.values.push(values);
        existingData.datum.push(datum);
        if (validScopes != null && existingData.validScopes != null) {
          for (const scope of existingData.validScopes) {
            if (!validScopes.has(scope)) {
              existingData.validScopes.delete(scope);
            }
          }
        }
      } else {
        processedData.set(groupStr, {
          keys: group,
          values: [values],
          datum: [datum],
          validScopes
        });
      }
    }
    const resultData = new Array(processedData.size);
    const resultGroups = new Array(processedData.size);
    let dataIndex = 0;
    for (const { keys, values, datum, validScopes } of processedData.values()) {
      if (validScopes?.size === 0)
        continue;
      resultGroups[dataIndex] = keys;
      resultData[dataIndex++] = {
        keys,
        values,
        datum,
        validScopes
      };
    }
    return {
      ...data,
      type: "grouped",
      data: resultData,
      domain: {
        ...data.domain,
        groups: resultGroups
      }
    };
  }
  aggregateData(processedData) {
    const isUngrouped = processedData.type === "ungrouped";
    processedData.domain.aggValues = [];
    for (const [index, def] of this.aggregates.entries()) {
      const indices = this.valueGroupIdxLookup(def);
      const domain = [Infinity, -Infinity];
      for (const datum of processedData.data) {
        datum.aggValues ?? (datum.aggValues = new Array(this.aggregates.length));
        if (datum.validScopes)
          continue;
        const values = isUngrouped ? [datum.values] : datum.values;
        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];
        for (const distinctValues of values) {
          const valuesToAgg = indices.map((valueIdx) => distinctValues[valueIdx]);
          const valuesAgg = def.aggregateFunction(valuesToAgg, datum.keys);
          if (valuesAgg) {
            groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);
          }
        }
        const finalValues = (def.finalFunction?.(groupAggValues) ?? groupAggValues).map((v) => round2(v));
        datum.aggValues[index] = finalValues;
        ContinuousDomain.extendDomain(finalValues, domain);
      }
      processedData.domain.aggValues.push(domain);
    }
  }
  postProcessGroups(processedData) {
    const { groupProcessors } = this;
    const affectedIndices = /* @__PURE__ */ new Set();
    const updatedDomains = /* @__PURE__ */ new Map();
    const groupProcessorIndices = /* @__PURE__ */ new Map();
    const groupProcessorInitFns = /* @__PURE__ */ new Map();
    for (const processor of groupProcessors) {
      const indices = this.valueGroupIdxLookup(processor);
      groupProcessorIndices.set(processor, indices);
      groupProcessorInitFns.set(processor, processor.adjust());
      for (const idx of indices) {
        const valueDef = this.values[idx];
        const isDiscrete = valueDef.valueType === "category";
        affectedIndices.add(idx);
        updatedDomains.set(idx, isDiscrete ? new DiscreteDomain() : new ContinuousDomain());
      }
    }
    const updateDomains = (values) => {
      for (const valueIndex of affectedIndices) {
        updatedDomains.get(valueIndex)?.extend(values[valueIndex]);
      }
    };
    for (const group of processedData.data) {
      for (const processor of groupProcessors) {
        if (group.validScopes)
          continue;
        const valueIndexes = groupProcessorIndices.get(processor) ?? [];
        const adjustFn = groupProcessorInitFns.get(processor)?.();
        if (!adjustFn)
          continue;
        if (processedData.type === "grouped") {
          for (const values of group.values) {
            if (values) {
              adjustFn(values, valueIndexes);
            }
          }
        } else if (group.values) {
          adjustFn(group.values, valueIndexes);
        }
      }
      if (processedData.type === "grouped") {
        for (const values of group.values) {
          updateDomains(values);
        }
      } else {
        updateDomains(group.values);
      }
    }
    for (const [idx, dataDomain] of updatedDomains) {
      processedData.domain.values[idx] = dataDomain.getDomain();
    }
  }
  postProcessProperties(processedData) {
    for (const { adjust, property, scopes } of this.propertyProcessors) {
      adjust()(processedData, this.valueIdxLookup(scopes, property));
    }
  }
  reduceData(processedData) {
    processedData.reduced ?? (processedData.reduced = {});
    for (const def of this.reducers) {
      const reducer = def.reducer();
      let accValue = def.initialValue;
      for (const datum of processedData.data) {
        if (!datum.validScopes || def.scopes?.some((s) => datum.validScopes?.has(s))) {
          accValue = reducer(accValue, datum);
        }
      }
      processedData.reduced[def.property] = accValue;
    }
  }
  postProcessData(processedData) {
    processedData.reduced ?? (processedData.reduced = {});
    for (const def of this.processors) {
      processedData.reduced[def.property] = def.calculate(processedData);
    }
  }
  initDataDomainProcessor() {
    const { keys: keyDefs, values: valueDefs } = this;
    const scopes = /* @__PURE__ */ new Set();
    for (const valueDef of valueDefs) {
      if (!valueDef.scopes)
        continue;
      for (const scope of valueDef.scopes) {
        scopes.add(scope);
      }
    }
    const dataDomain = /* @__PURE__ */ new Map();
    const processorFns = /* @__PURE__ */ new Map();
    let allScopesHaveSameDefs = true;
    const initDataDomain = () => {
      for (const def of iterate(keyDefs, valueDefs)) {
        if (def.valueType === "category") {
          dataDomain.set(def, new DiscreteDomain());
        } else {
          dataDomain.set(def, new ContinuousDomain());
          allScopesHaveSameDefs && (allScopesHaveSameDefs = (def.scopes ?? []).length === scopes.size);
        }
      }
    };
    initDataDomain();
    const accessors = this.buildAccessors(iterate(keyDefs, valueDefs));
    const processValue = (def, datum, previousDatum, scope) => {
      let valueInDatum;
      let value;
      if (accessors.has(def.property)) {
        try {
          value = accessors.get(def.property)(datum);
        } catch (error) {
        }
        valueInDatum = value != null;
      } else {
        valueInDatum = def.property in datum;
        value = valueInDatum ? datum[def.property] : def.missingValue;
      }
      if (def.forceValue != null) {
        const valueNegative = valueInDatum && isNegative(value);
        value = valueNegative ? -1 * def.forceValue : def.forceValue;
        valueInDatum = true;
      }
      const missingValueDef = "missingValue" in def;
      if (!valueInDatum && !missingValueDef) {
        const missCount = def.missing.get(scope) ?? 0;
        def.missing.set(scope, missCount + 1);
      }
      if (!dataDomain.has(def)) {
        initDataDomain();
      }
      if (valueInDatum && def.validation?.(value, datum) === false) {
        if ("invalidValue" in def) {
          value = def.invalidValue;
        } else {
          if (this.mode !== "integrated") {
            Logger.warnOnce(
              `invalid value of type [${typeof value}] for [${def.scopes} / ${def.id}] ignored:`,
              `[${value}]`
            );
          }
          return INVALID_VALUE;
        }
      }
      if (def.processor) {
        if (!processorFns.has(def)) {
          processorFns.set(def, def.processor());
        }
        value = processorFns.get(def)?.(value, previousDatum === INVALID_VALUE ? void 0 : previousDatum);
      }
      dataDomain.get(def)?.extend(value);
      return value;
    };
    return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };
  }
  buildAccessors(defs) {
    const result = /* @__PURE__ */ new Map();
    if (this.mode === "integrated") {
      return result;
    }
    for (const def of defs) {
      const isPath = def.property.includes(".") || def.property.includes("[");
      if (!isPath)
        continue;
      const components = getPathComponents(def.property);
      if (components == null) {
        Logger.warnOnce("Invalid property path [%s]", def.property);
        continue;
      }
      const accessor = createPathAccessor(components);
      result.set(def.property, accessor);
    }
    return result;
  }
};
function logProcessedData(processedData) {
  const logValues = (name, data) => {
    if (data.length > 0) {
      Logger.log(`DataModel.processData() - ${name}`);
      Logger.table(data);
    }
  };
  Logger.log("DataModel.processData() - processedData", processedData);
  logValues("Key Domains", processedData.domain.keys);
  logValues("Group Domains", processedData.domain.groups ?? []);
  logValues("Value Domains", processedData.domain.values);
  logValues("Aggregate Domains", processedData.domain.aggValues ?? []);
  if (processedData.type === "grouped") {
    const flattenedValues = processedData.data.reduce((acc, next) => {
      const keys = next.keys ?? [];
      const aggValues = next.aggValues ?? [];
      const skipKeys = next.keys.map(() => void 0);
      const skipAggValues = aggValues?.map(() => void 0);
      acc.push(
        ...next.values.map((v, i) => [
          ...i === 0 ? keys : skipKeys,
          ...v ?? [],
          ...i == 0 ? aggValues : skipAggValues
        ])
      );
      return acc;
    }, []);
    logValues("Values", flattenedValues);
  } else {
    const flattenedValues = processedData.data.reduce((acc, next) => {
      const aggValues = next.aggValues ?? [];
      acc.push([...next.keys, ...next.values, ...aggValues]);
      return acc;
    }, []);
    logValues("Values", flattenedValues);
  }
}

// packages/ag-charts-community/src/chart/data/dataController.ts
var _DataController = class _DataController {
  constructor(mode) {
    this.mode = mode;
    this.debug = Debug.create(true, "data-model");
    this.requested = [];
    this.status = "setup";
  }
  async request(id, data, opts) {
    if (this.status !== "setup") {
      throw new Error(`AG Charts - data request after data setup phase.`);
    }
    return new Promise((resolve, reject) => {
      this.requested.push({ id, opts, data, resolve, reject });
    });
  }
  execute() {
    if (this.status !== "setup") {
      throw new Error(`AG Charts - data request after data setup phase.`);
    }
    this.status = "executed";
    this.debug("DataController.execute() - requested", this.requested);
    const valid = this.validateRequests(this.requested);
    this.debug("DataController.execute() - validated", valid);
    const merged = this.mergeRequested(valid);
    this.debug("DataController.execute() - merged", merged);
    if (this.debug.check()) {
      getWindow().processedData = [];
    }
    const scopes = this.requested.map(({ id }) => id);
    const needsValueExtraction = this.hasMultipleDataSources(valid);
    for (const { opts, data, resolves, rejects, ids } of merged) {
      try {
        const dataModel = new DataModel(opts, this.mode);
        const processedData = dataModel.processData(data, valid);
        if (this.debug.check()) {
          getWindow("processedData").push(processedData);
        }
        if (processedData?.partialValidDataCount === 0) {
          resolves.forEach(
            (resolve, requestIdx) => resolve({
              dataModel,
              processedData: this.processScopedData(
                ids[requestIdx],
                processedData,
                scopes,
                needsValueExtraction
              )
            })
          );
        } else if (processedData) {
          this.splitResult(dataModel, processedData, ids, resolves);
        } else {
          rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));
        }
      } catch (error) {
        rejects.forEach((cb) => cb(error));
      }
    }
  }
  hasMultipleDataSources(validRequests) {
    if (validRequests.length) {
      const [{ data }, ...restRequests] = validRequests;
      return restRequests.some((v) => data !== v.data);
    }
    return false;
  }
  processScopedData(id, processedData, ids, needsValueExtraction) {
    const extractDatum = (datum) => {
      if (Array.isArray(datum)) {
        return datum.map(extractDatum);
      }
      const extracted = needsValueExtraction ? { ...datum, ...datum[id] } : datum;
      for (const otherId of ids) {
        delete extracted[otherId];
      }
      return extracted;
    };
    const extractValues = (values) => {
      if (Array.isArray(values)) {
        return values.map(extractValues);
      }
      return values?.[id] ?? values;
    };
    return {
      ...processedData,
      data: processedData.data.map((datum) => ({
        ...datum,
        datum: extractDatum(datum.datum),
        values: needsValueExtraction ? datum.values?.map(extractValues) : datum.values
      }))
    };
  }
  validateRequests(requested) {
    const valid = [];
    for (const [index, request] of requested.entries()) {
      if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false) {
        request.reject(
          new Error("all series[].data arrays must be of the same length and have matching keys.")
        );
      } else {
        valid.push(request);
      }
    }
    return valid;
  }
  mergeRequested(requested) {
    const grouped = [];
    for (const request of requested) {
      const match = grouped.find(_DataController.groupMatch(request));
      if (match) {
        match.push(request);
      } else {
        grouped.push([request]);
      }
    }
    return grouped.map(_DataController.mergeRequests);
  }
  splitResult(dataModel, processedData, scopes, resolves) {
    for (let i = 0; i < scopes.length; i++) {
      const scope = scopes[i];
      const resolve = resolves[i];
      resolve({
        dataModel,
        processedData: {
          ...processedData,
          data: processedData.data.filter(({ validScopes }) => validScopes?.has(scope) ?? true)
        }
      });
    }
  }
  static groupMatch({ data, opts }) {
    function keys(props) {
      return props.filter((p) => p.type === "key").map((p) => p.property).join(";");
    }
    return ([group]) => (opts.groupByData === false || group.data === data) && group.opts.groupByKeys === opts.groupByKeys && group.opts.groupByFn === opts.groupByFn && keys(group.opts.props) === keys(opts.props);
  }
  static mergeRequests(requests) {
    return requests.reduce(
      (result, { id, data, resolve, reject, opts: { props, ...opts } }) => {
        result.ids.push(id);
        result.rejects.push(reject);
        result.resolves.push(resolve);
        result.data ?? (result.data = data);
        result.opts ?? (result.opts = { ...opts, props: [] });
        for (const prop of props) {
          const clone = { ...prop, scopes: [id] };
          _DataController.createIdsMap(id, clone);
          const match = result.opts.props.find(
            (existing) => existing.type === clone.type && _DataController.deepEqual(existing, clone)
          );
          if (!match) {
            result.opts.props.push(clone);
            continue;
          }
          match.scopes ?? (match.scopes = []);
          match.scopes.push(...clone.scopes ?? []);
          if ((match.type === "key" || match.type === "value") && clone.idsMap?.size) {
            _DataController.mergeIdsMap(clone.idsMap, match.idsMap);
          }
        }
        return result;
      },
      { ids: [], rejects: [], resolves: [], data: null, opts: null }
    );
  }
  static mergeIdsMap(fromMap, toMap) {
    for (const [scope, ids] of fromMap) {
      const toMapValue = toMap.get(scope);
      if (toMapValue != null) {
        for (const id of ids) {
          toMapValue.add(id);
        }
      } else {
        toMap.set(scope, new Set(ids));
      }
    }
  }
  static createIdsMap(scope, prop) {
    if (prop.id == null)
      return;
    prop.idsMap ?? (prop.idsMap = /* @__PURE__ */ new Map());
    if (prop.idsMap.has(scope)) {
      prop.idsMap.get(scope).add(prop.id);
    } else {
      prop.idsMap.set(scope, /* @__PURE__ */ new Set([prop.id]));
    }
  }
  static deepEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor) {
        return false;
      }
      let i, length2;
      if (Array.isArray(a)) {
        length2 = a.length;
        if (length2 !== b.length) {
          return false;
        }
        for (i = length2 - 1; i >= 0; i--) {
          if (!_DataController.deepEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      const keys = Object.keys(a);
      length2 = keys.length;
      if (length2 !== Object.keys(b).length) {
        return false;
      }
      for (i = length2 - 1; i >= 0; i--) {
        const key = keys[i];
        if (!_DataController.skipKeys.has(key) && (!Object.hasOwn(b, key) || !_DataController.deepEqual(a[key], b[key]))) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
};
// optimized version of deep equality for `mergeRequests` which can potentially loop over 1M times
_DataController.skipKeys = /* @__PURE__ */ new Set(["id", "idsMap", "type", "scopes"]);
var DataController = _DataController;

// packages/ag-charts-community/src/chart/factory/axisRegistry.ts
var AxisRegistry = class {
  constructor() {
    this.axesMap = /* @__PURE__ */ new Map();
    this.hidden = /* @__PURE__ */ new Set();
    this.themeTemplates = /* @__PURE__ */ new Map();
  }
  register(axisType, module2) {
    this.axesMap.set(axisType, module2.moduleFactory);
    if (module2.themeTemplate) {
      this.setThemeTemplate(axisType, module2.themeTemplate);
    }
    if (module2.hidden) {
      this.hidden.add(axisType);
    }
  }
  create(axisType, moduleContext) {
    const axisFactory = this.axesMap.get(axisType);
    if (axisFactory) {
      return axisFactory(moduleContext);
    }
    throw new Error(`AG Charts - unknown axis type: ${axisType}`);
  }
  has(axisType) {
    return this.axesMap.has(axisType);
  }
  keys() {
    return this.axesMap.keys();
  }
  publicKeys() {
    return [...this.keys()].filter((k) => !this.hidden.has(k));
  }
  setThemeTemplate(axisType, themeTemplate) {
    this.themeTemplates.set(axisType, themeTemplate);
    return this;
  }
  getThemeTemplate(axisType) {
    return this.themeTemplates.get(axisType);
  }
};
var axisRegistry = new AxisRegistry();

// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts
var EXPECTED_ENTERPRISE_MODULES = [
  {
    type: "root",
    optionsKey: "animation",
    chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"]
  },
  { type: "root", optionsKey: "annotations", chartTypes: ["cartesian"] },
  {
    type: "root",
    optionsKey: "background",
    chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"],
    optionsInnerKey: "image"
  },
  {
    type: "root",
    optionsKey: "foreground",
    chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"],
    optionsInnerKey: "image"
  },
  {
    type: "root",
    optionsKey: "chartToolbar",
    chartTypes: ["cartesian"]
  },
  {
    type: "root",
    optionsKey: "contextMenu",
    chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"]
  },
  { type: "root", optionsKey: "statusBar", chartTypes: ["cartesian"], identifier: "status-bar" },
  {
    type: "root",
    optionsKey: "dataSource",
    chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"]
  },
  { type: "root", optionsKey: "sync", chartTypes: ["cartesian"] },
  { type: "root", optionsKey: "zoom", chartTypes: ["cartesian", "topology"] },
  {
    type: "legend",
    optionsKey: "gradientLegend",
    chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"],
    identifier: "gradient"
  },
  { type: "root", optionsKey: "navigator", chartTypes: ["cartesian"], optionsInnerKey: "miniChart" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "angle-category" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "angle-number" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "radius-category" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "radius-number" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["cartesian"], identifier: "ordinal-time" },
  { type: "axis-option", optionsKey: "crosshair", chartTypes: ["cartesian"] },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "box-plot" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "candlestick" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "cone-funnel" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "funnel" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "ohlc" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "bullet" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "heatmap" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "range-area" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "range-bar" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "waterfall" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "nightingale" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radar-area" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radar-line" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radial-bar" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radial-column" },
  { type: "series", optionsKey: "series[]", chartTypes: ["hierarchy"], identifier: "sunburst" },
  { type: "series", optionsKey: "series[]", chartTypes: ["hierarchy"], identifier: "treemap" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-shape" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-line" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-marker" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-shape-background" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-line-background" },
  { type: "series", optionsKey: "series[]", chartTypes: ["flow-proportion"], identifier: "chord" },
  { type: "series", optionsKey: "series[]", chartTypes: ["flow-proportion"], identifier: "sankey" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "pyramid" },
  { type: "series", optionsKey: "series[]", chartTypes: ["gauge"], identifier: "linear-gauge" },
  { type: "series", optionsKey: "series[]", chartTypes: ["gauge"], identifier: "radial-gauge" },
  { type: "series-option", optionsKey: "errorBar", chartTypes: ["cartesian"], identifier: "error-bars" }
];
function isEnterpriseSeriesType(type) {
  return EXPECTED_ENTERPRISE_MODULES.some((s) => s.type === "series" && s.identifier === type);
}
function getEnterpriseSeriesChartTypes(type) {
  return EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === "series" && s.identifier === type)?.chartTypes;
}
function isEnterpriseCartesian(seriesType2) {
  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === "cartesian");
  return type === "cartesian";
}
function isEnterprisePolar(seriesType2) {
  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === "polar");
  return type === "polar";
}
function isEnterpriseHierarchy(seriesType2) {
  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === "hierarchy");
  return type === "hierarchy";
}
function isEnterpriseTopology(seriesType2) {
  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === "topology");
  return type === "topology";
}
function isEnterpriseFlowProportion(seriesType2) {
  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === "flow-proportion");
  return type === "flow-proportion";
}
function isEnterpriseStandalone(seriesType2) {
  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === "standalone");
  return type === "standalone";
}
function isEnterpriseGauge(seriesType2) {
  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === "gauge");
  return type === "gauge";
}
function isEnterpriseModule(module2) {
  return module2.packageType === "enterprise";
}
function verifyIfModuleExpected(module2) {
  if (!isEnterpriseModule(module2)) {
    throw new Error("AG Charts - internal configuration error, only enterprise modules need verification.");
  }
  const stub = EXPECTED_ENTERPRISE_MODULES.find((s) => {
    return s.type === module2.type && s.optionsKey === module2.optionsKey && s.identifier === module2.identifier && module2.chartTypes.every((t) => s.chartTypes.includes(t));
  });
  if (stub) {
    stub.useCount ?? (stub.useCount = 0);
    stub.useCount++;
  }
  return stub != null;
}
function getUnusedExpectedModules() {
  return EXPECTED_ENTERPRISE_MODULES.filter(({ useCount }) => useCount == null || useCount === 0);
}

// packages/ag-charts-community/src/chart/factory/legendRegistry.ts
var LegendRegistry = class {
  constructor() {
    this.legendMap = /* @__PURE__ */ new Map();
    this.themeTemplates = /* @__PURE__ */ new Map();
  }
  register(legendType, { optionsKey, moduleFactory, themeTemplate }) {
    this.legendMap.set(legendType, { optionsKey, moduleFactory });
    this.themeTemplates.set(optionsKey, themeTemplate);
  }
  create(legendType, moduleContext) {
    const legendFactory = this.legendMap.get(legendType)?.moduleFactory;
    if (legendFactory) {
      return legendFactory(moduleContext);
    }
    throw new Error(`AG Charts - unknown legend type: ${legendType}`);
  }
  getThemeTemplates() {
    return Object.fromEntries(this.themeTemplates);
  }
  getKeys() {
    return Array.from(this.legendMap.entries()).reduce(
      (result, [legendType, record]) => {
        result[legendType] = record.optionsKey;
        return result;
      },
      {}
    );
  }
};
var legendRegistry = new LegendRegistry();

// packages/ag-charts-community/src/chart/factory/chartTypes.ts
var ChartTypes = class extends Map {
  get(seriesType2) {
    return super.get(seriesType2) ?? "unknown";
  }
  isCartesian(seriesType2) {
    return this.get(seriesType2) === "cartesian";
  }
  isPolar(seriesType2) {
    return this.get(seriesType2) === "polar";
  }
  isHierarchy(seriesType2) {
    return this.get(seriesType2) === "hierarchy";
  }
  isTopology(seriesType2) {
    return this.get(seriesType2) === "topology";
  }
  isFlowProportion(seriesType2) {
    return this.get(seriesType2) === "flow-proportion";
  }
  isStandalone(seriesType2) {
    return this.get(seriesType2) === "standalone";
  }
  isGauge(seriesType2) {
    return this.get(seriesType2) === "gauge";
  }
  get seriesTypes() {
    return Array.from(this.keys());
  }
  get cartesianTypes() {
    return this.seriesTypes.filter((t) => this.isCartesian(t));
  }
  get polarTypes() {
    return this.seriesTypes.filter((t) => this.isPolar(t));
  }
  get hierarchyTypes() {
    return this.seriesTypes.filter((t) => this.isHierarchy(t));
  }
  get topologyTypes() {
    return this.seriesTypes.filter((t) => this.isTopology(t));
  }
  get flowProportionTypes() {
    return this.seriesTypes.filter((t) => this.isFlowProportion(t));
  }
  get standaloneTypes() {
    return this.seriesTypes.filter((t) => this.isStandalone(t));
  }
  get gaugeTypes() {
    return this.seriesTypes.filter((t) => this.isGauge(t));
  }
};
var ChartDefaults = class extends Map {
  set(chartType2, defaults) {
    return super.set(chartType2, mergeDefaults(defaults, this.get(chartType2)));
  }
};
var chartTypes = new ChartTypes();
var publicChartTypes = new ChartTypes();
var chartDefaults = new ChartDefaults();

// packages/ag-charts-community/src/chart/factory/seriesRegistry.ts
var SeriesRegistry = class {
  constructor() {
    this.seriesMap = /* @__PURE__ */ new Map();
    this.themeTemplates = /* @__PURE__ */ new Map();
  }
  register(seriesType2, {
    chartTypes: [chartType2],
    moduleFactory,
    tooltipDefaults,
    defaultAxes,
    themeTemplate,
    paletteFactory,
    solo,
    stackable,
    groupable,
    stackedByDefault,
    hidden
  }) {
    this.setThemeTemplate(seriesType2, themeTemplate);
    this.seriesMap.set(seriesType2, {
      moduleFactory,
      tooltipDefaults,
      defaultAxes,
      paletteFactory,
      solo,
      stackable,
      groupable,
      stackedByDefault
    });
    chartTypes.set(seriesType2, chartType2);
    if (!hidden) {
      publicChartTypes.set(seriesType2, chartType2);
    }
  }
  create(seriesType2, moduleContext) {
    const seriesFactory = this.seriesMap.get(seriesType2)?.moduleFactory;
    if (seriesFactory) {
      return seriesFactory(moduleContext);
    }
    throw new Error(`AG Charts - unknown series type: ${seriesType2}`);
  }
  cloneDefaultAxes(seriesType2, options) {
    const defaultAxes = this.seriesMap.get(seriesType2)?.defaultAxes;
    if (defaultAxes == null)
      return null;
    const axes = typeof defaultAxes === "function" ? defaultAxes(options) : defaultAxes;
    return { axes: deepClone(axes) };
  }
  setThemeTemplate(seriesType2, themeTemplate) {
    const currentTemplate = this.themeTemplates.get(seriesType2);
    this.themeTemplates.set(seriesType2, mergeDefaults(themeTemplate, currentTemplate));
  }
  getThemeTemplate(seriesType2) {
    return this.themeTemplates.get(seriesType2);
  }
  getPaletteFactory(seriesType2) {
    return this.seriesMap.get(seriesType2)?.paletteFactory;
  }
  getTooltipDefauls(seriesType2) {
    return this.seriesMap.get(seriesType2)?.tooltipDefaults;
  }
  isSolo(seriesType2) {
    return this.seriesMap.get(seriesType2)?.solo ?? false;
  }
  isGroupable(seriesType2) {
    return this.seriesMap.get(seriesType2)?.groupable ?? false;
  }
  isStackable(seriesType2) {
    return this.seriesMap.get(seriesType2)?.stackable ?? false;
  }
  isStackedByDefault(seriesType2) {
    return this.seriesMap.get(seriesType2)?.stackedByDefault ?? false;
  }
};
var seriesRegistry = new SeriesRegistry();

// packages/ag-charts-community/src/chart/interaction/syncManager.ts
var _SyncManager = class _SyncManager extends BaseManager {
  constructor(chart) {
    super();
    this.chart = chart;
  }
  subscribe(groupId = _SyncManager.DEFAULT_GROUP) {
    let syncGroup = this.get(groupId);
    if (!syncGroup) {
      syncGroup = /* @__PURE__ */ new Set();
      _SyncManager.chartsGroups.set(groupId, syncGroup);
    }
    syncGroup.add(this.chart);
    return this;
  }
  unsubscribe(groupId = _SyncManager.DEFAULT_GROUP) {
    this.get(groupId)?.delete(this.chart);
    return this;
  }
  getChart() {
    return this.chart;
  }
  getGroup(groupId = _SyncManager.DEFAULT_GROUP) {
    const syncGroup = this.get(groupId);
    return syncGroup ? Array.from(syncGroup) : [];
  }
  getGroupSiblings(groupId = _SyncManager.DEFAULT_GROUP) {
    return this.getGroup(groupId).filter((chart) => chart !== this.chart);
  }
  get(groupId) {
    return _SyncManager.chartsGroups.get(groupId);
  }
};
_SyncManager.chartsGroups = /* @__PURE__ */ new Map();
_SyncManager.DEFAULT_GROUP = Symbol("sync-group-default");
var SyncManager = _SyncManager;

// packages/ag-charts-community/src/chart/keyboard.ts
var Keyboard = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = false;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], Keyboard.prototype, "enabled", 2);
__decorateClass([
  Validate(NUMBER)
], Keyboard.prototype, "tabIndex", 2);

// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts
var CartesianAxisPositions = ["top", "right", "bottom", "left"];
function isAxisPosition(position) {
  return typeof position === "string" && CartesianAxisPositions.includes(position);
}
function guessInvalidPositions(axes) {
  const invalidAxes = [];
  const usedPositions = [];
  const guesses = [...CartesianAxisPositions];
  for (const axis of axes) {
    if (axis instanceof CartesianAxis) {
      if (isAxisPosition(axis.position)) {
        usedPositions.push(axis.position);
      } else {
        invalidAxes.push(axis);
      }
    }
  }
  for (const axis of invalidAxes) {
    let nextGuess;
    do {
      nextGuess = guesses.pop();
    } while (nextGuess && usedPositions.includes(nextGuess));
    if (nextGuess == null)
      break;
    axis.position = nextGuess;
  }
}

// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts
var MATCHING_KEYS = ["direction", "xKey", "yKey", "sizeKey", "angleKey", "radiusKey", "normalizedTo"];
function matchSeriesOptions(series, optSeries, oldOptsSeries) {
  const generateKey = (type, i, opts) => {
    const result = [type];
    for (const key of MATCHING_KEYS) {
      if (key in i && i[key] != null)
        result.push(`${key}=${i[key]}`);
    }
    if (opts?.seriesGrouping) {
      result.push(`seriesGrouping.groupId=${opts?.seriesGrouping.groupId}`);
    }
    return result.join(";");
  };
  const seriesMap = /* @__PURE__ */ new Map();
  let idx = 0;
  for (const s of series) {
    const key = generateKey(s.type, s.properties, oldOptsSeries?.[idx]);
    if (!seriesMap.has(key)) {
      seriesMap.set(key, []);
    }
    seriesMap.get(key)?.push([s, idx++]);
  }
  const optsMap = /* @__PURE__ */ new Map();
  for (const o of optSeries) {
    const key = generateKey(o.type, o, o);
    if (!optsMap.has(key)) {
      optsMap.set(key, []);
    }
    optsMap.get(key)?.push(o);
  }
  const overlap = [...seriesMap.keys()].some((k) => optsMap.has(k));
  if (!overlap) {
    return { status: "no-overlap", oldKeys: seriesMap.keys(), newKeys: optsMap.keys() };
  }
  const changes = [];
  let targetIdx = -1;
  for (const [key, optArray] of optsMap.entries()) {
    for (const opts of optArray) {
      targetIdx++;
      const seriesArray = seriesMap.get(key);
      if (seriesArray == null || seriesArray.length < 1) {
        changes.push({ opts, idx: targetIdx, status: "add" });
        seriesMap.delete(key);
        continue;
      }
      const [outputSeries, outputIdx] = seriesArray.shift();
      const previousOpts = oldOptsSeries?.[outputIdx] ?? {};
      const diff2 = jsonDiff(previousOpts, opts ?? {});
      const { groupIndex, stackIndex } = diff2?.seriesGrouping ?? {};
      if (groupIndex != null || stackIndex != null) {
        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: "series-grouping" });
      } else if (diff2) {
        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: "update" });
      } else {
        changes.push({ opts, series: outputSeries, idx: outputIdx, status: "no-op" });
      }
      if (seriesArray.length === 0) {
        seriesMap.delete(key);
      }
    }
  }
  for (const seriesArray of seriesMap.values()) {
    for (const [outputSeries, outputIdx] of seriesArray) {
      changes.push({ series: outputSeries, idx: outputIdx, status: "remove" });
    }
  }
  return { status: "overlap", changes };
}

// packages/ag-charts-community/src/chart/mapping/types.ts
function optionsType(input) {
  const { series } = input;
  if (!series)
    return;
  return series[0]?.type ?? "line";
}
function isAgCartesianChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  return chartTypes.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);
}
function isAgPolarChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  if (specifiedType === "polar") {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return chartTypes.isPolar(specifiedType) || isEnterprisePolar(specifiedType);
}
function isAgHierarchyChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  if (specifiedType === "hierarchy") {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return chartTypes.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);
}
function isAgTopologyChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  if (specifiedType === "topology") {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return chartTypes.isTopology(specifiedType) || isEnterpriseTopology(specifiedType);
}
function isAgFlowProportionChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  if (specifiedType === "flow-proportion") {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return chartTypes.isFlowProportion(specifiedType) || isEnterpriseFlowProportion(specifiedType);
}
function isAgStandaloneChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  if (specifiedType === "standalone") {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return chartTypes.isStandalone(specifiedType) || isEnterpriseStandalone(specifiedType);
}
function isAgGaugeChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  if (specifiedType === "gauge") {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return chartTypes.isGauge(specifiedType) || isEnterpriseGauge(specifiedType);
}
function isAgPolarChartOptionsWithSeriesBasedLegend(input) {
  const specifiedType = optionsType(input);
  return isAgPolarChartOptions(input) && specifiedType !== "pie" && specifiedType !== "donut";
}
function isSeriesOptionType(input) {
  if (input == null) {
    return false;
  }
  return chartTypes.has(input);
}
function isAxisOptionType(input) {
  if (input == null) {
    return false;
  }
  return axisRegistry.has(input);
}

// packages/ag-charts-community/src/chart/modulesManager.ts
var ModulesManager = class extends ModuleMap {
  applyOptions(options) {
    for (const m of this.moduleMap.values()) {
      if (m.module.optionsKey in options && isProperties(m.moduleInstance)) {
        m.moduleInstance.set(options[m.module.optionsKey]);
      }
    }
  }
  *legends() {
    for (const { module: module2, moduleInstance } of this.moduleMap.values()) {
      if (module2.type !== "legend")
        continue;
      yield {
        legendType: module2.identifier,
        legend: moduleInstance
      };
    }
  }
};

// packages/ag-charts-community/src/chart/overlay/overlay.ts
var DEFAULT_OVERLAY_CLASS = "ag-chart-overlay";
var DEFAULT_OVERLAY_DARK_CLASS = "ag-chart-dark-overlay";
var Overlay = class extends BaseProperties {
  constructor(className, defaultMessageId) {
    super();
    this.className = className;
    this.defaultMessageId = defaultMessageId;
  }
  getText(localeManager) {
    return localeManager.t(this.text ?? this.defaultMessageId);
  }
  getElement(animationManager, localeManager, rect) {
    this.content?.remove();
    this.focusBox = rect;
    if (this.renderer) {
      const htmlContent = this.renderer();
      if (htmlContent instanceof HTMLElement) {
        this.content = htmlContent;
      } else {
        const tempDiv = createElement("div");
        tempDiv.innerHTML = htmlContent;
        this.content = tempDiv.firstElementChild;
      }
    } else {
      const content = createElement("div", {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        boxSizing: "border-box",
        height: "100%",
        margin: "8px",
        font: "12px Verdana, sans-serif"
      });
      content.innerText = this.getText(localeManager);
      this.content = content;
      animationManager?.animate({
        from: 0,
        to: 1,
        id: "overlay",
        phase: "add",
        groupId: "opacity",
        onUpdate(value) {
          content.style.opacity = String(value);
        },
        onStop() {
          content.style.opacity = "1";
        }
      });
    }
    return this.content;
  }
  removeElement(cleanup = () => this.content?.remove(), animationManager) {
    if (!this.content)
      return;
    if (animationManager) {
      const { content } = this;
      animationManager.animate({
        from: 1,
        to: 0,
        phase: "remove",
        id: "overlay",
        groupId: "opacity",
        onUpdate(value) {
          content.style.opacity = String(value);
        },
        onStop() {
          cleanup?.();
        }
      });
    } else {
      cleanup?.();
    }
    this.content = void 0;
    this.focusBox = void 0;
  }
};
__decorateClass([
  Validate(STRING, { optional: true })
], Overlay.prototype, "text", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], Overlay.prototype, "renderer", 2);

// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts
var ChartOverlays = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.darkTheme = false;
    this.loading = new Overlay("ag-chart-loading-overlay", "overlayLoadingData");
    this.noData = new Overlay("ag-chart-no-data-overlay", "overlayNoData");
    this.noVisibleSeries = new Overlay("ag-chart-no-visible-series", "overlayNoVisibleSeries");
  }
  getFocusInfo(localeManager) {
    for (const overlay of [this.loading, this.noData, this.noVisibleSeries]) {
      if (overlay.focusBox !== void 0) {
        return { text: overlay.getText(localeManager), rect: overlay.focusBox };
      }
    }
    return void 0;
  }
  destroy() {
    this.loading.removeElement();
    this.noData.removeElement();
    this.noVisibleSeries.removeElement();
  }
};
__decorateClass([
  Validate(BOOLEAN)
], ChartOverlays.prototype, "darkTheme", 2);
__decorateClass([
  Validate(OBJECT)
], ChartOverlays.prototype, "loading", 2);
__decorateClass([
  Validate(OBJECT)
], ChartOverlays.prototype, "noData", 2);
__decorateClass([
  Validate(OBJECT)
], ChartOverlays.prototype, "noVisibleSeries", 2);

// packages/ag-charts-community/src/chart/overlay/loadingSpinner.ts
function getLoadingSpinner(text, defaultDuration) {
  const { animationDuration } = PHASE_METADATA["add"];
  const duration = animationDuration * defaultDuration;
  const container = createElement("div", `${DEFAULT_OVERLAY_CLASS}--loading`, {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column",
    height: "100%",
    boxSizing: "border-box",
    font: "13px Verdana, sans-serif",
    // FONT_SIZE.MEDIUM
    userSelect: "none",
    animation: `ag-charts-loading ${duration}ms linear 50ms both`
  });
  const matrix = createElement("span", {
    width: "45px",
    height: "40px",
    backgroundImage: [
      "linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), ",
      "linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), ",
      "linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)"
    ].join(""),
    backgroundSize: "10px 400%",
    backgroundRepeat: "no-repeat",
    animation: "ag-charts-loading-matrix 1s infinite linear"
  });
  const label = createElement("p", { marginTop: "1em" });
  label.innerText = text;
  const background = createElement("div", `${DEFAULT_OVERLAY_CLASS}__loading-background`, {
    position: "absolute",
    inset: "0",
    opacity: "0.5",
    zIndex: "-1"
  });
  const animationStyles = createElement("style");
  animationStyles.innerText = [
    "@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }",
    "@keyframes ag-charts-loading-matrix {",
    "0% { background-position: 0% 0%, 50% 0%, 100% 0%; }",
    "100% { background-position: 0% 100%, 50% 100%, 100% 100%; }",
    "}"
  ].join(" ");
  container.replaceChildren(animationStyles, matrix, label, background);
  return container;
}

// packages/ag-charts-community/src/chart/series/series.ts
var CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR = 0.25;
var CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR = 0.125;
var SeriesNodeEvent = class {
  constructor(type, event, { datum }, series) {
    this.type = type;
    this.event = event;
    this.datum = datum;
    this.seriesId = series.id;
  }
};
var SeriesGroupingChangedEvent = class {
  constructor(series, seriesGrouping, oldGrouping) {
    this.series = series;
    this.seriesGrouping = seriesGrouping;
    this.oldGrouping = oldGrouping;
    this.type = "groupingChanged";
  }
};
var Series = class extends Observable {
  constructor(seriesOpts) {
    super();
    this.destroyFns = [];
    this.seriesGrouping = void 0;
    this.NodeEvent = SeriesNodeEvent;
    this.internalId = createId(this);
    // The group node that contains all the nodes used to render this series.
    this.rootGroup = new Group({ name: "seriesRoot", isVirtual: true });
    this.axes = {
      ["x" /* X */]: void 0,
      ["y" /* Y */]: void 0
    };
    this.directions = ["x" /* X */, "y" /* Y */];
    // Flag to determine if we should recalculate node data.
    this.nodeDataRefresh = true;
    this.moduleMap = new ModuleMap();
    this._declarationOrder = -1;
    this.seriesListeners = new Listeners();
    this._pickNodeCache = new LRUCache();
    const {
      moduleCtx,
      pickModes,
      directionKeys = {},
      directionNames = {},
      contentGroupVirtual = true,
      canHaveAxes = false
    } = seriesOpts;
    this.ctx = moduleCtx;
    this.directionKeys = directionKeys;
    this.directionNames = directionNames;
    this.canHaveAxes = canHaveAxes;
    this.contentGroup = this.rootGroup.appendChild(
      new TranslatableGroup({
        name: `${this.internalId}-content`,
        isVirtual: contentGroupVirtual,
        zIndex: 4 /* SERIES_LAYER */,
        zIndexSubOrder: this.getGroupZIndexSubOrder("data")
      })
    );
    this.highlightGroup = new TranslatableGroup({
      name: `${this.internalId}-highlight`,
      isVirtual: contentGroupVirtual,
      zIndex: 4 /* SERIES_LAYER */,
      zIndexSubOrder: this.getGroupZIndexSubOrder("highlight")
    });
    this.highlightNode = this.highlightGroup.appendChild(new Group({ name: "highlightNode", zIndex: 0 }));
    this.highlightLabel = this.highlightGroup.appendChild(new Group({ name: "highlightLabel", zIndex: 10 }));
    this.pickModes = pickModes;
    this.labelGroup = this.rootGroup.appendChild(
      new TranslatableGroup({
        name: `${this.internalId}-series-labels`,
        zIndex: 14 /* SERIES_LABEL */
      })
    );
    this.annotationGroup = new Group({
      name: `${this.id}-annotation`,
      isVirtual: contentGroupVirtual,
      zIndex: 4 /* SERIES_LAYER */,
      zIndexSubOrder: this.getGroupZIndexSubOrder("annotation")
    });
  }
  get pickModeAxis() {
    return "main";
  }
  get id() {
    return this.properties?.id ?? this.internalId;
  }
  get type() {
    return this.constructor.type ?? "";
  }
  get data() {
    return this._data ?? this._chartData;
  }
  set visible(value) {
    this.properties.visible = value;
    this.visibleMaybeChanged();
  }
  get visible() {
    return this.properties.visible;
  }
  get hasData() {
    return this.data != null && this.data.length > 0;
  }
  get tooltipEnabled() {
    return this.properties.tooltip?.enabled ?? false;
  }
  onDataChange() {
    this.nodeDataRefresh = true;
    this._pickNodeCache.clear();
  }
  setOptionsData(input) {
    this._data = input;
    this.onDataChange();
  }
  setChartData(input) {
    this._chartData = input;
    if (this.data === input) {
      this.onDataChange();
    }
  }
  onSeriesGroupingChange(prev, next) {
    const { internalId, type, visible } = this;
    if (prev) {
      this.ctx.seriesStateManager.deregisterSeries(this);
    }
    if (next) {
      this.ctx.seriesStateManager.registerSeries({ internalId, type, visible, seriesGrouping: next });
    }
    this.fireEvent(new SeriesGroupingChangedEvent(this, next, prev));
  }
  getBandScalePadding() {
    return { inner: 1, outer: 0 };
  }
  getGroupZIndexSubOrder(type, subIndex = 0) {
    let mainAdjust = 0;
    switch (type) {
      case "data":
      case "paths":
        break;
      case "labels":
        mainAdjust += 2e4;
        break;
      case "marker":
        mainAdjust += 1e4;
        break;
      case "highlight":
        subIndex += 15e3;
        break;
      case "annotation":
        mainAdjust += 15e3;
        break;
    }
    const main = () => this._declarationOrder + mainAdjust;
    return [main, subIndex];
  }
  addListener(type, listener) {
    return this.seriesListeners.addListener(type, listener);
  }
  dispatch(type, event) {
    this.seriesListeners.dispatch(type, event);
  }
  addChartEventListeners() {
    return;
  }
  destroy() {
    this.destroyFns.forEach((f) => f());
    this.destroyFns = [];
    this.ctx.seriesStateManager.deregisterSeries(this);
  }
  getDirectionValues(direction, properties) {
    const resolvedDirection = this.resolveKeyDirection(direction);
    const keys = properties?.[resolvedDirection];
    const values = [];
    if (!keys) {
      return values;
    }
    const addValues = (...items) => {
      for (const value of items) {
        if (Array.isArray(value)) {
          addValues(...value);
        } else if (typeof value === "object") {
          addValues(...Object.values(value));
        } else {
          values.push(value);
        }
      }
    };
    addValues(...keys.map((key) => this.properties[key]));
    return values;
  }
  getKeys(direction) {
    return this.getDirectionValues(direction, this.directionKeys);
  }
  getKeyProperties(direction) {
    return this.directionKeys[this.resolveKeyDirection(direction)] ?? [];
  }
  getNames(direction) {
    return this.getDirectionValues(direction, this.directionNames);
  }
  resolveKeyDirection(direction) {
    return direction;
  }
  // The union of the series domain ('community') and series-option domains ('enterprise').
  getDomain(direction) {
    const seriesDomain = this.getSeriesDomain(direction);
    const moduleDomains = this.moduleMap.mapModules((module2) => module2.getDomain(direction));
    return seriesDomain.concat(moduleDomains.flat());
  }
  // Indicate that something external changed and we should recalculate nodeData.
  markNodeDataDirty() {
    this.nodeDataRefresh = true;
    this._pickNodeCache.clear();
    this.visibleMaybeChanged();
  }
  visibleMaybeChanged() {
    this.ctx.seriesStateManager.updateSeries(this);
  }
  getOpacity() {
    const defaultOpacity = 1;
    const { dimOpacity = 1, enabled = true } = this.properties.highlightStyle.series;
    if (!enabled || dimOpacity === defaultOpacity) {
      return defaultOpacity;
    }
    switch (this.isItemIdHighlighted()) {
      case 0 /* None */:
      case 1 /* This */:
        return defaultOpacity;
      case 2 /* Other */:
      default:
        return dimOpacity;
    }
  }
  getStrokeWidth(defaultStrokeWidth) {
    const { strokeWidth, enabled = true } = this.properties.highlightStyle.series;
    if (!enabled || strokeWidth === void 0) {
      return defaultStrokeWidth;
    }
    switch (this.isItemIdHighlighted()) {
      case 1 /* This */:
        return strokeWidth;
      case 0 /* None */:
      case 2 /* Other */:
        return defaultStrokeWidth;
    }
  }
  isItemIdHighlighted() {
    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;
    if (series == null) {
      return 0 /* None */;
    }
    if (series !== this) {
      return 2 /* Other */;
    }
    return 1 /* This */;
  }
  getModuleTooltipParams() {
    return this.moduleMap.mapModules((module2) => module2.getTooltipParams()).reduce((total, current) => Object.assign(total, current), {});
  }
  pickNode(point, intent, exactMatchOnly = false) {
    const { pickModes, pickModeAxis, visible, rootGroup } = this;
    if (!visible || !rootGroup.visible)
      return;
    if (intent === "highlight" && !this.properties.highlight.enabled)
      return;
    if (intent === "highlight-tooltip" && !this.properties.highlight.enabled)
      return;
    let maxDistance = Infinity;
    if (intent === "tooltip" || intent === "highlight-tooltip") {
      const { tooltip } = this.properties;
      maxDistance = typeof tooltip.range === "number" ? tooltip.range : Infinity;
      exactMatchOnly || (exactMatchOnly = tooltip.range === "exact");
    } else if (intent === "event" || intent === "context-menu") {
      const { nodeClickRange } = this.properties;
      maxDistance = typeof nodeClickRange === "number" ? nodeClickRange : Infinity;
      exactMatchOnly || (exactMatchOnly = nodeClickRange === "exact");
    }
    const selectedPickModes = pickModes.filter(
      (m) => !exactMatchOnly || m === 0 /* EXACT_SHAPE_MATCH */
    );
    const { x, y } = point;
    const key = JSON.stringify({ x, y, maxDistance, selectedPickModes });
    if (this._pickNodeCache.has(key)) {
      return this._pickNodeCache.get(key);
    }
    for (const pickMode of selectedPickModes) {
      let match;
      switch (pickMode) {
        case 0 /* EXACT_SHAPE_MATCH */:
          match = this.pickNodeExactShape(point);
          break;
        case 1 /* NEAREST_NODE */:
          match = this.pickNodeClosestDatum(point);
          break;
        case 2 /* AXIS_ALIGNED */:
          match = pickMode != null ? this.pickNodeMainAxisFirst(point, pickModeAxis === "main-category") : void 0;
          break;
      }
      if (match && match.distance <= maxDistance) {
        return this._pickNodeCache.set(key, { pickMode, match: match.datum, distance: match.distance });
      }
    }
    return this._pickNodeCache.set(key, void 0);
  }
  pickNodeExactShape(point) {
    const match = this.contentGroup.pickNode(point.x, point.y);
    if (match && match.datum.missing !== true) {
      return { datum: match.datum, distance: 0 };
    }
    return void 0;
  }
  pickNodeClosestDatum(_point) {
    throw new Error("AG Charts - Series.pickNodeClosestDatum() not implemented");
  }
  pickNodeNearestDistantObject(point, items) {
    const match = nearestSquared(point.x, point.y, items);
    if (match.nearest !== void 0 && match.nearest.datum.missing !== true) {
      return { datum: match.nearest.datum, distance: Math.sqrt(match.distanceSquared) };
    }
    return void 0;
  }
  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {
    throw new Error("AG Charts - Series.pickNodeMainAxisFirst() not implemented");
  }
  fireNodeClickEvent(event, datum) {
    this.fireEvent(new this.NodeEvent("nodeClick", event, datum, this));
  }
  fireNodeDoubleClickEvent(event, datum) {
    this.fireEvent(new this.NodeEvent("nodeDoubleClick", event, datum, this));
  }
  createNodeContextMenuActionEvent(event, datum) {
    return new this.NodeEvent("nodeContextMenuAction", event, datum, this);
  }
  toggleSeriesItem(itemId, enabled) {
    this.visible = enabled;
    this.nodeDataRefresh = true;
    this._pickNodeCache.clear();
    this.dispatch("visibility-changed", { itemId, enabled });
  }
  isEnabled() {
    return this.visible;
  }
  getModuleMap() {
    return this.moduleMap;
  }
  createModuleContext() {
    return { ...this.ctx, series: this };
  }
  getLabelText(label, params, defaultFormatter = String) {
    if (label.formatter) {
      return this.ctx.callbackCache.call(label.formatter, { seriesId: this.id, ...params }) ?? defaultFormatter(params.value);
    }
    return defaultFormatter(params.value);
  }
  getMarkerStyle(marker, params, defaultStyle = marker.getStyle()) {
    const defaultSize = { size: params.datum.point?.size ?? 0 };
    const markerStyle = mergeDefaults(defaultSize, defaultStyle);
    if (marker.itemStyler) {
      const style = this.ctx.callbackCache.call(marker.itemStyler, {
        seriesId: this.id,
        ...markerStyle,
        ...params,
        datum: params.datum.datum
      });
      return mergeDefaults(style, markerStyle);
    }
    return markerStyle;
  }
  updateMarkerStyle(markerNode, marker, params, defaultStyle = marker.getStyle(), { applyTranslation = true, selected = true } = {}) {
    const { point } = params.datum;
    const activeStyle = this.getMarkerStyle(marker, params, defaultStyle);
    const visible = this.visible && activeStyle.size > 0 && point && !isNaN(point.x) && !isNaN(point.y);
    if (applyTranslation) {
      markerNode.setProperties({ visible, ...activeStyle, translationX: point?.x, translationY: point?.y });
    } else {
      markerNode.setProperties({ visible, ...activeStyle });
    }
    if (!selected) {
      markerNode.fillOpacity *= CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR;
      markerNode.strokeOpacity *= CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR;
    }
    if (typeof marker.shape === "function" && !markerNode.dirtyPath) {
      markerNode.path.clear(true);
      markerNode.updatePath();
      markerNode.checkPathDirty();
      const bb = markerNode.getBBox();
      if (point !== void 0 && bb.isFinite()) {
        const center = bb.computeCenter();
        const [dx, dy] = ["x", "y"].map(
          (key) => (activeStyle.strokeWidth ?? 0) + Math.abs(center[key] - point[key])
        );
        const customSize = Math.max(bb.width + dx, bb.height + dy);
        point.focusSize = customSize;
      }
    }
  }
  getMinRects(_width, _height) {
    return;
  }
  get nodeDataDependencies() {
    return this._nodeDataDependencies ?? { seriesRectWidth: NaN, seriesRectHeight: NaN };
  }
  checkResize(newSeriesRect) {
    const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect ?? { width: NaN, height: NaN };
    const newNodeDataDependencies = newSeriesRect ? { seriesRectWidth, seriesRectHeight } : void 0;
    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
    if (resize) {
      this._nodeDataDependencies = newNodeDataDependencies;
      this.markNodeDataDirty();
    }
    return resize;
  }
  pickFocus(_opts) {
    return void 0;
  }
};
Series.highlightedZIndex = 1e12;
__decorateClass([
  ActionOnSet({
    changeValue: function(newVal, oldVal) {
      this.onSeriesGroupingChange(oldVal, newVal);
    }
  })
], Series.prototype, "seriesGrouping", 2);

// packages/ag-charts-community/src/chart/keyboardUtil.ts
function computeCenter(bboxOrPath) {
  if (bboxOrPath == null)
    return;
  if (bboxOrPath instanceof BBox) {
    return bboxOrPath.computeCenter();
  }
  return Transformable.toCanvas(bboxOrPath).computeCenter();
}
function drawPickedFocus(focusIndicator, pick) {
  const { bounds, showFocusBox } = pick;
  if (showFocusBox) {
    focusIndicator?.updateBounds(bounds);
  }
}
function makeKeyboardPointerEvent(focusIndicator, pick) {
  drawPickedFocus(focusIndicator, pick);
  const { x: offsetX, y: offsetY } = computeCenter(pick.bounds) ?? {};
  if (offsetX !== void 0 && offsetY !== void 0) {
    return { type: "keyboard", offsetX, offsetY };
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/series/util.ts
function pickNode(inputSeries, point, intent, exactMatchOnly) {
  const reverseSeries = [...inputSeries].reverse();
  let result;
  for (const series of reverseSeries) {
    if (!series.visible || !series.rootGroup.visible) {
      continue;
    }
    const { match, distance: distance3 } = series.pickNode(point, intent, exactMatchOnly) ?? {};
    if (!match || distance3 == null) {
      continue;
    }
    if (!result || result.distance > distance3) {
      result = { series, distance: distance3, datum: match };
    }
    if (distance3 === 0) {
      break;
    }
  }
  return result;
}

// packages/ag-charts-community/src/chart/series/seriesAreaManager.ts
var SeriesAreaAriaLabel = class {
  constructor(element2, id) {
    this.element = element2;
    this.id = id;
    element2.id = id;
    element2.style.display = "none";
    setAttribute(element2.parentElement, "aria-labelledby", id);
  }
  layoutComplete(event) {
    this.element.parentElement.style.width = `${event.chart.width}px`;
    this.element.parentElement.style.height = `${event.chart.height}px`;
  }
  set text(text) {
    this.element.textContent = text;
  }
};
var SeriesAreaManager = class extends BaseManager {
  constructor(chart) {
    super();
    this.chart = chart;
    this.id = createId(this);
    this.series = [];
    this.highlight = {
      /** Last received event that still needs to be applied. */
      pendingHoverEvent: void 0,
      /** Last applied event. */
      appliedHoverEvent: void 0,
      /** Last applied event, which has been temporarily stashed during the main chart update cycle. */
      stashedHoverEvent: void 0
    };
    this.tooltip = {
      lastHover: void 0
    };
    /**
     * A11y Requirements for Tooltip/Highlight (see AG-13051 for details):
     *
     *   -   When the series-area is blurred, always the mouse to update the tooltip/highlight.
     *
     *   -   When the series-area receives a `focus` event, use `:focus-visible` to guess the input device.
     *       (this is decided by the browser).
     *
     *   -   For keyboard users, `focus` and `keydown` events always updates & shows the tooltip/highlight on
     *       the currently (or newly) focused datum.
     *
     *   -   For keyboard users, `mousemove` events update the tooltip/highlight iff `pickNode` finds a match
     *       for the mouse event offsets.
     */
    this.hoverDevice = "mouse";
    this.focus = {
      sortedSeries: [],
      series: void 0,
      seriesIndex: 0,
      datumIndex: 0,
      datum: void 0
    };
    this.hoverScheduler = debouncedAnimationFrame(() => {
      if (!this.tooltip.lastHover && !this.highlight.pendingHoverEvent)
        return;
      if (this.chart.getUpdateType() <= 4 /* SERIES_UPDATE */) {
        this.hoverScheduler.schedule();
        return;
      }
      if (this.highlight.pendingHoverEvent) {
        this.handleHoverHighlight(false);
      }
      if (this.tooltip.lastHover) {
        this.handleHoverTooltip(this.tooltip.lastHover, false);
      }
    });
    const seriesRegion = chart.ctx.regionManager.getRegion("series" /* SERIES */);
    const horizontalAxesRegion = chart.ctx.regionManager.getRegion("horizontal-axes" /* HORIZONTAL_AXES */);
    const verticalAxesRegion = chart.ctx.regionManager.getRegion("vertical-axes" /* VERTICAL_AXES */);
    const mouseMoveStates = 32 /* Default */ | 8 /* Annotations */ | 1 /* AnnotationsSelected */;
    const keyState = 32 /* Default */ | 2 /* Animation */;
    const labelEl = chart.ctx.domManager.addChild("series-area", "series-area-aria-label");
    this.ariaLabel = new SeriesAreaAriaLabel(labelEl, `${this.id}-aria-label`);
    this.destroyFns.push(
      () => chart.ctx.domManager.removeChild("series-area", "series-area-aria-label"),
      seriesRegion.addListener("contextmenu", (event) => this.onContextMenu(event), 63 /* All */),
      seriesRegion.addListener("drag", (event) => this.onHoverLikeEvent(event), mouseMoveStates),
      seriesRegion.addListener("hover", (event) => this.onHover(event), mouseMoveStates),
      seriesRegion.addListener("leave", () => this.onLeave(), mouseMoveStates),
      horizontalAxesRegion.addListener("hover", (event) => this.onHover(event), mouseMoveStates),
      horizontalAxesRegion.addListener("leave", () => this.onLeave()),
      verticalAxesRegion.addListener("hover", (event) => this.onHover(event), mouseMoveStates),
      verticalAxesRegion.addListener("leave", () => this.onLeave()),
      chart.ctx.animationManager.addListener("animation-start", () => this.clearAll()),
      chart.ctx.domManager.addListener("resize", () => this.clearAll()),
      chart.ctx.highlightManager.addListener("highlight-change", (event) => this.changeHighlightDatum(event)),
      chart.ctx.keyNavManager.addListener("blur", () => this.onBlur()),
      chart.ctx.keyNavManager.addListener("focus", (event) => this.onFocus(event), keyState),
      chart.ctx.keyNavManager.addListener("nav-hori", (event) => this.onNavHori(event), keyState),
      chart.ctx.keyNavManager.addListener("nav-vert", (event) => this.onNavVert(event), keyState),
      chart.ctx.keyNavManager.addListener("submit", (event) => this.onSubmit(event), keyState),
      chart.ctx.layoutManager.addListener("layout:complete", (event) => this.layoutComplete(event)),
      chart.ctx.regionManager.listenAll("click", (event) => this.onClick(event)),
      chart.ctx.regionManager.listenAll("dblclick", (event) => this.onClick(event)),
      chart.ctx.updateService.addListener("pre-scene-render", () => this.preSceneRender()),
      chart.ctx.zoomManager.addListener("zoom-change", () => this.clearAll()),
      chart.ctx.zoomManager.addListener("zoom-pan-start", () => this.clearAll())
    );
  }
  dataChanged() {
    var _a;
    (_a = this.highlight).stashedHoverEvent ?? (_a.stashedHoverEvent = this.highlight.appliedHoverEvent);
    this.chart.ctx.tooltipManager.removeTooltip(this.id);
    this.chart.ctx.focusIndicator.updateBounds(void 0);
    this.clearHighlight();
  }
  preSceneRender() {
    this.refreshFocus();
    if (this.highlight.stashedHoverEvent != null) {
      this.highlight.pendingHoverEvent = this.highlight.stashedHoverEvent;
      this.highlight.stashedHoverEvent = void 0;
      this.handleHoverHighlight(true);
    }
    if (this.tooltip.lastHover != null) {
      this.handleHoverTooltip(this.tooltip.lastHover, true);
    }
  }
  update(type, opts) {
    this.chart.ctx.updateService.update(type, opts);
  }
  seriesChanged(series) {
    this.focus.sortedSeries = [...series].sort((a, b) => {
      let fpA = a.properties.focusPriority ?? Infinity;
      let fpB = b.properties.focusPriority ?? Infinity;
      if (fpA === fpB) {
        [fpA, fpB] = [a._declarationOrder, b._declarationOrder];
      }
      if (fpA < fpB) {
        return -1;
      } else if (fpA > fpB) {
        return 1;
      }
      return 0;
    });
    this.series = series;
  }
  layoutComplete(event) {
    this.seriesRect = event.series.rect;
    this.hoverRect = event.series.paddedRect;
    this.ariaLabel.layoutComplete(event);
  }
  onContextMenu(event) {
    const { Default: Default2, ContextMenu } = InteractionState;
    let pickedNode;
    let position;
    if (this.chart.ctx.focusIndicator.isFocusVisible()) {
      pickedNode = this.chart.ctx.highlightManager.getActiveHighlight();
      if (pickedNode && this.seriesRect && pickedNode.midPoint) {
        position = Transformable.toCanvasPoint(
          pickedNode.series.contentGroup,
          pickedNode.midPoint.x,
          pickedNode.midPoint.y
        );
      }
    } else if (this.chart.ctx.interactionManager.getState() & (Default2 | ContextMenu)) {
      const match = pickNode(this.series, { x: event.regionOffsetX, y: event.regionOffsetY }, "context-menu");
      if (match) {
        this.chart.ctx.highlightManager.updateHighlight(this.id);
        pickedNode = match.datum;
      }
    }
    this.clearAll();
    this.chart.ctx.contextMenuRegistry.dispatchContext("series", event, { pickedNode }, position);
  }
  onLeave() {
    this.chart.ctx.cursorManager.updateCursor(this.id);
    if (!this.chart.ctx.focusIndicator.isFocusVisible())
      this.clearAll();
  }
  onHover(event) {
    this.hoverDevice = "mouse";
    this.onHoverLikeEvent(event);
  }
  onHoverLikeEvent(event) {
    if (excludesType(event, "drag")) {
      this.tooltip.lastHover = event;
    }
    this.highlight.pendingHoverEvent = event;
    this.hoverScheduler.schedule();
    if (this.chart.ctx.interactionManager.getState() === 32 /* Default */) {
      const { regionOffsetX, regionOffsetY } = event;
      const found = pickNode(this.series, { x: regionOffsetX, y: regionOffsetY }, "event");
      if (found?.series.hasEventListener("nodeClick") || found?.series.hasEventListener("nodeDoubleClick")) {
        this.chart.ctx.cursorManager.updateCursor(this.id, "pointer");
      } else {
        this.chart.ctx.cursorManager.updateCursor(this.id);
      }
    }
  }
  onClick(event) {
    this.hoverDevice = "mouse";
    this.onHoverLikeEvent(event);
    if (this.seriesRect?.containsPoint(event.offsetX, event.offsetY) && this.checkSeriesNodeClick(event)) {
      this.update(4 /* SERIES_UPDATE */);
      event.preventDefault();
      return;
    }
    const newEvent = { type: event.type === "click" ? "click" : "doubleClick", event: event.sourceEvent };
    this.chart.fireEvent(newEvent);
  }
  onFocus(event) {
    this.hoverDevice = this.chart.ctx.focusIndicator.isFocusVisible() ? "keyboard" : "mouse";
    this.handleFocus(0, 0);
    event.preventDefault();
  }
  onBlur() {
    this.hoverDevice = "mouse";
    this.clearAll();
  }
  onNavVert(event) {
    this.hoverDevice = "keyboard";
    this.focus.seriesIndex += event.delta;
    this.handleFocus(event.delta, 0);
    event.preventDefault();
  }
  onNavHori(event) {
    this.hoverDevice = "keyboard";
    this.focus.datumIndex += event.delta;
    this.handleFocus(0, event.delta);
    event.preventDefault();
  }
  onSubmit(event) {
    const { series, datum } = this.focus;
    const sourceEvent = event.sourceEvent.sourceEvent;
    if (series !== void 0 && datum !== void 0) {
      series.fireNodeClickEvent(sourceEvent, datum);
    } else {
      this.chart.fireEvent({
        type: "click",
        event: sourceEvent
      });
    }
    event.preventDefault();
  }
  checkSeriesNodeClick(event) {
    let point = { x: event.regionOffsetX, y: event.regionOffsetY };
    if (event.region !== "series") {
      point = Transformable.fromCanvasPoint(this.chart.seriesRoot, event.offsetX, event.offsetY);
    }
    const result = pickNode(this.series, point, "event");
    if (result == null)
      return false;
    if (event.type === "click") {
      result.series.fireNodeClickEvent(event.sourceEvent, result.datum);
      return true;
    }
    if (event.type === "dblclick") {
      event.preventZoomDblClick = result.distance === 0;
      result.series.fireNodeDoubleClickEvent(event.sourceEvent, result.datum);
      return true;
    }
    return false;
  }
  refreshFocus() {
    if (this.chart.ctx.focusIndicator.isFocusVisible()) {
      this.handleSeriesFocus(0, 0);
    }
  }
  handleFocus(seriesIndexDelta, datumIndexDelta) {
    const overlayFocus = this.chart.overlays.getFocusInfo(this.chart.ctx.localeManager);
    if (overlayFocus == null) {
      this.handleSeriesFocus(seriesIndexDelta, datumIndexDelta);
    } else {
      this.chart.ctx.focusIndicator.updateBounds(overlayFocus.rect);
    }
  }
  handleSeriesFocus(otherIndexDelta, datumIndexDelta) {
    if (this.chart.chartType === "hierarchy") {
      this.handleHierarchySeriesFocus(otherIndexDelta, datumIndexDelta);
      return;
    }
    const { focus, seriesRect } = this;
    const visibleSeries = focus.sortedSeries.filter((s) => s.visible);
    if (visibleSeries.length === 0)
      return;
    focus.seriesIndex = clamp(0, focus.seriesIndex, visibleSeries.length - 1);
    focus.series = visibleSeries[focus.seriesIndex];
    const { datumIndex, seriesIndex: otherIndex } = focus;
    const pick = focus.series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });
    this.updatePickedFocus(pick);
  }
  handleHierarchySeriesFocus(otherIndexDelta, datumIndexDelta) {
    this.focus.series = this.focus.sortedSeries[0];
    const {
      focus: { series, seriesIndex: otherIndex, datumIndex },
      seriesRect
    } = this;
    if (series === void 0)
      return;
    const pick = series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });
    this.updatePickedFocus(pick);
  }
  updatePickedFocus(pick) {
    const { focus } = this;
    if (pick === void 0 || focus.series === void 0)
      return;
    const { datum, datumIndex } = pick;
    focus.datumIndex = datumIndex;
    focus.datum = datum;
    if (this.chart.ctx.focusIndicator.isFocusVisible()) {
      this.chart.ctx.animationManager.reset();
    }
    const keyboardEvent = makeKeyboardPointerEvent(this.chart.ctx.focusIndicator, pick);
    if (keyboardEvent !== void 0 && this.hoverDevice === "keyboard") {
      this.tooltip.lastHover = void 0;
      this.highlight.appliedHoverEvent = void 0;
      this.highlight.pendingHoverEvent = void 0;
      this.highlight.stashedHoverEvent = void 0;
      const html = focus.series.getTooltipHtml(datum);
      const meta = TooltipManager.makeTooltipMeta(keyboardEvent, datum);
      this.chart.ctx.highlightManager.updateHighlight(this.id, datum);
      this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, html);
      this.ariaLabel.text = this.getDatumAriaText(datum, html);
    }
  }
  getDatumAriaText(datum, html) {
    const description = html.ariaLabel;
    return this.chart.ctx.localeManager.t("ariaAnnounceHoverDatum", {
      datum: datum.series.getDatumAriaText?.(datum, description) ?? description
    });
  }
  clearHighlight() {
    this.highlight.pendingHoverEvent = void 0;
    this.highlight.appliedHoverEvent = void 0;
    this.chart.ctx.highlightManager.updateHighlight(this.id);
  }
  clearTooltip() {
    this.chart.ctx.tooltipManager.removeTooltip(this.id);
    this.tooltip.lastHover = void 0;
  }
  clearAll() {
    this.clearHighlight();
    this.clearTooltip();
    this.chart.ctx.focusIndicator.updateBounds(void 0);
  }
  handleHoverHighlight(redisplay) {
    this.highlight.appliedHoverEvent = this.highlight.pendingHoverEvent;
    this.highlight.pendingHoverEvent = void 0;
    const event = this.highlight.appliedHoverEvent;
    if (!event)
      return;
    const state = this.chart.ctx.interactionManager.getState();
    if (state !== 32 /* Default */ && state !== 8 /* Annotations */ && state !== 1 /* AnnotationsSelected */)
      return;
    const { offsetX, offsetY } = event;
    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(offsetX, offsetY)) {
      this.clearHighlight();
      return;
    }
    let pickCoords = { x: event.regionOffsetX, y: event.regionOffsetY };
    if (event.region !== "series") {
      pickCoords = Transformable.fromCanvasPoint(this.chart.seriesRoot, offsetX, offsetY);
    }
    const { range: range3 } = this.chart.highlight;
    const intent = range3 === "tooltip" ? "highlight-tooltip" : "highlight";
    const found = pickNode(this.series, pickCoords, intent);
    if (found) {
      this.chart.ctx.highlightManager.updateHighlight(this.id, found.datum);
      this.hoverDevice = "mouse";
      return;
    }
    this.chart.ctx.highlightManager.updateHighlight(this.id);
  }
  handleHoverTooltip(event, redisplay) {
    const state = this.chart.ctx.interactionManager.getState();
    if (state !== 32 /* Default */ && state !== 8 /* Annotations */ && state !== 1 /* AnnotationsSelected */)
      return;
    const { offsetX, offsetY, targetElement, regionOffsetX, regionOffsetY } = event;
    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(offsetX, offsetY)) {
      if (this.hoverDevice == "mouse")
        this.clearTooltip();
      return;
    }
    if (targetElement && this.chart.tooltip.interactive && this.chart.ctx.domManager.isManagedChildDOMElement(targetElement, "canvas-overlay", DEFAULT_TOOLTIP_CLASS)) {
      return;
    }
    let pickCoords = { x: regionOffsetX, y: regionOffsetY };
    if (event.region !== "series") {
      pickCoords = Transformable.fromCanvasPoint(this.chart.seriesRoot, offsetX, offsetY);
    }
    const pick = pickNode(this.series, pickCoords, "tooltip");
    if (!pick) {
      if (this.hoverDevice == "mouse")
        this.clearTooltip();
      return;
    }
    this.hoverDevice = "mouse";
    const html = pick.series.getTooltipHtml(pick.datum);
    const tooltipEnabled = this.chart.tooltip.enabled && pick.series.tooltipEnabled;
    const shouldUpdateTooltip = tooltipEnabled && html != null;
    if (shouldUpdateTooltip) {
      const meta = TooltipManager.makeTooltipMeta(event, pick.datum);
      this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, html);
    }
  }
  changeHighlightDatum(event) {
    const seriesToUpdate = /* @__PURE__ */ new Set();
    const { series: newSeries = void 0, datum: newDatum } = event.currentHighlight ?? {};
    const { series: lastSeries = void 0, datum: lastDatum } = event.previousHighlight ?? {};
    if (lastSeries) {
      seriesToUpdate.add(lastSeries);
    }
    if (newSeries) {
      seriesToUpdate.add(newSeries);
    }
    if (lastSeries?.properties.cursor && lastDatum) {
      this.chart.ctx.cursorManager.updateCursor(lastSeries.id);
    }
    if (newSeries?.properties.cursor && newSeries?.properties.cursor !== "default" && newDatum) {
      this.chart.ctx.cursorManager.updateCursor(newSeries.id, newSeries.properties.cursor);
    }
    const updateAll = newSeries == null || lastSeries == null;
    if (updateAll) {
      this.update(4 /* SERIES_UPDATE */);
    } else {
      this.update(4 /* SERIES_UPDATE */, { seriesToUpdate });
    }
  }
};

// packages/ag-charts-community/src/chart/series/seriesLayerManager.ts
var SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;
var SeriesLayerManager = class {
  constructor(seriesRoot, highlightRoot, annotationRoot) {
    this.seriesRoot = seriesRoot;
    this.highlightRoot = highlightRoot;
    this.annotationRoot = annotationRoot;
    this.groups = {};
    this.series = {};
    this.expectedSeriesCount = 1;
    this.mode = "normal";
  }
  setSeriesCount(count) {
    this.expectedSeriesCount = count;
  }
  requestGroup(seriesConfig) {
    var _a, _b;
    const {
      internalId,
      type,
      rootGroup: seriesRootGroup,
      highlightGroup: seriesHighlightGroup,
      annotationGroup: seriesAnnotationGroup,
      seriesGrouping
    } = seriesConfig;
    const { groupIndex = internalId } = seriesGrouping ?? {};
    if (this.series[internalId] != null) {
      throw new Error(`AG Charts - series already has an allocated layer: ${this.series[internalId]}`);
    }
    if (Object.keys(this.series).length === 0) {
      this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? "aggressive-grouping" : "normal";
    }
    (_a = this.groups)[type] ?? (_a[type] = {});
    const lookupIndex = this.lookupIdx(groupIndex);
    const groupInfo = (_b = this.groups[type])[lookupIndex] ?? (_b[lookupIndex] = {
      type,
      id: lookupIndex,
      seriesIds: [],
      group: this.seriesRoot.appendChild(
        new Layer({
          name: `${type}-content`,
          zIndex: 4 /* SERIES_LAYER */,
          zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder("data")
        })
      ),
      highlight: this.highlightRoot.appendChild(
        new Group({
          name: `${type}-highlight`,
          zIndex: 4 /* SERIES_LAYER */,
          zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder("highlight")
        })
      ),
      annotation: this.annotationRoot.appendChild(
        new Group({
          name: `${type}-annotation`,
          zIndex: 4 /* SERIES_LAYER */,
          zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder("annotation")
        })
      )
    });
    this.series[internalId] = { layerState: groupInfo, seriesConfig };
    groupInfo.seriesIds.push(internalId);
    groupInfo.group.appendChild(seriesRootGroup);
    groupInfo.highlight.appendChild(seriesHighlightGroup);
    groupInfo.annotation.appendChild(seriesAnnotationGroup);
    return groupInfo.group;
  }
  changeGroup(seriesConfig) {
    const { internalId, seriesGrouping, type, rootGroup, highlightGroup, annotationGroup, oldGrouping } = seriesConfig;
    const { groupIndex = internalId } = seriesGrouping ?? {};
    if (this.groups[type]?.[groupIndex]?.seriesIds.includes(internalId)) {
      return;
    }
    if (this.series[internalId] != null) {
      this.releaseGroup({
        internalId,
        seriesGrouping: oldGrouping,
        type,
        rootGroup,
        highlightGroup,
        annotationGroup
      });
    }
    this.requestGroup(seriesConfig);
  }
  releaseGroup(seriesConfig) {
    const { internalId, rootGroup, highlightGroup, annotationGroup, type } = seriesConfig;
    if (this.series[internalId] == null) {
      throw new Error(`AG Charts - series doesn't have an allocated layer: ${internalId}`);
    }
    const groupInfo = this.series[internalId]?.layerState;
    if (groupInfo) {
      groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== internalId);
      groupInfo.group.removeChild(rootGroup);
      groupInfo.highlight.removeChild(highlightGroup);
      groupInfo.annotation.removeChild(annotationGroup);
    }
    if (groupInfo?.seriesIds.length === 0) {
      this.seriesRoot.removeChild(groupInfo.group);
      this.highlightRoot.removeChild(groupInfo.highlight);
      this.annotationRoot.removeChild(groupInfo.annotation);
      delete this.groups[groupInfo.type][groupInfo.id];
      delete this.groups[type][internalId];
    } else if (groupInfo?.seriesIds.length > 0) {
      const leadSeriesConfig = this.series[groupInfo?.seriesIds?.[0]]?.seriesConfig;
      groupInfo.group.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder("data");
      groupInfo.highlight.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder("highlight");
      groupInfo.annotation.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder("annotation");
    }
    delete this.series[internalId];
  }
  lookupIdx(groupIndex) {
    if (this.mode === "normal") {
      return groupIndex;
    }
    if (typeof groupIndex === "string") {
      groupIndex = Number(groupIndex.split("-").at(-1));
      if (!groupIndex) {
        return 0;
      }
    }
    return Math.floor(
      clamp(0, groupIndex / this.expectedSeriesCount, 1) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION
    );
  }
  destroy() {
    for (const groups of Object.values(this.groups)) {
      for (const groupInfo of Object.values(groups)) {
        this.seriesRoot.removeChild(groupInfo.group);
        this.highlightRoot.removeChild(groupInfo.highlight);
        this.annotationRoot.removeChild(groupInfo.annotation);
      }
    }
    this.groups = {};
    this.series = {};
  }
};

// packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts
var DataWindowProcessor = class {
  constructor(chart, dataService, updateService, zoomManager) {
    this.chart = chart;
    this.dataService = dataService;
    this.updateService = updateService;
    this.zoomManager = zoomManager;
    this.dirtyZoom = false;
    this.dirtyDataSource = false;
    this.lastAxisZooms = /* @__PURE__ */ new Map();
    this.destroyFns = [];
    this.destroyFns.push(
      this.dataService.addListener("data-source-change", () => this.onDataSourceChange()),
      this.dataService.addListener("data-load", () => this.onDataLoad()),
      this.dataService.addListener("data-error", () => this.onDataError()),
      this.updateService.addListener("update-complete", () => this.onUpdateComplete()),
      this.zoomManager.addListener("zoom-change", () => this.onZoomChange())
    );
  }
  destroy() {
    this.destroyFns.forEach((cb) => cb());
  }
  onDataLoad() {
    this.updateService.update(1 /* UPDATE_DATA */);
  }
  onDataError() {
    this.updateService.update(3 /* PERFORM_LAYOUT */);
  }
  onDataSourceChange() {
    this.dirtyDataSource = true;
  }
  onUpdateComplete() {
    if (!this.dirtyZoom && !this.dirtyDataSource)
      return;
    this.updateWindow().catch((e) => Logger.errorOnce(e));
  }
  onZoomChange() {
    this.dirtyZoom = true;
  }
  async updateWindow() {
    if (!this.dataService.isLazy())
      return;
    const axis = this.getValidAxis();
    let window2;
    let shouldRefresh = true;
    if (axis) {
      const zoom2 = this.zoomManager.getAxisZoom(axis.id);
      window2 = this.getAxisWindow(axis, zoom2);
      shouldRefresh = this.shouldRefresh(axis, zoom2);
    }
    this.dirtyZoom = false;
    this.dirtyDataSource = false;
    if (!shouldRefresh)
      return;
    this.dataService.load({ windowStart: window2?.min, windowEnd: window2?.max });
  }
  getValidAxis() {
    return this.chart.axes.find((axis) => axis.type === "time");
  }
  shouldRefresh(axis, zoom2) {
    if (this.dirtyDataSource)
      return true;
    if (!this.dirtyZoom)
      return false;
    const lastZoom = this.lastAxisZooms.get(axis.id);
    if (lastZoom && zoom2.min === lastZoom.min && zoom2.max === lastZoom.max) {
      return false;
    }
    this.lastAxisZooms.set(axis.id, zoom2);
    return true;
  }
  getAxisWindow(axis, zoom2) {
    const domain = axis.scale.getDomain?.();
    if (!zoom2 || !domain || domain.length === 0 || isNaN(Number(domain[0])))
      return;
    const diff2 = Number(domain[1]) - Number(domain[0]);
    const min = new Date(Number(domain[0]) + diff2 * zoom2.min);
    const max = new Date(Number(domain[0]) + diff2 * zoom2.max);
    return { min, max };
  }
};

// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts
var OverlaysProcessor = class {
  constructor(chartLike, overlays, dataService, layoutManager, localeManager, animationManager, domManager) {
    this.chartLike = chartLike;
    this.overlays = overlays;
    this.dataService = dataService;
    this.layoutManager = layoutManager;
    this.localeManager = localeManager;
    this.animationManager = animationManager;
    this.domManager = domManager;
    this.destroyFns = [];
    this.overlayElem = this.domManager.addChild("canvas-overlay", "overlay");
    this.overlayElem.role = "status";
    this.overlayElem.ariaAtomic = "false";
    this.overlayElem.ariaLive = "polite";
    this.overlayElem.classList.toggle(DEFAULT_OVERLAY_CLASS);
    this.destroyFns.push(this.layoutManager.addListener("layout:complete", (e) => this.onLayoutComplete(e)));
  }
  destroy() {
    this.destroyFns.forEach((cb) => cb());
    this.domManager.removeStyles("overlays");
    this.domManager.removeChild("canvas-overlay", "overlay");
  }
  onLayoutComplete({ series: { rect } }) {
    const isLoading = this.dataService.isLoading();
    const hasData = this.chartLike.series.some((s) => s.hasData);
    const anySeriesVisible = this.chartLike.series.some((s) => s.visible);
    if (this.overlays.darkTheme) {
      this.overlayElem.classList.add(DEFAULT_OVERLAY_DARK_CLASS);
    } else {
      this.overlayElem.classList.remove(DEFAULT_OVERLAY_DARK_CLASS);
    }
    this.overlayElem.style.left = `${rect.x}px`;
    this.overlayElem.style.top = `${rect.y}px`;
    this.overlayElem.style.width = `${rect.width}px`;
    this.overlayElem.style.height = `${rect.height}px`;
    const loadingShown = isLoading;
    const noDataShown = !isLoading && !hasData;
    const noVisibleSeriesShown = hasData && !anySeriesVisible;
    if (loadingShown) {
      this.showOverlay(this.overlays.loading, rect);
    } else {
      this.hideOverlay(this.overlays.loading);
    }
    if (noDataShown) {
      this.showOverlay(this.overlays.noData, rect);
    } else {
      this.hideOverlay(this.overlays.noData);
    }
    if (noVisibleSeriesShown) {
      this.showOverlay(this.overlays.noVisibleSeries, rect);
    } else {
      this.hideOverlay(this.overlays.noVisibleSeries);
    }
    const shown = loadingShown || noDataShown || noVisibleSeriesShown;
    setAttribute(this.overlayElem, "aria-hidden", !shown);
  }
  showOverlay(overlay, seriesRect) {
    const element2 = overlay.getElement(this.animationManager, this.localeManager, seriesRect);
    this.overlayElem.appendChild(element2);
  }
  hideOverlay(overlay) {
    overlay.removeElement(() => {
      this.overlayElem.innerText = "\xA0";
    }, this.animationManager);
  }
};

// packages/ag-charts-community/src/chart/chart.ts
var debug = Debug.create(true, "opts");
var SeriesArea = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.padding = new Padding(0);
  }
};
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], SeriesArea.prototype, "clip", 2);
__decorateClass([
  Validate(OBJECT)
], SeriesArea.prototype, "padding", 2);
var _Chart = class _Chart extends Observable {
  constructor(options, resources) {
    var _a;
    super();
    this.id = createId(this);
    this.seriesRoot = new TranslatableGroup({ name: `${this.id}-series-root` });
    this.highlightRoot = new TranslatableLayer({
      name: `${this.id}-highlight-root`,
      zIndex: 5 /* SERIES_HIGHLIGHT */,
      deriveZIndexFromChildren: true
      // TODO remove feature
    });
    this.annotationRoot = new TranslatableLayer({
      name: `${this.id}-annotation-root`,
      zIndex: 10 /* SERIES_ANNOTATION */
    });
    this.debug = Debug.create();
    this.extraDebugStats = {};
    this.data = [];
    this._firstAutoSize = true;
    this.padding = new Padding(20);
    this.seriesArea = new SeriesArea();
    this.keyboard = new Keyboard();
    this.mode = "standalone";
    this.chartCaptions = new ChartCaptions();
    this.destroyed = false;
    this._destroyFns = [];
    // Used to prevent infinite update loops when syncing charts.
    this.skipSync = false;
    this.chartAnimationPhase = "initial";
    this.modulesManager = new ModulesManager();
    this.processors = [];
    this.queuedUserOptions = [];
    this._pendingFactoryUpdatesCount = 0;
    this._performUpdateNoRenderCount = 0;
    this._performUpdateSkipAnimations = false;
    this.performUpdateType = 7 /* NONE */;
    this.updateShortcutCount = 0;
    this.seriesToUpdate = /* @__PURE__ */ new Set();
    this.updateMutex = new Mutex();
    this.updateRequestors = {};
    this.performUpdateTrigger = debouncedCallback(async ({ count }) => {
      if (this.destroyed)
        return;
      this.updateMutex.acquire(async () => {
        try {
          await this.performUpdate(count);
        } catch (error) {
          Logger.error("update error", error);
        }
      }).catch((e) => Logger.errorOnce(e));
    });
    this._performUpdateSplits = {};
    this.axes = [];
    this.series = [];
    this.onSeriesNodeClick = (event) => {
      this.fireEvent({ ...event, type: "seriesNodeClick" });
    };
    this.onSeriesNodeDoubleClick = (event) => {
      this.fireEvent({ ...event, type: "seriesNodeDoubleClick" });
    };
    this.seriesGroupingChanged = (event) => {
      if (!(event instanceof SeriesGroupingChangedEvent))
        return;
      const { series, seriesGrouping, oldGrouping } = event;
      if (series.rootGroup.isRoot())
        return;
      this.seriesLayerManager.changeGroup({
        internalId: series.internalId,
        type: series.type,
        rootGroup: series.rootGroup,
        highlightGroup: series.highlightGroup,
        annotationGroup: series.annotationGroup,
        getGroupZIndexSubOrder: (type) => series.getGroupZIndexSubOrder(type),
        seriesGrouping,
        oldGrouping
      });
    };
    this.chartOptions = options;
    const scene = resources?.scene;
    const container = resources?.container ?? options.processedOptions.container ?? void 0;
    const styleContainer = resources?.styleContainer ?? options.specialOverrides.styleContainer;
    const root = new Group({ name: "root" });
    const titleGroup = new Layer({ name: "titles", zIndex: 14 /* SERIES_LABEL */ });
    root.visible = false;
    root.append(titleGroup);
    root.append(this.seriesRoot);
    root.append(this.highlightRoot);
    root.append(this.annotationRoot);
    titleGroup.append(this.title.node);
    titleGroup.append(this.subtitle.node);
    titleGroup.append(this.footnote.node);
    this.tooltip = new Tooltip();
    this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot, this.highlightRoot, this.annotationRoot);
    this.mode = options.userOptions.mode ?? this.mode;
    const ctx = this.ctx = new ChartContext(this, {
      scene,
      root,
      container,
      styleContainer,
      syncManager: new SyncManager(this),
      pixelRatio: options.specialOverrides.overrideDevicePixelRatio,
      updateCallback: (type = 0 /* FULL */, opts) => this.update(type, opts),
      updateMutex: this.updateMutex
    });
    this._destroyFns.push(
      ctx.domManager.addListener("resize", () => this.parentResize(ctx.domManager.containerSize))
    );
    this.overlays = new ChartOverlays();
    (_a = this.overlays.loading).renderer ?? (_a.renderer = () => getLoadingSpinner(this.overlays.loading.getText(ctx.localeManager), ctx.animationManager.defaultDuration));
    this.processors = [
      new DataWindowProcessor(this, ctx.dataService, ctx.updateService, ctx.zoomManager),
      new OverlaysProcessor(
        this,
        this.overlays,
        ctx.dataService,
        ctx.layoutManager,
        ctx.localeManager,
        ctx.animationManager,
        ctx.domManager
      )
    ];
    this.highlight = new ChartHighlight();
    this.container = container;
    const moduleContext = this.getModuleContext();
    ctx.regionManager.addRegion(
      "series" /* SERIES */,
      this.seriesRoot,
      new SimpleRegionBBoxProvider(this.seriesRoot, () => this.seriesRect ?? BBox.zero),
      this.ctx.axisManager.axisGridGroup
    );
    ctx.regionManager.addRegion("horizontal-axes" /* HORIZONTAL_AXES */);
    ctx.regionManager.addRegion("vertical-axes" /* VERTICAL_AXES */);
    ctx.regionManager.addRegion("root", root);
    ctx.domManager.setDataBoolean("animating", false);
    this.seriesAreaManager = new SeriesAreaManager(this.initSeriesAreaDependencies());
    this._destroyFns.push(
      ctx.layoutManager.registerElement(0 /* Caption */, (e) => {
        e.layoutBox.shrink(this.padding.toJson());
        this.chartCaptions.positionCaptions(e);
      }),
      ctx.layoutManager.addListener("layout:complete", (e) => this.chartCaptions.positionAbsoluteCaptions(e)),
      ctx.dataService.addListener("data-load", (event) => {
        this.data = event.data;
      }),
      this.title.registerInteraction(moduleContext, "beforebegin"),
      this.subtitle.registerInteraction(moduleContext, "beforebegin"),
      this.footnote.registerInteraction(moduleContext, "afterend"),
      ctx.interactionManager.addListener("page-left", () => this.destroy()),
      ctx.animationManager.addListener("animation-frame", () => {
        this.update(6 /* SCENE_RENDER */);
      }),
      ctx.animationManager.addListener("animation-start", () => ctx.domManager.setDataBoolean("animating", true)),
      ctx.animationManager.addListener("animation-stop", () => ctx.domManager.setDataBoolean("animating", false)),
      ctx.zoomManager.addListener("zoom-change", () => {
        this.series.forEach((s) => s.animationState?.transition("updateData"));
        const skipAnimations = this.chartAnimationPhase !== "initial";
        this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });
      })
    );
    this.parentResize(ctx.domManager.containerSize);
  }
  static getInstance(element2) {
    return _Chart.chartsInstances.get(element2);
  }
  /** NOTE: This is exposed for use by Integrated charts only. */
  get canvasElement() {
    return this.ctx.scene.canvas.element;
  }
  download(fileName, fileFormat) {
    this.ctx.scene.download(fileName, fileFormat);
  }
  getCanvasDataURL(fileFormat) {
    return this.ctx.scene.getDataURL(fileFormat);
  }
  toSVG() {
    return this.ctx.scene.toSVG();
  }
  getOptions() {
    return this.queuedUserOptions.at(-1) ?? this.chartOptions.userOptions;
  }
  initSeriesAreaDependencies() {
    const { ctx, tooltip, highlight, overlays, seriesRoot } = this;
    const chartType2 = this.getChartType();
    const fireEvent = this.fireEvent.bind(this);
    const getUpdateType = () => this.performUpdateType;
    return { fireEvent, getUpdateType, chartType: chartType2, ctx, tooltip, highlight, overlays, seriesRoot };
  }
  getModuleContext() {
    return this.ctx;
  }
  getCaptionText() {
    return [this.title, this.subtitle, this.footnote].filter((caption) => caption.enabled && caption.text).map((caption) => caption.text).join(". ");
  }
  getAriaLabel() {
    return this.ctx.localeManager.t("ariaAnnounceChart", { seriesCount: this.series.length });
  }
  resetAnimations() {
    this.chartAnimationPhase = "initial";
    for (const series of this.series) {
      series.resetAnimation(this.chartAnimationPhase);
    }
    for (const axis of this.axes) {
      axis.resetAnimation(this.chartAnimationPhase);
    }
    this.animationRect = void 0;
    this.ctx.animationManager.reset();
  }
  skipAnimations() {
    this.ctx.animationManager.skipCurrentBatch();
    this._performUpdateSkipAnimations = true;
  }
  destroy(opts) {
    if (this.destroyed) {
      return;
    }
    const keepTransferableResources = opts?.keepTransferableResources;
    let result;
    this.performUpdateType = 7 /* NONE */;
    this._destroyFns.forEach((fn) => fn());
    this.processors.forEach((p) => p.destroy());
    this.tooltip.destroy(this.ctx.domManager);
    this.overlays.destroy();
    this.modulesManager.destroy();
    if (keepTransferableResources) {
      this.ctx.scene.strip();
      result = {
        container: this.container,
        scene: this.ctx.scene
      };
    } else {
      this.ctx.scene.destroy();
      this.container = void 0;
    }
    this.destroySeries(this.series);
    this.seriesLayerManager.destroy();
    this.axes.forEach((a) => a.destroy());
    this.axes = [];
    this.animationRect = void 0;
    this.ctx.destroy();
    this.destroyed = true;
    Object.freeze(this);
    return result;
  }
  requestFactoryUpdate(cb) {
    if (this.destroyed)
      return;
    this._pendingFactoryUpdatesCount++;
    this.updateMutex.acquire(async () => {
      if (this.destroyed)
        return;
      await cb(this);
      if (this.destroyed)
        return;
      this._pendingFactoryUpdatesCount--;
    }).catch((e) => Logger.errorOnce(e));
  }
  update(type = 0 /* FULL */, opts) {
    const {
      forceNodeDataRefresh = false,
      skipAnimations,
      seriesToUpdate = this.series,
      newAnimationBatch
    } = opts ?? {};
    if (forceNodeDataRefresh) {
      this.series.forEach((series) => series.markNodeDataDirty());
    }
    for (const series of seriesToUpdate) {
      this.seriesToUpdate.add(series);
    }
    if (skipAnimations) {
      this.ctx.animationManager.skipCurrentBatch();
      this._performUpdateSkipAnimations = true;
    }
    if (newAnimationBatch && this.ctx.animationManager.isActive()) {
      this._performUpdateSkipAnimations = true;
    }
    this.skipSync = opts?.skipSync ?? false;
    if (this.debug.check()) {
      let stack = new Error().stack ?? "<unknown>";
      stack = stack.replace(/\([^)]*/g, "");
      this.updateRequestors[stack] = type;
    }
    if (type < this.performUpdateType) {
      this.performUpdateType = type;
      this.ctx.domManager.setDataBoolean("updatePending", true);
      this.performUpdateTrigger.schedule(opts?.backOffMs);
    }
  }
  async performUpdate(count) {
    const { performUpdateType, extraDebugStats, _performUpdateSplits: splits, ctx } = this;
    const seriesToUpdate = [...this.seriesToUpdate];
    this.performUpdateType = 7 /* NONE */;
    this.seriesToUpdate.clear();
    if (this.updateShortcutCount === 0 && performUpdateType < 6 /* SCENE_RENDER */) {
      ctx.animationManager.startBatch(this._performUpdateSkipAnimations);
      ctx.animationManager.onBatchStop(() => this.chartAnimationPhase = "ready");
    }
    this.debug("Chart.performUpdate() - start", ChartUpdateType[performUpdateType]);
    let previousSplit = performance.now();
    splits.start ?? (splits.start = previousSplit);
    const updateSplits = (splitName) => {
      splits[splitName] ?? (splits[splitName] = 0);
      splits[splitName] += performance.now() - previousSplit;
      previousSplit = performance.now();
    };
    let updateDeferred = false;
    switch (performUpdateType) {
      case 0 /* FULL */:
        this.ctx.updateService.dispatchPreDomUpdate();
        this.updateDOM();
      case 1 /* UPDATE_DATA */:
        await this.updateData();
        updateSplits("\u2B07\uFE0F");
      case 2 /* PROCESS_DATA */:
        await this.processData();
        this.seriesAreaManager.dataChanged();
        updateSplits("\u{1F3ED}");
      case 3 /* PERFORM_LAYOUT */:
        if (this.checkUpdateShortcut(3 /* PERFORM_LAYOUT */))
          break;
        if (!this.checkFirstAutoSize(seriesToUpdate)) {
          updateDeferred = true;
          break;
        }
        await this.processLayout();
        updateSplits("\u2316");
      case 4 /* SERIES_UPDATE */: {
        if (this.checkUpdateShortcut(4 /* SERIES_UPDATE */))
          break;
        const { seriesRect } = this;
        await Promise.all(seriesToUpdate.map((series) => series.update({ seriesRect })));
        updateSplits("\u{1F914}");
        this.updateAriaLabels();
      }
      case 5 /* PRE_SCENE_RENDER */:
        if (this.checkUpdateShortcut(5 /* PRE_SCENE_RENDER */))
          break;
        ctx.updateService.dispatchPreSceneRender(this.getMinRects());
        updateSplits("\u2196");
      case 6 /* SCENE_RENDER */:
        if (this.checkUpdateShortcut(6 /* SCENE_RENDER */))
          break;
        ctx.animationManager.endBatch();
        extraDebugStats["updateShortcutCount"] = this.updateShortcutCount;
        await ctx.scene.render({ debugSplitTimes: splits, extraDebugStats, seriesRect: this.seriesRect });
        this.extraDebugStats = {};
        for (const key in splits) {
          delete splits[key];
        }
        this.ctx.domManager.incrementDataCounter("sceneRenders");
      case 7 /* NONE */:
        this.updateShortcutCount = 0;
        this.updateRequestors = {};
        this._performUpdateSkipAnimations = false;
        ctx.animationManager.endBatch();
    }
    if (!updateDeferred) {
      ctx.updateService.dispatchUpdateComplete(this.getMinRects());
      this.ctx.domManager.setDataBoolean("updatePending", false);
    }
    const end = performance.now();
    this.debug("Chart.performUpdate() - end", {
      chart: this,
      durationMs: Math.round((end - splits["start"]) * 100) / 100,
      count,
      performUpdateType: ChartUpdateType[performUpdateType]
    });
  }
  updateThemeClassName() {
    const { theme } = this.chartOptions.processedOptions;
    const themeClassNamePrefix = "ag-charts-theme-";
    const validThemeClassNames = [`${themeClassNamePrefix}default`, `${themeClassNamePrefix}default-dark`];
    let themeClassName = validThemeClassNames[0];
    let isDark = false;
    if (typeof theme === "string") {
      themeClassName = theme.replace("ag-", themeClassNamePrefix);
      isDark = theme.includes("-dark");
    } else if (typeof theme?.baseTheme === "string") {
      themeClassName = theme.baseTheme.replace("ag-", themeClassNamePrefix);
      isDark = theme.baseTheme.includes("-dark");
    }
    if (!validThemeClassNames.includes(themeClassName)) {
      themeClassName = isDark ? validThemeClassNames[1] : validThemeClassNames[0];
    }
    this.ctx.domManager.setThemeClass(themeClassName);
  }
  updateDOM() {
    this.updateThemeClassName();
    const { enabled, tabIndex } = this.keyboard;
    this.ctx.domManager.setTabIndex(enabled ? tabIndex ?? 0 : -1);
  }
  updateAriaLabels() {
    this.ctx.domManager.updateCanvasLabel(this.getAriaLabel());
  }
  checkUpdateShortcut(checkUpdateType) {
    const maxShortcuts = 3;
    if (this.updateShortcutCount > maxShortcuts) {
      Logger.warn(
        `exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`,
        this.updateRequestors
      );
      return false;
    }
    if (this.performUpdateType <= checkUpdateType) {
      this.updateShortcutCount++;
      return true;
    }
    return false;
  }
  checkFirstAutoSize(seriesToUpdate) {
    if (this.width != null && this.height != null) {
    } else if (!this._lastAutoSize) {
      const count = this._performUpdateNoRenderCount++;
      const backOffMs = (count + 1) ** 2 * 40;
      if (count < 8) {
        this.update(3 /* PERFORM_LAYOUT */, { seriesToUpdate, backOffMs });
        this.debug("Chart.checkFirstAutoSize() - backing off until first size update", backOffMs);
        return false;
      }
      this.debug("Chart.checkFirstAutoSize() - timeout for first size update.");
    }
    this._performUpdateNoRenderCount = 0;
    return true;
  }
  onAxisChange(newValue, oldValue) {
    if (oldValue == null && newValue.length === 0)
      return;
    this.ctx.axisManager.updateAxes(oldValue ?? [], newValue);
  }
  onSeriesChange(newValue, oldValue) {
    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];
    this.destroySeries(seriesToDestroy);
    this.seriesLayerManager?.setSeriesCount(newValue.length);
    for (const series of newValue) {
      if (oldValue?.includes(series))
        continue;
      if (series.rootGroup.isRoot()) {
        this.seriesLayerManager.requestGroup(series);
      }
      const chart = this;
      series.chart = {
        get mode() {
          return chart.mode;
        },
        get isMiniChart() {
          return false;
        },
        get seriesRect() {
          return chart.seriesRect;
        },
        placeLabels(padding) {
          return chart.placeLabels(padding);
        }
      };
      series.resetAnimation(this.chartAnimationPhase);
      this.addSeriesListeners(series);
      series.addChartEventListeners();
    }
    this.seriesAreaManager?.seriesChanged(newValue);
  }
  destroySeries(allSeries) {
    allSeries?.forEach((series) => {
      series.removeEventListener("nodeClick", this.onSeriesNodeClick);
      series.removeEventListener("nodeDoubleClick", this.onSeriesNodeDoubleClick);
      series.removeEventListener("groupingChanged", this.seriesGroupingChanged);
      series.destroy();
      this.seriesLayerManager.releaseGroup(series);
      series.chart = void 0;
    });
  }
  addSeriesListeners(series) {
    if (this.hasEventListener("seriesNodeClick")) {
      series.addEventListener("nodeClick", this.onSeriesNodeClick);
    }
    if (this.hasEventListener("seriesNodeDoubleClick")) {
      series.addEventListener("nodeDoubleClick", this.onSeriesNodeDoubleClick);
    }
    series.addEventListener("groupingChanged", this.seriesGroupingChanged);
  }
  assignSeriesToAxes() {
    for (const axis of this.axes) {
      axis.boundSeries = this.series.filter((s) => s.axes[axis.direction] === axis);
    }
  }
  assignAxesToSeries() {
    const directionToAxesMap = groupBy(this.axes, (axis) => axis.direction);
    this.series.forEach((series) => {
      series.directions.forEach((direction) => {
        const directionAxes = directionToAxesMap[direction];
        if (!directionAxes) {
          Logger.warnOnce(
            `no available axis for direction [${direction}]; check series and axes configuration.`
          );
          return;
        }
        const seriesKeys = series.getKeys(direction);
        const newAxis = directionAxes.find(
          (axis) => !axis.keys.length || seriesKeys.some((key) => axis.keys.includes(key))
        );
        if (!newAxis) {
          Logger.warnOnce(
            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`
          );
          return;
        }
        series.axes[direction] = newAxis;
      });
    });
  }
  parentResize(size) {
    if (size == null || this.width != null && this.height != null)
      return;
    let { width, height } = size;
    width = Math.floor(width);
    height = Math.floor(height);
    if (width === 0 && height === 0)
      return;
    const [autoWidth = 0, authHeight = 0] = this._lastAutoSize ?? [];
    if (autoWidth === width && authHeight === height)
      return;
    this._lastAutoSize = [width, height];
    this.resize("SizeMonitor", {});
  }
  resize(source, opts) {
    const { scene, animationManager } = this.ctx;
    const { inWidth, inHeight, inMinWidth, inMinHeight } = opts;
    this.ctx.domManager.setSizeOptions(
      inMinWidth ?? this.minWidth,
      inMinHeight ?? this.minHeight,
      inWidth ?? this.width,
      inHeight ?? this.height
    );
    const width = inWidth ?? this.width ?? this._lastAutoSize?.[0];
    const height = inHeight ?? this.height ?? this._lastAutoSize?.[1];
    this.debug(`Chart.resize() from ${source}`, { width, height, stack: new Error().stack });
    if (width == null || height == null || !isFiniteNumber(width) || !isFiniteNumber(height))
      return;
    if (scene.resize(width, height)) {
      animationManager.reset();
      let skipAnimations = true;
      if ((this.width == null || this.height == null) && this._firstAutoSize) {
        skipAnimations = false;
        this._firstAutoSize = false;
      }
      this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });
    }
  }
  async updateData() {
    this.series.forEach((s) => s.setChartData(this.data));
    const modulePromises = this.modulesManager.mapModules((m) => m.updateData?.(this.data));
    await Promise.all(modulePromises);
  }
  async processData() {
    if (this.series.some((s) => s.canHaveAxes)) {
      this.assignAxesToSeries();
      this.assignSeriesToAxes();
    }
    const dataController = new DataController(this.mode);
    const seriesPromises = this.series.map((s) => s.processData(dataController));
    const modulePromises = this.modulesManager.mapModules((m) => m.processData?.(dataController));
    dataController.execute();
    await Promise.all([...seriesPromises, ...modulePromises]);
    for (const { legendType, legend } of this.modulesManager.legends()) {
      legend.data = this.getLegendData(legendType, this.mode !== "integrated");
    }
  }
  placeLabels(padding) {
    const visibleSeries = [];
    const data = [];
    for (const series of this.series) {
      if (!series.visible)
        continue;
      const labelData = series.getLabelData();
      if (isPointLabelDatum(labelData?.[0])) {
        data.push(labelData);
        visibleSeries.push(series);
      }
    }
    const { seriesRect } = this;
    const { top, right, bottom, left } = this.seriesArea.padding;
    const labels = seriesRect && data.length > 0 ? placeLabels(
      data,
      {
        x: -left,
        y: -top,
        width: seriesRect.width + left + right,
        height: seriesRect.height + top + bottom
      },
      padding
    ) : [];
    return new Map(labels.map((l, i) => [visibleSeries[i], l]));
  }
  getLegendData(legendType, warnConflicts) {
    var _a;
    const legendData = this.series.filter((s) => s.properties.showInLegend).flatMap((s) => s.getLegendData(legendType));
    const isCategoryLegendData = (data) => data.every((d) => d.legendType === "category");
    if (warnConflicts && isCategoryLegendData(legendData)) {
      const seriesMarkerFills = {};
      const seriesTypeMap = new Map(this.series.map((s) => [s.id, s.type]));
      for (const {
        seriesId,
        symbols: [{ marker }],
        label
      } of legendData) {
        if (marker.fill == null)
          continue;
        const seriesType2 = seriesTypeMap.get(seriesId);
        const markerFill = seriesMarkerFills[seriesType2] ?? (seriesMarkerFills[seriesType2] = {});
        markerFill[_a = label.text] ?? (markerFill[_a] = marker.fill);
        if (markerFill[label.text] !== marker.fill) {
          Logger.warnOnce(
            `legend item '${label.text}' has multiple fill colors, this may cause unexpected behaviour.`
          );
        }
      }
    }
    return legendData;
  }
  async processLayout() {
    const oldRect = this.animationRect;
    const { width, height } = this.ctx.scene;
    const ctx = this.ctx.layoutManager.createContext(width, height);
    await this.performLayout(ctx);
    if (oldRect && !this.animationRect?.equals(oldRect)) {
      this.ctx.animationManager.skipCurrentBatch();
    }
    this.debug("Chart.performUpdate() - seriesRect", this.seriesRect);
  }
  async waitForUpdate(timeoutMs = 1e4, failOnTimeout = false) {
    const start = performance.now();
    if (this._pendingFactoryUpdatesCount > 0) {
      await this.updateMutex.waitForClearAcquireQueue();
    }
    while (this.performUpdateType !== 7 /* NONE */) {
      if (performance.now() - start > timeoutMs) {
        const message = `Chart.waitForUpdate() timeout of ${timeoutMs} reached - first chart update taking too long.`;
        if (failOnTimeout) {
          throw new Error(message);
        } else {
          Logger.warnOnce(message);
        }
      }
      await sleep(50);
    }
    await this.updateMutex.waitForClearAcquireQueue();
  }
  getMinRects() {
    const { width, height } = this.ctx.scene;
    const minRects = this.series.map((series) => series.getMinRects(width, height)).filter(isDefined);
    if (minRects.length === 0)
      return;
    let maxWidth = 0;
    let maxHeight = 0;
    let maxVisibleWidth = 0;
    let maxVisibleHeight = 0;
    for (const { minRect: minRect2, minVisibleRect: minVisibleRect2 } of minRects) {
      maxWidth = Math.max(maxWidth, minRect2.width);
      maxHeight = Math.max(maxHeight, minRect2.height);
      maxVisibleWidth = Math.max(maxVisibleWidth, minVisibleRect2.width);
      maxVisibleHeight = Math.max(maxVisibleHeight, minVisibleRect2.height);
    }
    const minRect = new BBox(0, 0, maxWidth, maxHeight);
    let minVisibleRect = minRect.clone();
    if (maxVisibleWidth > 0 && maxVisibleHeight > 0) {
      minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);
    }
    return { minRect, minVisibleRect };
  }
  filterMiniChartSeries(series) {
    return series?.filter((s) => s.showInMiniChart !== false);
  }
  applyOptions(newChartOptions) {
    const isDifferentOpts = newChartOptions !== this.chartOptions;
    const oldOpts = isDifferentOpts ? this.chartOptions.processedOptions : {};
    const newOpts = newChartOptions.processedOptions;
    const deltaOptions = newChartOptions.diffOptions(oldOpts);
    if (deltaOptions == null)
      return;
    debug("Chart.applyOptions() - applying delta", deltaOptions);
    const modulesChanged = this.applyModules(newOpts);
    const skip = [
      "type",
      "data",
      "series",
      "listeners",
      "preset",
      "theme",
      "legend.listeners",
      "navigator.miniChart.series",
      "navigator.miniChart.label",
      "locale.localeText",
      "axes",
      "topology",
      "nodes",
      "initialState",
      "styleContainer"
    ];
    if (deltaOptions.listeners) {
      this.registerListeners(this, deltaOptions.listeners);
    }
    jsonApply(this, deltaOptions, { skip });
    let forceNodeDataRefresh = false;
    let seriesStatus = "no-op";
    if (deltaOptions.series != null) {
      seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts?.series);
      forceNodeDataRefresh = true;
    }
    if (seriesStatus === "replaced") {
      this.resetAnimations();
    }
    if (this.applyAxes(this, newOpts, oldOpts, seriesStatus, [], true)) {
      forceNodeDataRefresh = true;
    }
    if (deltaOptions.data) {
      this.data = deltaOptions.data;
    }
    if (deltaOptions.legend?.listeners && this.modulesManager.isEnabled("legend")) {
      Object.assign(this.legend.listeners, deltaOptions.legend.listeners);
    }
    if (deltaOptions.locale?.localeText) {
      this.modulesManager.getModule("locale").localeText = deltaOptions.locale?.localeText;
    }
    this.chartOptions = newChartOptions;
    const navigatorModule = this.modulesManager.getModule("navigator");
    const zoomModule = this.modulesManager.getModule("zoom");
    if (!navigatorModule?.enabled && !zoomModule?.enabled) {
      this.ctx.zoomManager.updateZoom("chart");
    }
    const miniChart = navigatorModule?.miniChart;
    const miniChartSeries = newOpts.navigator?.miniChart?.series ?? newOpts.series;
    if (miniChart?.enabled === true && miniChartSeries != null) {
      this.applyMiniChartOptions(miniChart, miniChartSeries, newOpts, oldOpts);
    } else if (miniChart?.enabled === false) {
      miniChart.series = [];
      miniChart.axes = [];
    }
    this.ctx.annotationManager.setAnnotationStyles(newChartOptions.annotationThemes);
    forceNodeDataRefresh || (forceNodeDataRefresh = this.shouldForceNodeDataRefresh(deltaOptions, seriesStatus));
    const majorChange = forceNodeDataRefresh || modulesChanged;
    const updateType = majorChange ? 0 /* FULL */ : 3 /* PERFORM_LAYOUT */;
    this.maybeResetAnimations(seriesStatus);
    debug("Chart.applyOptions() - update type", ChartUpdateType[updateType], {
      seriesStatus,
      forceNodeDataRefresh
    });
    this.update(updateType, { forceNodeDataRefresh, newAnimationBatch: true });
    if (deltaOptions.initialState || deltaOptions.theme) {
      this.applyInitialState(newChartOptions.userOptions.initialState);
    }
  }
  applyInitialState(initialState) {
    const {
      ctx: { annotationManager, historyManager, stateManager }
    } = this;
    if (initialState?.annotations != null) {
      const annotations2 = initialState.annotations.map((annotation) => {
        const annotationTheme = annotationManager.getAnnotationTypeStyles(annotation.type);
        return mergeDefaults(annotation, annotationTheme);
      });
      stateManager.setState(annotationManager, annotations2);
    }
    if (initialState != null) {
      historyManager.clear();
    }
  }
  maybeResetAnimations(seriesStatus) {
    if (this.mode !== "standalone")
      return;
    switch (seriesStatus) {
      case "series-grouping-change":
      case "replaced":
        this.resetAnimations();
        break;
      default:
    }
  }
  shouldForceNodeDataRefresh(deltaOptions, seriesStatus) {
    const seriesDataUpdate = !!deltaOptions.data || seriesStatus === "data-change" || seriesStatus === "replaced";
    const legendKeys = legendRegistry.getKeys();
    const optionsHaveLegend = Object.values(legendKeys).some(
      (legendKey) => deltaOptions[legendKey] != null
    );
    const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null;
    return seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;
  }
  applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts) {
    const oldSeries = oldOpts?.navigator?.miniChart?.series ?? oldOpts?.series;
    const miniChartSeriesStatus = this.applySeries(
      miniChart,
      this.filterMiniChartSeries(miniChartSeries),
      this.filterMiniChartSeries(oldSeries)
    );
    this.applyAxes(miniChart, completeOptions, oldOpts, miniChartSeriesStatus, [
      "axes[].tick",
      "axes[].thickness",
      "axes[].title",
      "axes[].crosshair",
      "axes[].gridLine",
      "axes[].label"
    ]);
    const series = miniChart.series;
    for (const s of series) {
      s.properties.id = void 0;
    }
    const axes = miniChart.axes;
    const horizontalAxis = axes.find((axis) => axis.direction === "x" /* X */);
    for (const axis of axes) {
      axis.gridLine.enabled = false;
      axis.label.enabled = axis === horizontalAxis;
      axis.tick.enabled = false;
      axis.interactionEnabled = false;
    }
    if (horizontalAxis != null) {
      const miniChartOpts = completeOptions.navigator?.miniChart;
      const labelOptions = miniChartOpts?.label;
      const intervalOptions = miniChartOpts?.label?.interval;
      horizontalAxis.line.enabled = false;
      horizontalAxis.label.set(
        without(labelOptions, ["interval", "rotation", "minSpacing", "autoRotate", "autoRotateAngle"])
      );
      horizontalAxis.tick.set(
        without(intervalOptions, ["enabled", "width", "size", "color", "interval", "step"])
      );
      const step = intervalOptions?.step;
      if (step != null) {
        horizontalAxis.interval.step = step;
      }
    }
  }
  applyModules(options) {
    const { type: chartType2 } = this.constructor;
    let modulesChanged = false;
    for (const module2 of moduleRegistry.byType("root", "legend")) {
      const isConfigured = options[module2.optionsKey] != null;
      const shouldBeEnabled = isConfigured && module2.chartTypes.includes(chartType2);
      if (shouldBeEnabled === this.modulesManager.isEnabled(module2))
        continue;
      if (shouldBeEnabled) {
        this.modulesManager.addModule(module2, (m) => m.moduleFactory(this.getModuleContext()));
        if (module2.type === "legend") {
          this.modulesManager.getModule(module2)?.attachLegend(this.ctx.scene);
        }
        this[module2.optionsKey] = this.modulesManager.getModule(module2);
      } else {
        this.modulesManager.removeModule(module2);
        delete this[module2.optionsKey];
      }
      modulesChanged = true;
    }
    return modulesChanged;
  }
  initSeriesDeclarationOrder(series) {
    for (let idx = 0; idx < series.length; idx++) {
      series[idx]._declarationOrder = idx;
    }
  }
  applySeries(chart, optSeries, oldOptSeries) {
    if (!optSeries) {
      return "no-change";
    }
    const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);
    if (matchResult.status === "no-overlap") {
      debug(`Chart.applySeries() - creating new series instances, status: ${matchResult.status}`, matchResult);
      chart.series = optSeries.map((opts) => this.createSeries(opts));
      this.initSeriesDeclarationOrder(chart.series);
      return "replaced";
    }
    debug(`Chart.applySeries() - matchResult`, matchResult);
    const seriesInstances = [];
    let dataChanged = false;
    let groupingChanged = false;
    let isUpdated = false;
    for (const change of matchResult.changes) {
      groupingChanged || (groupingChanged = change.status === "series-grouping");
      dataChanged || (dataChanged = change.diff?.data != null);
      isUpdated || (isUpdated = change.status !== "no-op");
      switch (change.status) {
        case "add": {
          const newSeries = this.createSeries(change.opts);
          seriesInstances.push(newSeries);
          debug(`Chart.applySeries() - created new series`, newSeries);
          break;
        }
        case "remove":
          debug(`Chart.applySeries() - removing series at previous idx ${change.idx}`, change.series);
          break;
        case "no-op":
          seriesInstances.push(change.series);
          debug(`Chart.applySeries() - no change to series at previous idx ${change.idx}`, change.series);
          break;
        case "series-grouping":
        case "update":
        default: {
          const { series, diff: diff2, idx } = change;
          debug(`Chart.applySeries() - applying series diff previous idx ${idx}`, diff2, series);
          this.applySeriesValues(series, diff2);
          series.markNodeDataDirty();
          seriesInstances.push(series);
        }
      }
    }
    this.initSeriesDeclarationOrder(seriesInstances);
    debug(`Chart.applySeries() - final series instances`, seriesInstances);
    chart.series = seriesInstances;
    if (groupingChanged) {
      return "series-grouping-change";
    }
    if (dataChanged) {
      return "data-change";
    }
    return isUpdated ? "updated" : "no-op";
  }
  applyAxes(chart, options, oldOpts, seriesStatus, skip = [], registerRegions = false) {
    if (!("axes" in options) || !options.axes) {
      return false;
    }
    skip = ["axes[].type", ...skip];
    const { axes } = options;
    const forceRecreate = seriesStatus === "replaced";
    const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i) => a.type === axes[i].type);
    if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {
      chart.axes.forEach((axis, index) => {
        const previousOpts = oldOpts.axes?.[index] ?? {};
        const axisDiff = jsonDiff(previousOpts, axes[index]);
        debug(`Chart.applyAxes() - applying axis diff idx ${index}`, axisDiff);
        const path = `axes[${index}]`;
        jsonApply(axis, axisDiff, { path, skip });
      });
      return true;
    }
    debug(`Chart.applyAxes() - creating new axes instances; seriesStatus: ${seriesStatus}`);
    chart.axes = this.createAxis(axes, skip);
    const axisGroups = {
      ["x" /* X */]: [],
      ["y" /* Y */]: []
    };
    chart.axes.forEach((axis) => {
      const { id } = axis;
      const node = axis.getRegionNode();
      if (node != null) {
        axisGroups[axis.direction].push({ id, node });
      }
    });
    if (registerRegions) {
      this.ctx.regionManager.updateRegion("horizontal-axes" /* HORIZONTAL_AXES */, ...axisGroups["x" /* X */]);
      this.ctx.regionManager.updateRegion("vertical-axes" /* VERTICAL_AXES */, ...axisGroups["y" /* Y */]);
    }
    return true;
  }
  createSeries(seriesOptions) {
    const seriesInstance = seriesRegistry.create(seriesOptions.type, this.getModuleContext());
    this.applySeriesOptionModules(seriesInstance, seriesOptions);
    this.applySeriesValues(seriesInstance, seriesOptions);
    return seriesInstance;
  }
  applySeriesOptionModules(series, options) {
    const moduleContext = series.createModuleContext();
    const moduleMap = series.getModuleMap();
    for (const module2 of moduleRegistry.byType("series-option")) {
      if (module2.optionsKey in options && module2.seriesTypes.includes(series.type)) {
        moduleMap.addModule(module2, (m) => m.moduleFactory(moduleContext));
      }
    }
  }
  applySeriesValues(target, options) {
    const moduleMap = target.getModuleMap();
    const { type: _, data, listeners, seriesGrouping, showInMiniChart: __, ...seriesOptions } = options;
    for (const moduleDef of EXPECTED_ENTERPRISE_MODULES) {
      if (moduleDef.type !== "series-option")
        continue;
      if (moduleDef.optionsKey in seriesOptions) {
        const module2 = moduleMap.getModule(moduleDef.optionsKey);
        if (module2) {
          const moduleOptions = seriesOptions[moduleDef.optionsKey];
          delete seriesOptions[moduleDef.optionsKey];
          module2.properties.set(moduleOptions);
        }
      }
    }
    target.properties.set(seriesOptions);
    if ("data" in options) {
      target.setOptionsData(data);
    }
    if (listeners) {
      this.registerListeners(target, listeners);
    }
    if ("seriesGrouping" in options) {
      if (seriesGrouping == null) {
        target.seriesGrouping = void 0;
      } else {
        target.seriesGrouping = { ...target.seriesGrouping, ...seriesGrouping };
      }
    }
  }
  createAxis(options, skip) {
    const newAxes = [];
    const moduleContext = this.getModuleContext();
    for (let index = 0; index < options.length; index++) {
      const axisOptions = options[index];
      const axis = axisRegistry.create(axisOptions.type, moduleContext);
      this.applyAxisModules(axis, axisOptions);
      jsonApply(axis, axisOptions, { path: `axes[${index}]`, skip });
      newAxes.push(axis);
    }
    guessInvalidPositions(newAxes);
    return newAxes;
  }
  applyAxisModules(axis, options) {
    const moduleContext = axis.createModuleContext();
    const moduleMap = axis.getModuleMap();
    for (const module2 of moduleRegistry.byType("axis-option")) {
      const shouldBeEnabled = options[module2.optionsKey] != null;
      if (shouldBeEnabled === moduleMap.isEnabled(module2))
        continue;
      if (shouldBeEnabled) {
        moduleMap.addModule(module2, (m) => m.moduleFactory(moduleContext));
        axis[module2.optionsKey] = moduleMap.getModule(module2);
      } else {
        moduleMap.removeModule(module2);
        delete axis[module2.optionsKey];
      }
    }
  }
  registerListeners(source, listeners) {
    source.clearEventListeners();
    for (const [property, listener] of Object.entries(listeners)) {
      if (isFunction(listener)) {
        source.addEventListener(property, listener);
      }
    }
  }
};
_Chart.chartsInstances = /* @__PURE__ */ new WeakMap();
__decorateClass([
  ActionOnSet({
    newValue(value) {
      if (this.destroyed)
        return;
      this.ctx.domManager.setContainer(value);
      _Chart.chartsInstances.set(value, this);
    },
    oldValue(value) {
      _Chart.chartsInstances.delete(value);
    }
  })
], _Chart.prototype, "container", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("width option", { inWidth: value });
    }
  })
], _Chart.prototype, "width", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("height option", { inHeight: value });
    }
  })
], _Chart.prototype, "height", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("minWidth option", { inMinWidth: value });
    }
  })
], _Chart.prototype, "minWidth", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("minHeight option", { inMinHeight: value });
    }
  })
], _Chart.prototype, "minHeight", 2);
__decorateClass([
  Validate(OBJECT)
], _Chart.prototype, "padding", 2);
__decorateClass([
  Validate(OBJECT)
], _Chart.prototype, "seriesArea", 2);
__decorateClass([
  Validate(OBJECT)
], _Chart.prototype, "keyboard", 2);
__decorateClass([
  Validate(UNION(["standalone", "integrated"], "a chart mode"))
], _Chart.prototype, "mode", 2);
__decorateClass([
  ProxyProperty("chartCaptions.title")
], _Chart.prototype, "title", 2);
__decorateClass([
  ProxyProperty("chartCaptions.subtitle")
], _Chart.prototype, "subtitle", 2);
__decorateClass([
  ProxyProperty("chartCaptions.footnote")
], _Chart.prototype, "footnote", 2);
__decorateClass([
  ActionOnSet({
    changeValue(newValue, oldValue) {
      this.onAxisChange(newValue, oldValue);
    }
  })
], _Chart.prototype, "axes", 2);
__decorateClass([
  ActionOnSet({
    changeValue(newValue, oldValue) {
      this.onSeriesChange(newValue, oldValue);
    }
  })
], _Chart.prototype, "series", 2);
var Chart = _Chart;

// packages/ag-charts-community/src/scene/util/quadtree.ts
var QuadtreeNearest = class {
  constructor(capacity, maxdepth, boundary) {
    this.root = new QuadtreeNodeNearest(capacity, maxdepth, boundary);
  }
  clear(boundary) {
    this.root.clear(boundary);
  }
  addValue(hitTester, value) {
    const elem = {
      hitTester,
      value,
      distanceSquared: (x, y) => {
        return hitTester.distanceSquared(x, y);
      }
    };
    this.root.addElem(elem);
  }
  find(x, y) {
    const arg = { best: { nearest: void 0, distanceSquared: Infinity } };
    this.root.find(x, y, arg);
    return arg.best;
  }
};
var QuadtreeSubdivisions = class {
  constructor(nw, ne, sw, se) {
    this.nw = nw;
    this.ne = ne;
    this.sw = sw;
    this.se = se;
  }
  addElem(elem) {
    this.nw.addElem(elem);
    this.ne.addElem(elem);
    this.sw.addElem(elem);
    this.se.addElem(elem);
  }
  find(x, y, arg) {
    this.nw.find(x, y, arg);
    this.ne.find(x, y, arg);
    this.sw.find(x, y, arg);
    this.se.find(x, y, arg);
  }
};
var QuadtreeNode = class {
  constructor(capacity, maxdepth, boundary) {
    this.capacity = capacity;
    this.maxdepth = maxdepth;
    this.boundary = boundary ?? BBox.NaN;
    this.elems = [];
    this.subdivisions = void 0;
  }
  clear(boundary) {
    this.elems.length = 0;
    this.boundary = boundary;
    this.subdivisions = void 0;
  }
  addElem(e) {
    if (this.addCondition(e)) {
      if (this.subdivisions === void 0) {
        if (this.maxdepth === 0 || this.elems.length < this.capacity) {
          this.elems.push(e);
        } else {
          this.subdivide(e);
        }
      } else {
        this.subdivisions.addElem(e);
      }
    }
  }
  find(x, y, arg) {
    if (this.findCondition(x, y, arg)) {
      if (this.subdivisions === void 0) {
        this.findAction(x, y, arg);
      } else {
        this.subdivisions.find(x, y, arg);
      }
    }
  }
  subdivide(newElem) {
    this.subdivisions = this.makeSubdivisions();
    for (const e of this.elems) {
      this.subdivisions.addElem(e);
    }
    this.subdivisions.addElem(newElem);
    this.elems.length = 0;
  }
  makeSubdivisions() {
    const { x, y, width, height } = this.boundary;
    const { capacity } = this;
    const depth = this.maxdepth - 1;
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const nwBoundary = new BBox(x, y, halfWidth, halfHeight);
    const neBoundary = new BBox(x + halfWidth, y, halfWidth, halfHeight);
    const swBoundary = new BBox(x, y + halfHeight, halfWidth, halfHeight);
    const seBoundary = new BBox(x + halfWidth, y + halfHeight, halfWidth, halfHeight);
    return new QuadtreeSubdivisions(
      this.child(capacity, depth, nwBoundary),
      this.child(capacity, depth, neBoundary),
      this.child(capacity, depth, swBoundary),
      this.child(capacity, depth, seBoundary)
    );
  }
};
var QuadtreeNodeNearest = class _QuadtreeNodeNearest extends QuadtreeNode {
  addCondition(e) {
    const { x, y } = e.hitTester.midPoint;
    return this.boundary.containsPoint(x, y);
  }
  findCondition(x, y, arg) {
    const { best } = arg;
    return best.distanceSquared !== 0 && this.boundary.distanceSquared(x, y) < best.distanceSquared;
  }
  findAction(x, y, arg) {
    const other = nearestSquared(x, y, this.elems, arg.best.distanceSquared);
    if (other.nearest !== void 0 && other.distanceSquared < arg.best.distanceSquared) {
      arg.best = other;
    }
  }
  child(capacity, depth, boundary) {
    return new _QuadtreeNodeNearest(capacity, depth, boundary);
  }
};

// packages/ag-charts-community/src/chart/marker/marker.ts
var BUILTIN_MARKERS = [
  "ArrowDown",
  "ArrowUp",
  "Circle",
  "Cross",
  "Diamond",
  "Heart",
  "MapPin",
  "Plus",
  "Square",
  "Star",
  "Triangle"
];
var DEFAULT_CENTER_POINT = Object.freeze({ x: 0.5, y: 0.5 });
var InternalMarker = class extends Path {
  constructor() {
    super(...arguments);
    this.x = 0;
    this.y = 0;
    this.size = 12;
  }
  isBuiltIn() {
    return BUILTIN_MARKERS.includes(this.constructor.className ?? "");
  }
  computeBBox() {
    if (!this.isBuiltIn()) {
      return this.path.computeBBox();
    }
    const { x, y, size } = this;
    const { center } = this.constructor;
    return new BBox(x - size * center.x, y - size * center.y, size, size);
  }
  applyPath(s, moves) {
    const { path } = this;
    let { x, y } = this;
    path.clear();
    for (const { x: mx, y: my, t } of moves) {
      x += mx * s;
      y += my * s;
      if (t === "move") {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.closePath();
  }
  executeFill(ctx, path) {
    if (!path)
      return;
    return super.executeFill(ctx, path);
  }
  executeStroke(ctx, path) {
    if (!path)
      return;
    return super.executeStroke(ctx, path);
  }
};
__decorateClass([
  ScenePathChangeDetection()
], InternalMarker.prototype, "x", 2);
__decorateClass([
  ScenePathChangeDetection()
], InternalMarker.prototype, "y", 2);
__decorateClass([
  ScenePathChangeDetection({ convertor: Math.abs })
], InternalMarker.prototype, "size", 2);
var Marker = class extends Rotatable(Scalable(Translatable(InternalMarker))) {
};
Marker.center = DEFAULT_CENTER_POINT;

// packages/ag-charts-community/src/chart/marker/circle.ts
var Circle = class extends Marker {
  updatePath() {
    const { x, y, path, size } = this;
    const r = size / 2;
    path.clear();
    path.arc(x, y, r, 0, Math.PI * 2);
    path.closePath();
  }
};
Circle.className = "Circle";

// packages/ag-charts-community/src/chart/marker/cross.ts
var _Cross = class _Cross extends Marker {
  updatePath() {
    const s = this.size / 4.2;
    super.applyPath(s, _Cross.moves);
  }
};
_Cross.className = "Cross";
_Cross.moves = [
  { x: -1, y: 0, t: "move" },
  { x: -1, y: -1 },
  { x: 1, y: -1 },
  { x: 1, y: 1 },
  { x: 1, y: -1 },
  { x: 1, y: 1 },
  { x: -1, y: 1 },
  { x: 1, y: 1 },
  { x: -1, y: 1 },
  { x: -1, y: -1 },
  { x: -1, y: 1 },
  { x: -1, y: -1 }
];
var Cross = _Cross;

// packages/ag-charts-community/src/chart/marker/diamond.ts
var _Diamond = class _Diamond extends Marker {
  updatePath() {
    const s = this.size / 2;
    super.applyPath(s, _Diamond.moves);
  }
};
_Diamond.className = "Diamond";
_Diamond.moves = [
  { x: 0, y: -1, t: "move" },
  { x: 1, y: 1 },
  { x: -1, y: 1 },
  { x: -1, y: -1 },
  { x: 1, y: -1 }
];
var Diamond = _Diamond;

// packages/ag-charts-community/src/chart/marker/heart.ts
var Heart = class extends Marker {
  rad(degree2) {
    return degree2 / 180 * Math.PI;
  }
  updatePath() {
    const { x, path, size, rad } = this;
    const r = size / 4;
    const y = this.y + r / 2;
    path.clear();
    path.arc(x - r, y - r, r, rad(130), rad(330));
    path.arc(x + r, y - r, r, rad(220), rad(50));
    path.lineTo(x, y + r);
    path.closePath();
  }
};
Heart.className = "Heart";

// packages/ag-charts-community/src/chart/marker/pin.ts
var Pin = class extends Marker {
  updatePath() {
    const { path, x, y } = this;
    const s = this.size;
    const cx = 0.5;
    const cy = 1;
    path.clear();
    path.moveTo(x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);
    path.cubicCurveTo(
      x + (0.15625 - cx) * s,
      y + (0.151491 - cy) * s,
      x + (0.307741 - cx) * s,
      y + (0 - cy) * s,
      x + (0.5 - cx) * s,
      y + (0 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.692259 - cx) * s,
      y + (0 - cy) * s,
      x + (0.84375 - cx) * s,
      y + (0.151491 - cy) * s,
      x + (0.84375 - cx) * s,
      y + (0.34375 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.84375 - cx) * s,
      y + (0.493824 - cy) * s,
      x + (0.784625 - cx) * s,
      y + (0.600181 - cy) * s,
      x + (0.716461 - cx) * s,
      y + (0.695393 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.699009 - cx) * s,
      y + (0.719769 - cy) * s,
      x + (0.681271 - cx) * s,
      y + (0.743104 - cy) * s,
      x + (0.663785 - cx) * s,
      y + (0.766105 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.611893 - cx) * s,
      y + (0.834367 - cy) * s,
      x + (0.562228 - cx) * s,
      y + (0.899699 - cy) * s,
      x + (0.528896 - cx) * s,
      y + (0.980648 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.524075 - cx) * s,
      y + (0.992358 - cy) * s,
      x + (0.512663 - cx) * s,
      y + (1 - cy) * s,
      x + (0.5 - cx) * s,
      y + (1 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.487337 - cx) * s,
      y + (1 - cy) * s,
      x + (0.475925 - cx) * s,
      y + (0.992358 - cy) * s,
      x + (0.471104 - cx) * s,
      y + (0.980648 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.487337 - cx) * s,
      y + (1 - cy) * s,
      x + (0.475925 - cx) * s,
      y + (0.992358 - cy) * s,
      x + (0.471104 - cx) * s,
      y + (0.980648 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.437772 - cx) * s,
      y + (0.899699 - cy) * s,
      x + (0.388107 - cx) * s,
      y + (0.834367 - cy) * s,
      x + (0.336215 - cx) * s,
      y + (0.766105 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.318729 - cx) * s,
      y + (0.743104 - cy) * s,
      x + (0.300991 - cx) * s,
      y + (0.719769 - cy) * s,
      x + (0.283539 - cx) * s,
      y + (0.695393 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.215375 - cx) * s,
      y + (0.600181 - cy) * s,
      x + (0.15625 - cx) * s,
      y + (0.493824 - cy) * s,
      x + (0.15625 - cx) * s,
      y + (0.34375 - cy) * s
    );
    path.closePath();
  }
};
Pin.className = "MapPin";
Pin.center = { x: 0.5, y: 1 };

// packages/ag-charts-community/src/chart/marker/plus.ts
var _Plus = class _Plus extends Marker {
  updatePath() {
    const s = this.size / 3;
    super.applyPath(s, _Plus.moves);
  }
};
_Plus.className = "Plus";
_Plus.moves = [
  { x: -0.5, y: -0.5, t: "move" },
  { x: 0, y: -1 },
  { x: 1, y: 0 },
  { x: 0, y: 1 },
  { x: 1, y: 0 },
  { x: 0, y: 1 },
  { x: -1, y: 0 },
  { x: 0, y: 1 },
  { x: -1, y: 0 },
  { x: 0, y: -1 },
  { x: -1, y: 0 },
  { x: 0, y: -1 }
];
var Plus = _Plus;

// packages/ag-charts-community/src/chart/marker/square.ts
var Square = class extends Marker {
  updatePath() {
    const { path, x, y } = this;
    const hs = this.size / 2;
    path.clear();
    path.moveTo(this.align(x - hs), this.align(y - hs));
    path.lineTo(this.align(x + hs), this.align(y - hs));
    path.lineTo(this.align(x + hs), this.align(y + hs));
    path.lineTo(this.align(x - hs), this.align(y + hs));
    path.closePath();
  }
};
Square.className = "Square";

// packages/ag-charts-community/src/chart/marker/star.ts
var Star = class extends Marker {
  updatePath() {
    const { x, y, path, size } = this;
    const spikes = 5;
    const innerRadius = size / 2;
    const rotation = Math.PI / 2;
    path.clear();
    for (let i = 0; i < spikes * 2; i++) {
      const radius = i % 2 === 0 ? size : innerRadius;
      const angle2 = i * Math.PI / spikes - rotation;
      const xCoordinate = x + Math.cos(angle2) * radius;
      const yCoordinate = y + Math.sin(angle2) * radius;
      path.lineTo(xCoordinate, yCoordinate);
    }
    path.closePath();
  }
};
Star.className = "Star";

// packages/ag-charts-community/src/chart/marker/triangle.ts
var _Triangle = class _Triangle extends Marker {
  updatePath() {
    const s = this.size * 1.1;
    super.applyPath(s, _Triangle.moves);
  }
};
_Triangle.className = "Triangle";
_Triangle.moves = [
  { x: 0, y: -0.48, t: "move" },
  { x: 0.5, y: 0.87 },
  { x: -1, y: 0 }
];
var Triangle = _Triangle;

// packages/ag-charts-community/src/chart/marker/util.ts
var MARKER_SHAPES = {
  circle: Circle,
  cross: Cross,
  diamond: Diamond,
  heart: Heart,
  pin: Pin,
  plus: Plus,
  square: Square,
  star: Star,
  triangle: Triangle
};
var MARKER_SUPPORTED_SHAPES = Object.keys(MARKER_SHAPES);
function isMarkerShape(shape) {
  return typeof shape === "string" && MARKER_SUPPORTED_SHAPES.includes(shape);
}
function getMarker(shape = Square) {
  if (isMarkerShape(shape)) {
    return MARKER_SHAPES[shape];
  }
  if (typeof shape === "function") {
    return shape;
  }
  return Square;
}

// packages/ag-charts-community/src/chart/series/dataModelSeries.ts
var DataModelSeries = class extends Series {
  constructor() {
    super(...arguments);
    this.showFocusBox = true;
  }
  getScaleInformation({
    xScale,
    yScale
  }) {
    const isContinuousX = ContinuousScale.is(xScale);
    const isContinuousY = ContinuousScale.is(yScale);
    return { isContinuousX, isContinuousY, xScaleType: xScale?.type, yScaleType: yScale?.type };
  }
  getModulePropertyDefinitions() {
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    return this.moduleMap.mapModules((mod2) => mod2.getPropertyDefinitions(this.getScaleInformation({ xScale, yScale }))).flat();
  }
  // Request data, but with message dispatching to series-options (modules).
  async requestDataModel(dataController, data, opts) {
    opts.props.push(...this.getModulePropertyDefinitions());
    const { dataModel, processedData } = await dataController.request(this.id, data ?? [], opts);
    this.dataModel = dataModel;
    this.processedData = processedData;
    this.dispatch("data-processed", { dataModel, processedData });
    return { dataModel, processedData };
  }
  isProcessedDataAnimatable() {
    const validationResults = this.processedData?.reduced?.animationValidation;
    if (!validationResults) {
      return true;
    }
    const { orderedKeys, uniqueKeys } = validationResults;
    return orderedKeys && uniqueKeys;
  }
  checkProcessedDataAnimatable() {
    if (!this.isProcessedDataAnimatable()) {
      this.ctx.animationManager.skipCurrentBatch();
    }
  }
  pickFocus(opts) {
    const nodeData = this.getNodeData();
    if (nodeData === void 0 || nodeData.length === 0) {
      return;
    }
    const datumIndex = this.computeFocusDatumIndex(opts, nodeData);
    if (datumIndex === void 0) {
      return;
    }
    const { showFocusBox } = this;
    const datum = nodeData[datumIndex];
    const derivedOpts = { ...opts, datumIndex };
    const bounds = this.computeFocusBounds(derivedOpts);
    if (bounds !== void 0) {
      return { bounds, showFocusBox, datum, datumIndex };
    }
  }
  computeFocusDatumIndex(opts, nodeData) {
    const isDatumEnabled = (datumIndex2) => {
      const { missing = false, enabled = true, focusable = true } = nodeData[datumIndex2];
      return !missing && enabled && focusable;
    };
    const searchBackward = (datumIndex2) => {
      while (datumIndex2 >= 0 && !isDatumEnabled(datumIndex2)) {
        datumIndex2--;
      }
      return datumIndex2 === -1 ? void 0 : datumIndex2;
    };
    const searchForward = (datumIndex2) => {
      while (datumIndex2 < nodeData.length && !isDatumEnabled(datumIndex2)) {
        datumIndex2++;
      }
      return datumIndex2 === nodeData.length ? void 0 : datumIndex2;
    };
    let datumIndex;
    const clampedIndex = clamp(0, opts.datumIndex, nodeData.length - 1);
    if (opts.datumIndexDelta < 0) {
      datumIndex = searchBackward(clampedIndex);
    } else if (opts.datumIndexDelta > 0) {
      datumIndex = searchForward(clampedIndex);
    } else {
      datumIndex = searchForward(clampedIndex) ?? searchBackward(clampedIndex);
    }
    if (datumIndex === void 0) {
      if (opts.datumIndexDelta === 0) {
        return;
      } else {
        return opts.datumIndex - opts.datumIndexDelta;
      }
    } else {
      return datumIndex;
    }
  }
};

// packages/ag-charts-community/src/chart/series/seriesProperties.ts
var SeriesItemHighlightStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.fill = "rgba(255,255,255, 0.33)";
    this.stroke = `rgba(0, 0, 0, 0.4)`;
    this.strokeWidth = 2;
  }
};
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], SeriesItemHighlightStyle.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], SeriesItemHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], SeriesItemHighlightStyle.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], SeriesItemHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], SeriesItemHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH, { optional: true })
], SeriesItemHighlightStyle.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], SeriesItemHighlightStyle.prototype, "lineDashOffset", 2);
var SeriesHighlightStyle = class extends BaseProperties {
};
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], SeriesHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], SeriesHighlightStyle.prototype, "dimOpacity", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], SeriesHighlightStyle.prototype, "enabled", 2);
var TextHighlightStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.color = "black";
  }
};
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], TextHighlightStyle.prototype, "color", 2);
var HighlightProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
  }
};
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], HighlightProperties.prototype, "enabled", 2);
var HighlightStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.item = new SeriesItemHighlightStyle();
    this.series = new SeriesHighlightStyle();
    this.text = new TextHighlightStyle();
  }
};
__decorateClass([
  Validate(OBJECT)
], HighlightStyle.prototype, "item", 2);
__decorateClass([
  Validate(OBJECT)
], HighlightStyle.prototype, "series", 2);
__decorateClass([
  Validate(OBJECT)
], HighlightStyle.prototype, "text", 2);
var SeriesProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.visible = true;
    this.focusPriority = Infinity;
    this.showInLegend = true;
    this.cursor = "default";
    this.nodeClickRange = "exact";
    this.highlight = new HighlightProperties();
    this.highlightStyle = new HighlightStyle();
  }
};
__decorateClass([
  Validate(STRING, { optional: true })
], SeriesProperties.prototype, "id", 2);
__decorateClass([
  Validate(BOOLEAN)
], SeriesProperties.prototype, "visible", 2);
__decorateClass([
  Validate(REAL_NUMBER, { optional: true })
], SeriesProperties.prototype, "focusPriority", 2);
__decorateClass([
  Validate(BOOLEAN)
], SeriesProperties.prototype, "showInLegend", 2);
__decorateClass([
  Validate(STRING)
], SeriesProperties.prototype, "cursor", 2);
__decorateClass([
  Validate(INTERACTION_RANGE)
], SeriesProperties.prototype, "nodeClickRange", 2);
__decorateClass([
  Validate(OBJECT)
], SeriesProperties.prototype, "highlight", 2);
__decorateClass([
  Validate(OBJECT)
], SeriesProperties.prototype, "highlightStyle", 2);

// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts
var DEFAULT_CARTESIAN_DIRECTION_KEYS = {
  ["x" /* X */]: ["xKey"],
  ["y" /* Y */]: ["yKey"]
};
var DEFAULT_CARTESIAN_DIRECTION_NAMES = {
  ["x" /* X */]: ["xName"],
  ["y" /* Y */]: ["yName"]
};
var CartesianSeriesNodeEvent = class extends SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.yKey = series.properties.yKey;
  }
};
var CartesianSeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.pickOutsideVisibleMinorAxis = false;
  }
};
__decorateClass([
  Validate(STRING, { optional: true })
], CartesianSeriesProperties.prototype, "legendItemName", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], CartesianSeriesProperties.prototype, "pickOutsideVisibleMinorAxis", 2);
var CartesianSeries = class extends DataModelSeries {
  constructor({
    pathsPerSeries = ["path"],
    hasMarkers = false,
    hasHighlightedLabels = false,
    pathsZIndexSubOrderOffset = [],
    datumSelectionGarbageCollection = true,
    markerSelectionGarbageCollection = true,
    animationAlwaysUpdateSelections = false,
    animationResetFns,
    directionKeys,
    directionNames,
    ...otherOpts
  }) {
    super({
      directionKeys,
      directionNames,
      canHaveAxes: true,
      ...otherOpts
    });
    this.NodeEvent = CartesianSeriesNodeEvent;
    this.dataNodeGroup = this.contentGroup.appendChild(
      new Group({
        name: `${this.id}-series-dataNodes`,
        zIndex: 4 /* SERIES_LAYER */,
        zIndexSubOrder: this.getGroupZIndexSubOrder("data")
      })
    );
    this.markerGroup = this.contentGroup.appendChild(
      new Group({
        name: `${this.id}-series-markers`,
        zIndex: 4 /* SERIES_LAYER */,
        zIndexSubOrder: this.getGroupZIndexSubOrder("marker")
      })
    );
    this.labelGroup = this.contentGroup.appendChild(
      new TranslatableGroup({
        name: `${this.id}-series-labels`,
        zIndex: 14 /* SERIES_LABEL */,
        zIndexSubOrder: this.getGroupZIndexSubOrder("labels")
      })
    );
    this.labelSelection = Selection.select(this.labelGroup, Text);
    this.highlightSelection = Selection.select(
      this.highlightNode,
      () => this.opts.hasMarkers ? this.markerFactory() : this.nodeFactory()
    );
    this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);
    this.annotationSelections = /* @__PURE__ */ new Set();
    this.minRectsCache = {
      dirtyNodeData: true
    };
    this.debug = Debug.create();
    if (!directionKeys || !directionNames)
      throw new Error(`Unable to initialise series type ${this.type}`);
    this.opts = {
      pathsPerSeries,
      hasMarkers,
      hasHighlightedLabels,
      pathsZIndexSubOrderOffset,
      directionKeys,
      directionNames,
      animationResetFns,
      animationAlwaysUpdateSelections,
      datumSelectionGarbageCollection,
      markerSelectionGarbageCollection
    };
    this.paths = [];
    for (let index = 0; index < pathsPerSeries.length; index++) {
      this.paths[index] = new Path({ name: `${this.id}-${pathsPerSeries[index]}` });
      this.paths[index].zIndex = 4 /* SERIES_LAYER */;
      this.paths[index].zIndexSubOrder = this.getGroupZIndexSubOrder("paths", index);
      this.contentGroup.appendChild(this.paths[index]);
    }
    this.datumSelection = Selection.select(
      this.dataNodeGroup,
      () => this.nodeFactory(),
      datumSelectionGarbageCollection
    );
    this.markerSelection = Selection.select(
      this.markerGroup,
      () => this.markerFactory(),
      markerSelectionGarbageCollection
    );
    this.animationState = new StateMachine(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: (data) => this.animateEmptyUpdateReady(data)
          },
          reset: "empty",
          skip: "ready",
          disable: "disabled"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          highlight: (data) => this.animateReadyHighlight(data),
          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),
          resize: (data) => this.animateReadyResize(data),
          reset: "empty",
          skip: "ready",
          disable: "disabled"
        },
        waiting: {
          update: {
            target: "ready",
            action: (data) => {
              if (this.ctx.animationManager.isSkipped()) {
                this.resetAllAnimation(data);
              } else {
                this.animateWaitingUpdateReady(data);
              }
            }
          },
          reset: "empty",
          skip: "ready",
          disable: "disabled"
        },
        disabled: {
          update: (data) => this.resetAllAnimation(data),
          reset: "empty"
        },
        clearing: {
          update: {
            target: "empty",
            action: (data) => this.animateClearingUpdateEmpty(data)
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  get contextNodeData() {
    return this._contextNodeData;
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    } else if (phase === "disabled") {
      this.animationState.transition("disable");
    }
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
      this.ctx.chartEventManager.addListener(
        "legend-item-double-click",
        (event) => this.onLegendItemDoubleClick(event)
      )
    );
  }
  destroy() {
    super.destroy();
    this._contextNodeData = void 0;
  }
  async update({ seriesRect }) {
    const { visible, _contextNodeData: previousContextData } = this;
    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;
    const seriesHighlighted = series === this;
    const resize = this.checkResize(seriesRect);
    const highlightItems = await this.updateHighlightSelection(seriesHighlighted);
    await this.updateSelections(visible);
    await this.updateNodes(highlightItems, seriesHighlighted, visible);
    const animationData = this.getAnimationData(seriesRect, previousContextData);
    if (!animationData)
      return;
    if (resize) {
      this.animationState.transition("resize", animationData);
    }
    this.animationState.transition("update", animationData);
  }
  async updateSelections(anySeriesItemEnabled) {
    var _a;
    const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();
    if (!anySeriesItemEnabled && animationSkipUpdate) {
      return;
    }
    if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {
      return;
    }
    if (this.nodeDataRefresh) {
      this.nodeDataRefresh = false;
      this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);
      this.markQuadtreeDirty();
      this._contextNodeData = await this.createNodeData();
      const animationValid = this.isProcessedDataAnimatable();
      if (this._contextNodeData) {
        (_a = this._contextNodeData).animationValid ?? (_a.animationValid = animationValid);
      }
      this.minRectsCache.dirtyNodeData = true;
      const { dataModel, processedData } = this;
      if (dataModel !== void 0 && processedData !== void 0) {
        this.dispatch("data-update", { dataModel, processedData });
      }
    }
    await this.updateSeriesSelections();
  }
  async updateSeriesSelections(seriesHighlighted) {
    const { datumSelection, labelSelection, markerSelection, paths } = this;
    const contextData = this._contextNodeData;
    if (!contextData)
      return;
    const { nodeData, labelData, itemId } = contextData;
    await this.updatePaths({ seriesHighlighted, itemId, contextData, paths });
    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });
    this.labelSelection = await this.updateLabelSelection({ labelData, labelSelection });
    if (this.opts.hasMarkers) {
      this.markerSelection = await this.updateMarkerSelection({ nodeData, markerSelection });
    }
  }
  markerFactory() {
    const MarkerShape = getMarker();
    return new MarkerShape();
  }
  getGroupZIndexSubOrder(type, subIndex = 0) {
    const result = super.getGroupZIndexSubOrder(type, subIndex);
    if (type === "paths") {
      const [superFn] = result;
      const pathOffset = this.opts.pathsZIndexSubOrderOffset[subIndex] ?? 0;
      result[0] = isFunction(superFn) ? () => Number(superFn()) + pathOffset : Number(superFn) + pathOffset;
    }
    return result;
  }
  async updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {
    const {
      highlightSelection,
      highlightLabelSelection,
      opts: { hasMarkers, hasHighlightedLabels }
    } = this;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const visible = this.visible && this._contextNodeData != null && anySeriesItemEnabled;
    this.rootGroup.visible = animationEnabled || visible;
    this.contentGroup.visible = animationEnabled || visible;
    this.highlightGroup.visible = (animationEnabled || visible) && seriesHighlighted;
    const opacity = this.getOpacity();
    if (hasMarkers) {
      await this.updateMarkerNodes({
        markerSelection: highlightSelection,
        isHighlight: true
      });
      this.animationState.transition("highlightMarkers", highlightSelection);
    } else {
      await this.updateDatumNodes({
        datumSelection: highlightSelection,
        isHighlight: true
      });
      this.animationState.transition("highlight", highlightSelection);
    }
    if (hasHighlightedLabels) {
      await this.updateLabelNodes({ labelSelection: highlightLabelSelection });
    }
    const { dataNodeGroup, markerGroup, datumSelection, labelSelection, markerSelection, paths, labelGroup } = this;
    const { itemId } = this.contextNodeData ?? {};
    dataNodeGroup.opacity = opacity;
    dataNodeGroup.visible = animationEnabled || visible;
    labelGroup.visible = visible;
    if (hasMarkers) {
      markerGroup.opacity = opacity;
      markerGroup.zIndex = dataNodeGroup.zIndex >= 4 /* SERIES_LAYER */ ? dataNodeGroup.zIndex : dataNodeGroup.zIndex + 1;
      markerGroup.visible = visible;
    }
    if (labelGroup) {
      labelGroup.opacity = opacity;
    }
    await this.updatePathNodes({
      seriesHighlighted,
      itemId,
      paths,
      opacity,
      visible,
      animationEnabled
    });
    if (!dataNodeGroup.visible) {
      return;
    }
    await this.updateDatumNodes({ datumSelection, highlightedItems, isHighlight: false });
    await this.updateLabelNodes({ labelSelection });
    if (hasMarkers) {
      await this.updateMarkerNodes({ markerSelection, isHighlight: false });
    }
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter(
      (ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId
    );
    return labelItems.length === 0 ? void 0 : labelItems;
  }
  getHighlightData(_nodeData, highlightedItem) {
    return highlightedItem ? [highlightedItem] : void 0;
  }
  async updateHighlightSelection(seriesHighlighted) {
    const { highlightSelection, highlightLabelSelection, _contextNodeData: contextNodeData } = this;
    if (!contextNodeData)
      return;
    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    const item = seriesHighlighted && highlightedDatum?.datum ? highlightedDatum : void 0;
    let labelItems;
    let highlightItems;
    if (item != null) {
      const labelsEnabled = this.isLabelEnabled();
      const { labelData, nodeData } = contextNodeData;
      highlightItems = this.getHighlightData(nodeData, item);
      labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : void 0;
    }
    this.highlightSelection = await this.updateHighlightSelectionItem({
      items: highlightItems,
      highlightSelection
    });
    this.highlightLabelSelection = await this.updateHighlightSelectionLabel({
      items: labelItems,
      highlightLabelSelection
    });
    return highlightItems;
  }
  markQuadtreeDirty() {
    this.quadtree = void 0;
  }
  *datumNodesIter() {
    for (const { node } of this.datumSelection) {
      if (node.datum.missing === true)
        continue;
      yield node;
    }
  }
  getQuadTree() {
    if (this.quadtree === void 0) {
      const { width, height } = this.ctx.scene.canvas;
      const canvasRect = new BBox(0, 0, width, height);
      this.quadtree = new QuadtreeNearest(100, 10, canvasRect);
      this.initQuadTree(this.quadtree);
    }
    return this.quadtree;
  }
  initQuadTree(_quadtree) {
  }
  pickNodeExactShape(point) {
    const result = super.pickNodeExactShape(point);
    if (result) {
      return result;
    }
    const { x, y } = point;
    const {
      opts: { hasMarkers }
    } = this;
    let match;
    const { dataNodeGroup, markerGroup } = this;
    match = dataNodeGroup.pickNode(x, y);
    if (!match && hasMarkers) {
      match = markerGroup?.pickNode(x, y);
    }
    if (match && match.datum.missing !== true) {
      return { datum: match.datum, distance: 0 };
    }
    for (const mod2 of this.moduleMap.modules()) {
      const { datum } = mod2.pickNodeExact(point) ?? {};
      if (datum == null)
        continue;
      if (datum?.missing === true)
        continue;
      return { datum, distance: 0 };
    }
  }
  pickNodeClosestDatum(point) {
    const { x, y } = point;
    const { axes, _contextNodeData: contextNodeData } = this;
    if (!contextNodeData)
      return;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    const hitPoint = { x, y };
    let minDistance = Infinity;
    let closestDatum;
    for (const datum of contextNodeData.nodeData) {
      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;
      if (isNaN(datumX) || isNaN(datumY)) {
        continue;
      }
      const isInRange = xAxis?.inRange(datumX) && yAxis?.inRange(datumY);
      if (!isInRange) {
        continue;
      }
      const distance3 = Math.max((hitPoint.x - datumX) ** 2 + (hitPoint.y - datumY) ** 2, 0);
      if (distance3 < minDistance) {
        minDistance = distance3;
        closestDatum = datum;
      }
    }
    for (const mod2 of this.moduleMap.modules()) {
      const modPick = mod2.pickNodeNearest(point);
      if (modPick !== void 0 && modPick.distanceSquared < minDistance) {
        minDistance = modPick.distanceSquared;
        closestDatum = modPick.datum;
        break;
      }
    }
    if (closestDatum) {
      const distance3 = Math.max(Math.sqrt(minDistance) - (closestDatum.point?.size ?? 0), 0);
      return { datum: closestDatum, distance: distance3 };
    }
  }
  pickNodeMainAxisFirst(point, requireCategoryAxis) {
    const { x, y } = point;
    const { axes, _contextNodeData: contextNodeData } = this;
    const { pickOutsideVisibleMinorAxis } = this.properties;
    if (!contextNodeData)
      return;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    const directions2 = [xAxis, yAxis].filter(CategoryAxis.is).map((a) => a.direction);
    if (requireCategoryAxis && directions2.length === 0)
      return;
    const [majorDirection = "x" /* X */] = directions2;
    const hitPointCoords = [x, y];
    if (majorDirection !== "x" /* X */)
      hitPointCoords.reverse();
    const minDistance = [Infinity, Infinity];
    let closestDatum;
    for (const datum of contextNodeData.nodeData) {
      const { x: datumX = NaN, y: datumY = NaN } = datum.point ?? datum.midPoint ?? {};
      if (isNaN(datumX) || isNaN(datumY) || datum.missing === true)
        continue;
      const visible = [xAxis?.inRange(datumX), yAxis?.inRange(datumY)];
      if (majorDirection !== "x" /* X */) {
        visible.reverse();
      }
      if (!visible[0] || !pickOutsideVisibleMinorAxis && !visible[1])
        continue;
      const datumPoint = [datumX, datumY];
      if (majorDirection !== "x" /* X */) {
        datumPoint.reverse();
      }
      let newMinDistance = true;
      for (let i = 0; i < datumPoint.length; i++) {
        const dist = Math.abs(datumPoint[i] - hitPointCoords[i]);
        if (dist > minDistance[i]) {
          newMinDistance = false;
          break;
        } else if (dist < minDistance[i]) {
          minDistance[i] = dist;
          minDistance.fill(Infinity, i + 1, minDistance.length);
        }
      }
      if (newMinDistance) {
        closestDatum = datum;
      }
    }
    if (closestDatum) {
      let closestDistanceSquared = Math.max(
        minDistance[0] ** 2 + minDistance[1] ** 2 - (closestDatum.point?.size ?? 0),
        0
      );
      for (const mod2 of this.moduleMap.modules()) {
        const modPick = mod2.pickNodeMainAxisFirst(point);
        if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {
          closestDatum = modPick.datum;
          closestDistanceSquared = modPick.distanceSquared;
          break;
        }
      }
      return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };
    }
  }
  onLegendItemClick(event) {
    const { legendItemName } = this.properties;
    const { enabled, itemId, series } = event;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const { legendItemName } = this.properties;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, true);
    } else if (enabled && numVisibleItems === 1) {
      this.toggleSeriesItem(itemId, true);
    } else {
      this.toggleSeriesItem(itemId, false);
    }
  }
  isPathOrSelectionDirty() {
    return false;
  }
  getLabelData() {
    return [];
  }
  shouldFlipXY() {
    return false;
  }
  /**
   * Get the minimum bounding box that contains any adjacent two nodes. The axes are treated independently, so this
   * may not represent the same two points for both directions. The dimensions represent the greatest distance
   * between any two adjacent nodes.
   */
  getMinRects(width, height) {
    const { dirtyNodeData, sizeCache, minRect, minVisibleRect } = this.minRectsCache;
    const newSizeCache = JSON.stringify({ width, height });
    const dirtySize = newSizeCache !== sizeCache;
    if (!dirtySize && !dirtyNodeData && minRect && minVisibleRect) {
      return { minRect, minVisibleRect };
    }
    const rects = this.computeMinRects(width, height);
    this.minRectsCache = {
      dirtyNodeData: false,
      sizeCache: newSizeCache,
      minRect: rects?.minRect,
      minVisibleRect: rects?.minVisibleRect
    };
    return rects;
  }
  computeMinRects(width, height) {
    const context = this._contextNodeData;
    if (!context?.nodeData.length) {
      return;
    }
    const { nodeData } = context;
    const minRectXs = Array(nodeData.length);
    const minRectYs = Array(nodeData.length);
    for (const [i, { midPoint }] of nodeData.entries()) {
      minRectXs[i] = midPoint?.x ?? 0;
      minRectYs[i] = midPoint?.y ?? 0;
    }
    minRectXs.sort((a, b) => a - b);
    minRectYs.sort((a, b) => a - b);
    let zeroX, widthX, zeroY, heightY;
    let maxWidth = 0;
    let maxHeight = 0;
    for (let i = 1; i < nodeData.length; i++) {
      if (minRectXs[i] >= 0)
        zeroX ?? (zeroX = i);
      if (minRectXs[i] > width)
        widthX ?? (widthX = i);
      if (minRectYs[i] >= 0)
        zeroY ?? (zeroY = i);
      if (minRectYs[i] > height)
        heightY ?? (heightY = i);
      maxWidth = Math.max(maxWidth, minRectXs[i] - minRectXs[i - 1]);
      maxHeight = Math.max(maxHeight, minRectYs[i] - minRectYs[i - 1]);
    }
    widthX ?? (widthX = nodeData.length);
    heightY ?? (heightY = nodeData.length);
    const minVisibleRectXs = zeroX != null && widthX != null ? minRectXs.slice(zeroX, widthX) : [];
    const minVisibleRectYs = zeroY != null && heightY != null ? minRectYs.slice(zeroY, heightY) : [];
    let maxVisibleWidth = 0;
    let maxVisibleHeight = 0;
    for (let i = 1; i < Math.max(minVisibleRectXs.length, minVisibleRectYs.length); i++) {
      const x1 = minVisibleRectXs[i];
      const x2 = minVisibleRectXs[i - 1];
      const y1 = minVisibleRectYs[i];
      const y2 = minVisibleRectYs[i - 1];
      if (x1 != null && x2 != null) {
        maxVisibleWidth = Math.max(maxVisibleWidth, x1 - x2);
      }
      if (y1 != null && y2 != null) {
        maxVisibleHeight = Math.max(maxVisibleHeight, y1 - y2);
      }
    }
    const minRect = new BBox(0, 0, maxWidth, maxHeight);
    const minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);
    return { minRect, minVisibleRect };
  }
  updateHighlightSelectionItem(opts) {
    const {
      opts: { hasMarkers }
    } = this;
    const { items, highlightSelection } = opts;
    const nodeData = items ?? [];
    if (hasMarkers) {
      const markerSelection = highlightSelection;
      return this.updateMarkerSelection({ nodeData, markerSelection });
    } else {
      return this.updateDatumSelection({
        nodeData,
        datumSelection: highlightSelection
      });
    }
  }
  updateHighlightSelectionLabel(opts) {
    return this.updateLabelSelection({
      labelData: opts.items ?? [],
      labelSelection: opts.highlightLabelSelection
    });
  }
  async updateDatumSelection(opts) {
    return opts.datumSelection;
  }
  async updateDatumNodes(_opts) {
  }
  async updateMarkerSelection(opts) {
    return opts.markerSelection;
  }
  async updateMarkerNodes(_opts) {
  }
  async updatePaths(opts) {
    opts.paths.forEach((p) => p.visible = false);
  }
  async updatePathNodes(opts) {
    const { paths, opacity, visible } = opts;
    for (const path of paths) {
      path.opacity = opacity;
      path.visible = visible;
    }
  }
  resetPathAnimation(data) {
    const { path } = this.opts?.animationResetFns ?? {};
    if (path) {
      data.paths.forEach((paths) => {
        resetMotion([paths], path);
      });
    }
  }
  resetDatumAnimation(data) {
    const { datum } = this.opts?.animationResetFns ?? {};
    if (datum) {
      resetMotion([data.datumSelection], datum);
    }
  }
  resetLabelAnimation(data) {
    const { label } = this.opts?.animationResetFns ?? {};
    if (label) {
      resetMotion([data.labelSelection], label);
    }
  }
  resetMarkerAnimation(data) {
    const { marker } = this.opts?.animationResetFns ?? {};
    if (marker && this.opts.hasMarkers) {
      resetMotion([data.markerSelection], marker);
    }
  }
  resetAllAnimation(data) {
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    this.resetPathAnimation(data);
    this.resetDatumAnimation(data);
    this.resetLabelAnimation(data);
    this.resetMarkerAnimation(data);
    if (data.contextData?.animationValid === false) {
      this.ctx.animationManager.skipCurrentBatch();
    }
  }
  animateEmptyUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateWaitingUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateReadyHighlight(data) {
    const { datum } = this.opts?.animationResetFns ?? {};
    if (datum) {
      resetMotion([data], datum);
    }
  }
  animateReadyHighlightMarkers(data) {
    const { marker } = this.opts?.animationResetFns ?? {};
    if (marker) {
      resetMotion([data], marker);
    }
  }
  animateReadyResize(data) {
    this.resetAllAnimation(data);
  }
  animateClearingUpdateEmpty(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animationTransitionClear() {
    const animationData = this.getAnimationData();
    if (!animationData)
      return;
    this.animationState.transition("clear", animationData);
  }
  getAnimationData(seriesRect, previousContextData) {
    const { _contextNodeData: contextData } = this;
    if (!contextData)
      return;
    const animationData = {
      datumSelection: this.datumSelection,
      markerSelection: this.markerSelection,
      labelSelection: this.labelSelection,
      annotationSelections: [...this.annotationSelections],
      contextData,
      previousContextData,
      paths: this.paths,
      seriesRect
    };
    return animationData;
  }
  calculateScaling() {
    const result = {};
    for (const direction of Object.values(ChartAxisDirection)) {
      const axis = this.axes[direction];
      if (!axis)
        continue;
      if (axis.scale instanceof LogScale) {
        const { range: range3, domain } = axis.scale;
        result[direction] = {
          type: "log",
          convert: (d) => axis.scale.convert(d),
          domain: [domain[0], domain[1]],
          range: [range3[0], range3[1]]
        };
      } else if (axis.scale instanceof ContinuousScale) {
        const { range: range3 } = axis.scale;
        const domain = axis.scale.getDomain();
        result[direction] = {
          type: "continuous",
          domain: [domain[0], domain[1]],
          range: [range3[0], range3[1]]
        };
      } else if (axis.scale) {
        const { domain } = axis.scale;
        result[direction] = {
          type: "category",
          domain,
          range: domain.map((d) => axis.scale.convert(d))
        };
      }
    }
    return result;
  }
};

// packages/ag-charts-community/src/chart/cartesianChart.ts
var directions = ["top", "right", "bottom", "left"];
var CartesianChart = class extends Chart {
  constructor(options, resources) {
    super(options, resources);
    /** Integrated Charts feature state - not used in Standalone Charts. */
    this.paired = true;
    this.firstSeriesTranslation = true;
    this.lastUpdateClipRect = void 0;
    this._lastCrossLineIds = void 0;
    this._lastAxisAreaWidths = /* @__PURE__ */ new Map();
    this._lastClipSeries = false;
    this._lastVisibility = {
      crossLines: true,
      series: true
    };
  }
  onAxisChange(newValue, oldValue) {
    super.onAxisChange(newValue, oldValue);
    this.ctx?.zoomManager.updateAxes(newValue);
  }
  destroySeries(series) {
    super.destroySeries(series);
    this.firstSeriesTranslation = true;
  }
  getChartType() {
    return "cartesian";
  }
  setRootClipRects(clipRect) {
    const { seriesRoot, annotationRoot, highlightRoot } = this;
    seriesRoot.setClipRect(clipRect);
    highlightRoot.setClipRect(clipRect);
    annotationRoot.setClipRect(clipRect);
  }
  performLayout(ctx) {
    const { firstSeriesTranslation, seriesRoot, annotationRoot, highlightRoot } = this;
    const { seriesRect, visibility, clipSeries } = this.updateAxes(ctx.layoutBox);
    this.seriesRoot.visible = visibility.series;
    this.seriesRect = seriesRect;
    this.animationRect = ctx.layoutBox;
    const { x, y } = seriesRect;
    if (firstSeriesTranslation) {
      for (const group of [seriesRoot, annotationRoot, highlightRoot]) {
        group.translationX = Math.floor(x);
        group.translationY = Math.floor(y);
      }
      this.firstSeriesTranslation = false;
    } else {
      const { translationX, translationY } = seriesRoot;
      staticFromToMotion(
        this.id,
        "seriesRect",
        this.ctx.animationManager,
        [seriesRoot, highlightRoot, annotationRoot],
        { translationX, translationY },
        { translationX: Math.floor(x), translationY: Math.floor(y) },
        { phase: "update" }
      );
    }
    const seriesPaddedRect = seriesRect.clone().grow(this.seriesArea.padding);
    const clipRect = this.seriesArea.clip || clipSeries ? seriesPaddedRect : void 0;
    const { lastUpdateClipRect } = this;
    this.lastUpdateClipRect = clipRect;
    if (this.ctx.animationManager.isActive() && lastUpdateClipRect != null) {
      this.ctx.animationManager.animate({
        id: this.id,
        groupId: "clip-rect",
        phase: "update",
        from: lastUpdateClipRect,
        to: seriesPaddedRect,
        onUpdate: (interpolatedClipRect) => this.setRootClipRects(interpolatedClipRect),
        onComplete: () => this.setRootClipRects(clipRect)
      });
    } else {
      this.setRootClipRects(clipRect);
    }
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      axes: this.axes.map((axis) => axis.getLayoutState()),
      series: {
        rect: seriesRect,
        paddedRect: seriesPaddedRect,
        visible: visibility.series,
        shouldFlipXY: this.shouldFlipXY()
      },
      clipSeries
    });
  }
  updateAxes(layoutBox) {
    const crossLineIds = this.axes.flatMap((axis) => axis.crossLines ?? []).map((crossLine) => crossLine.id);
    const axesValid = this._lastCrossLineIds != null && this._lastCrossLineIds.length === crossLineIds.length && this._lastCrossLineIds.every((id, index) => crossLineIds[index] === id);
    let axisAreaWidths;
    let clipSeries;
    let visibility;
    if (axesValid) {
      axisAreaWidths = new Map(this._lastAxisAreaWidths.entries());
      clipSeries = this._lastClipSeries;
      visibility = { ...this._lastVisibility };
    } else {
      axisAreaWidths = /* @__PURE__ */ new Map();
      clipSeries = false;
      visibility = { crossLines: true, series: true };
      this._lastCrossLineIds = crossLineIds;
    }
    const liveAxisWidths = new Set(this.axes.map((a) => a.position));
    for (const position of axisAreaWidths.keys()) {
      if (!liveAxisWidths.has(position)) {
        axisAreaWidths.delete(position);
      }
    }
    const stableOutputs = (otherAxisWidths, otherClipSeries, otherVisibility) => {
      if ([...otherAxisWidths.keys()].some((k) => !axisAreaWidths.has(k))) {
        return false;
      }
      if (visibility.crossLines !== otherVisibility.crossLines || visibility.series !== otherVisibility.series || clipSeries !== otherClipSeries) {
        return false;
      }
      for (const [p, w] of axisAreaWidths.entries()) {
        const otherW = otherAxisWidths.get(p);
        if ((w != null || otherW != null) && w !== otherW) {
          return false;
        }
      }
      return true;
    };
    const ceilValues = (map) => {
      for (const [key, value] of map.entries()) {
        if (value && Math.abs(value) === Infinity) {
          map.set(key, 0);
          continue;
        }
        map.set(key, value != null ? Math.ceil(value) : value);
      }
      return map;
    };
    let lastPassAxisAreaWidths = /* @__PURE__ */ new Map();
    let lastPassVisibility = {};
    let lastPassClipSeries = false;
    let seriesRect = this.seriesRect?.clone();
    let count = 0;
    do {
      axisAreaWidths = new Map(lastPassAxisAreaWidths.entries());
      clipSeries = lastPassClipSeries;
      Object.assign(visibility, lastPassVisibility);
      const result = this.updateAxesPass(axisAreaWidths, layoutBox.clone(), seriesRect);
      lastPassAxisAreaWidths = ceilValues(result.axisAreaWidths);
      lastPassVisibility = result.visibility;
      lastPassClipSeries = result.clipSeries;
      ({ seriesRect } = result);
      if (count++ > 10) {
        Logger.warn("unable to find stable axis layout.");
        break;
      }
    } while (!stableOutputs(lastPassAxisAreaWidths, lastPassClipSeries, lastPassVisibility));
    this.axes.forEach((axis) => {
      axis.update();
    });
    const clipRectPadding = 5;
    this.axes.forEach((axis) => {
      axis.setCrossLinesVisible(visibility.crossLines);
      if (!seriesRect) {
        return;
      }
      axis.clipGrid(
        seriesRect.x,
        seriesRect.y,
        seriesRect.width + clipRectPadding,
        seriesRect.height + clipRectPadding
      );
      switch (axis.position) {
        case "left":
        case "right":
          axis.clipTickLines(
            layoutBox.x,
            seriesRect.y,
            layoutBox.width + clipRectPadding,
            seriesRect.height + clipRectPadding
          );
          break;
        case "top":
        case "bottom":
          axis.clipTickLines(
            seriesRect.x,
            layoutBox.y,
            seriesRect.width + clipRectPadding,
            layoutBox.height + clipRectPadding
          );
          break;
      }
    });
    this._lastAxisAreaWidths = axisAreaWidths;
    this._lastVisibility = visibility;
    this._lastClipSeries = clipSeries;
    return { seriesRect, visibility, clipSeries };
  }
  updateAxesPass(axisAreaWidths, bounds, lastPassSeriesRect) {
    const axisWidths = /* @__PURE__ */ new Map();
    const axisGroups = /* @__PURE__ */ new Map();
    const visibility = {
      series: true,
      crossLines: true
    };
    let clipSeries = false;
    const primaryTickCounts = {};
    const paddedBounds = this.applySeriesPadding(bounds);
    const crossLinePadding = lastPassSeriesRect ? this.buildCrossLinePadding(axisAreaWidths) : {};
    const axisAreaBound = this.buildAxisBound(paddedBounds, axisAreaWidths, crossLinePadding, visibility);
    const seriesRect = this.buildSeriesRect(axisAreaBound, axisAreaWidths);
    for (const axis of this.axes) {
      const { position = "left" } = axis;
      const { clipSeries: newClipSeries, axisThickness } = this.calculateAxisDimensions({
        axis,
        seriesRect,
        primaryTickCounts,
        clipSeries
      });
      axisWidths.set(axis.id, axisThickness);
      if (!axisGroups.has(position))
        axisGroups.set(position, []);
      axisGroups.get(position)?.push(axis);
      clipSeries = clipSeries || newClipSeries;
    }
    const newAxisAreaWidths = /* @__PURE__ */ new Map();
    const axisOffsets = /* @__PURE__ */ new Map();
    for (const [position, axes] of axisGroups.entries()) {
      const isVertical = position === "left" || position === "right";
      newAxisAreaWidths.set(position, this.calculateAxisArea(axes, axisWidths, axisOffsets, isVertical));
    }
    for (const [position, axes] of axisGroups.entries()) {
      this.positionAxes({
        axes,
        position,
        axisWidths,
        axisOffsets,
        axisAreaWidths: newAxisAreaWidths,
        axisBound: axisAreaBound,
        seriesRect
      });
    }
    return { clipSeries, seriesRect, axisAreaWidths: newAxisAreaWidths, visibility };
  }
  buildCrossLinePadding(axisAreaSize) {
    const crossLinePadding = {};
    this.axes.forEach((axis) => {
      axis.crossLines?.forEach((crossLine) => {
        crossLine.calculatePadding?.(crossLinePadding);
      });
    });
    for (const [side, padding = 0] of Object.entries(crossLinePadding)) {
      crossLinePadding[side] = Math.max(padding - (axisAreaSize.get(side) ?? 0), 0);
    }
    return crossLinePadding;
  }
  applySeriesPadding(bounds) {
    const paddedRect = bounds.clone();
    directions.forEach((dir) => {
      const padding = this.seriesArea.padding[dir];
      const axis = this.axes.findLast((a) => a.position === dir);
      if (axis) {
        axis.seriesAreaPadding = padding;
      } else {
        paddedRect.shrink(padding, dir);
      }
    });
    return paddedRect;
  }
  buildAxisBound(bounds, axisAreaWidths, crossLinePadding, visibility) {
    const result = bounds.clone();
    const { top = 0, right = 0, bottom = 0, left = 0 } = crossLinePadding;
    const horizontalPadding = left + right;
    const verticalPadding = top + bottom;
    const totalWidth = (axisAreaWidths.get("left") ?? 0) + (axisAreaWidths.get("right") ?? 0) + horizontalPadding;
    const totalHeight = (axisAreaWidths.get("top") ?? 0) + (axisAreaWidths.get("bottom") ?? 0) + verticalPadding;
    if (result.width <= totalWidth || result.height <= totalHeight) {
      visibility.crossLines = false;
      visibility.series = false;
      return result;
    }
    result.x += left;
    result.y += top;
    result.width -= horizontalPadding;
    result.height -= verticalPadding;
    return result;
  }
  buildSeriesRect(axisBound, axisAreaWidths) {
    const result = axisBound.clone();
    result.x += axisAreaWidths.get("left") ?? 0;
    result.y += axisAreaWidths.get("top") ?? 0;
    result.width -= (axisAreaWidths.get("left") ?? 0) + (axisAreaWidths.get("right") ?? 0);
    result.height -= (axisAreaWidths.get("top") ?? 0) + (axisAreaWidths.get("bottom") ?? 0);
    result.width = Math.max(0, result.width);
    result.height = Math.max(0, result.height);
    return result;
  }
  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {
    const { x, y, width, height } = seriesRect;
    const clampBounds = [x, y, x + width, y + height];
    const compareTo = clampBounds[(dimension === "x" ? 0 : 1) + (direction === 1 ? 0 : 2)];
    const clampFn = direction === 1 ? Math.min : Math.max;
    return clampFn(value, compareTo);
  }
  calculateAxisDimensions(opts) {
    const { axis, seriesRect, primaryTickCounts } = opts;
    let { clipSeries } = opts;
    const { position = "left", direction } = axis;
    this.sizeAxis(axis, seriesRect, position);
    const syncedDomain = this.getSyncedDomain(axis);
    const layout = axis.calculateLayout(syncedDomain, axis.nice ? primaryTickCounts[direction] : void 0);
    const isVertical = direction === "y" /* Y */;
    primaryTickCounts[direction] ?? (primaryTickCounts[direction] = layout.primaryTickCount);
    clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);
    let axisThickness;
    if (axis.thickness != null && axis.thickness > 0) {
      axisThickness = axis.thickness;
    } else {
      axisThickness = isVertical ? layout.bbox.width : layout.bbox.height;
    }
    axisThickness = Math.ceil(axisThickness);
    return { clipSeries, axisThickness };
  }
  getSyncedDomain(axis) {
    const syncModule = this.modulesManager.getModule("sync");
    if (!syncModule?.enabled)
      return;
    const syncedDomain = syncModule.getSyncedDomain(axis);
    if (syncedDomain && axis.dataDomain.domain.length) {
      let shouldUpdate;
      const { domain } = axis.scale;
      if (ContinuousScale.is(axis.scale)) {
        const [min, max] = findMinMax(syncedDomain);
        shouldUpdate = min !== domain[0] || max !== domain[1];
      } else {
        shouldUpdate = !arraysEqual(syncedDomain, domain);
      }
      if (shouldUpdate && !this.skipSync) {
        syncModule.updateSiblings();
      }
    }
    return syncedDomain;
  }
  sizeAxis(axis, seriesRect, position) {
    const isCategory = axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis;
    const isLeftRight = position === "left" || position === "right";
    let { min, max } = this.ctx.zoomManager.getAxisZoom(axis.id);
    const { width, height } = seriesRect;
    const minStart = 0;
    const maxEnd = isLeftRight ? height : width;
    let start = minStart;
    let end = maxEnd;
    const { width: axisWidth, unit, align } = axis.layoutConstraints;
    if (unit === "px") {
      end = start + axisWidth;
    } else {
      end = end * axisWidth / 100;
    }
    if (align === "end") {
      start = maxEnd - (end - start);
      end = maxEnd;
    }
    if (isCategory && isLeftRight) {
      [min, max] = [1 - max, 1 - min];
    } else if (isLeftRight) {
      [start, end] = [end, start];
    }
    axis.range = [start, end];
    axis.visibleRange = [min, max];
    axis.gridLength = isLeftRight ? width : height;
  }
  calculateAxisArea(axes, axisWidths, axisOffsets, isVertical) {
    const { width, height, canvas } = this.ctx.scene;
    let currentOffset = isVertical ? height % canvas.pixelRatio : width % canvas.pixelRatio;
    let totalAxisWidth = 0;
    for (const axis of axes) {
      axisOffsets.set(axis.id, currentOffset);
      const axisThickness = axisWidths.get(axis.id) ?? 0;
      totalAxisWidth = Math.max(totalAxisWidth, currentOffset + axisThickness);
      if (axis.layoutConstraints.stacked) {
        currentOffset += axisThickness + 15;
      }
    }
    return totalAxisWidth;
  }
  positionAxes(opts) {
    const { axes, axisBound, axisWidths, axisOffsets, axisAreaWidths, seriesRect, position } = opts;
    const axisAreaWidth = axisAreaWidths.get(position) ?? 0;
    let mainDimension = "x";
    let minorDimension = "y";
    let direction = 1;
    let axisBoundMainOffset = 0;
    if (position === "top" || position === "bottom") {
      mainDimension = "y";
      minorDimension = "x";
      axisBoundMainOffset += 1;
    }
    axisBoundMainOffset += axisBound[mainDimension];
    if (position === "right" || position === "bottom") {
      direction = -1;
      axisBoundMainOffset += mainDimension === "x" ? axisBound.width : axisBound.height;
    }
    for (const axis of axes) {
      const minorOffset = axisAreaWidths.get(minorDimension === "x" ? "left" : "top") ?? 0;
      axis.translation[minorDimension] = axisBound[minorDimension] + minorOffset;
      const axisThickness = axisWidths.get(axis.id) ?? 0;
      const axisOffset = axisOffsets.get(axis.id) ?? 0;
      axis.translation[mainDimension] = this.clampToOutsideSeriesRect(
        seriesRect,
        axisBoundMainOffset + direction * (axisOffset + axisThickness),
        mainDimension,
        direction
      );
      axis.gridPadding = axisAreaWidth - axisOffset - axisThickness;
      axis.updatePosition();
    }
  }
  shouldFlipXY() {
    return this.series.every((series) => series instanceof CartesianSeries && series.shouldFlipXY());
  }
};
CartesianChart.className = "CartesianChart";
CartesianChart.type = "cartesian";

// packages/ag-charts-community/src/chart/chartProxy.ts
var _AgChartInstanceProxy = class _AgChartInstanceProxy {
  constructor(chart, factoryApi, licenseManager) {
    this.factoryApi = factoryApi;
    this.licenseManager = licenseManager;
    this.chart = chart;
  }
  static isInstance(x) {
    if (x instanceof _AgChartInstanceProxy) {
      return true;
    }
    if (x.constructor?.name === "AgChartInstanceProxy" && x.chart != null) {
      return true;
    }
    return x.chart != null && this.validateImplementation(x);
  }
  static validateImplementation(x) {
    const chartProps = ["getOptions", "destroy"];
    const signatureProps = Object.keys(Object.getPrototypeOf(x) ?? {});
    return chartProps.every((prop) => signatureProps.includes(prop));
  }
  async update(options) {
    this.factoryApi.update(options, this);
    await this.chart.waitForUpdate();
  }
  async updateDelta(deltaOptions) {
    this.factoryApi.updateUserDelta(this, deltaOptions);
    await this.chart.waitForUpdate();
  }
  getOptions() {
    const options = deepClone(this.chart.getOptions());
    for (const key in options) {
      if (key.startsWith("_")) {
        delete options[key];
      }
    }
    return options;
  }
  waitForUpdate() {
    return this.chart.waitForUpdate();
  }
  async download(opts) {
    const clone = await this.prepareResizedChart(this, opts);
    try {
      clone.chart.download(opts?.fileName, opts?.fileFormat);
    } finally {
      clone.destroy();
    }
  }
  async __toSVG(opts) {
    const clone = await this.prepareResizedChart(this, { width: 600, height: 300, ...opts });
    try {
      return clone.chart.toSVG();
    } finally {
      clone.destroy();
    }
  }
  async getImageDataURL(opts) {
    const clone = await this.prepareResizedChart(this, opts);
    try {
      return clone.chart.getCanvasDataURL(opts?.fileFormat);
    } finally {
      clone.destroy();
    }
  }
  getState() {
    const {
      factoryApi: { caretaker },
      chart: {
        ctx: { annotationManager }
      }
    } = this;
    return caretaker.save(annotationManager);
  }
  async setState(state) {
    const {
      factoryApi: { caretaker },
      chart: {
        ctx: { annotationManager }
      }
    } = this;
    caretaker.restore(state, annotationManager);
    await this.chart.waitForUpdate();
  }
  resetAnimations() {
    this.chart.resetAnimations();
  }
  skipAnimations() {
    this.chart.skipAnimations();
  }
  destroy() {
    this.chart.publicApi = void 0;
    this.chart.destroy();
  }
  async prepareResizedChart(proxy, opts = {}) {
    const { chart } = proxy;
    const width = opts.width ?? chart.width ?? chart.ctx.scene.canvas.width;
    const height = opts.height ?? chart.height ?? chart.ctx.scene.canvas.height;
    const state = proxy.getState();
    const isEnterprise = moduleRegistry.hasEnterpriseModules();
    const processedOverrides = {
      ...chart.chartOptions.processedOverrides,
      container: document.createElement("div"),
      width,
      height
    };
    const userOptions = chart.getOptions();
    if (isEnterprise) {
      processedOverrides.animation = { enabled: false };
      if (isAgCartesianChartOptions(userOptions)) {
        processedOverrides.toolbar = { enabled: false };
      }
      if (this.licenseManager?.isDisplayWatermark()) {
        processedOverrides.foreground = {
          text: this.licenseManager.getWatermarkMessage(),
          image: {
            url: `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=`,
            width: 170,
            height: 25,
            right: 25,
            bottom: 50,
            opacity: 0.7
          }
        };
      }
    }
    const specialOverrides = { ...chart.chartOptions.specialOverrides };
    const optionsMetadata = { ...chart.chartOptions.optionMetadata };
    if (opts.width != null && opts.height != null) {
      specialOverrides.overrideDevicePixelRatio = 1;
    }
    const cloneProxy = await this.factoryApi.create(
      userOptions,
      processedOverrides,
      specialOverrides,
      optionsMetadata
    );
    await cloneProxy.setState(state);
    cloneProxy.chart.ctx.zoomManager.updateZoom("chartProxy", chart.ctx.zoomManager.getZoom());
    chart.series.forEach((series, index) => {
      if (!series.visible) {
        cloneProxy.chart.series[index].visible = false;
      }
    });
    cloneProxy.chart.update(0 /* FULL */, { forceNodeDataRefresh: true });
    await cloneProxy.waitForUpdate();
    return cloneProxy;
  }
};
_AgChartInstanceProxy.chartInstances = /* @__PURE__ */ new WeakMap();
__decorateClass([
  ActionOnSet({
    oldValue(chart) {
      if (!chart.destroyed) {
        chart.publicApi = void 0;
      }
      _AgChartInstanceProxy.chartInstances.delete(chart);
    },
    newValue(chart) {
      chart.publicApi = this;
      _AgChartInstanceProxy.chartInstances.set(chart, this);
    }
  })
], _AgChartInstanceProxy.prototype, "chart", 2);
var AgChartInstanceProxy = _AgChartInstanceProxy;

// packages/ag-charts-community/src/locale/locale.ts
var Locale = class extends BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.localeText = void 0;
  }
};
__decorateClass([
  ObserveChanges((target) => {
    target.ctx.localeManager.setLocaleText(target.localeText);
  }),
  Validate(PLAIN_OBJECT, { optional: true })
], Locale.prototype, "localeText", 2);
__decorateClass([
  ObserveChanges((target) => {
    target.ctx.localeManager.setLocaleTextFormatter(target.getLocaleText);
  }),
  Validate(FUNCTION, { optional: true })
], Locale.prototype, "getLocaleText", 2);

// packages/ag-charts-community/src/locale/localeModule.ts
var LocaleModule = {
  type: "root",
  optionsKey: "locale",
  packageType: "community",
  chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"],
  moduleFactory: (ctx) => new Locale(ctx)
};

// packages/ag-charts-community/src/scale/linearScale.ts
var LinearScale = class extends ContinuousScale {
  constructor() {
    super([0, 1], [0, 1]);
    this.type = "number";
  }
  toDomain(d) {
    return d;
  }
  ticks() {
    const count = this.tickCount ?? ContinuousScale.defaultTickCount;
    if (!this.domain || this.domain.length < 2 || count < 1 || !this.domain.every(isFinite)) {
      return [];
    }
    this.refresh();
    const [d0, d1] = this.getDomain();
    if (this.interval) {
      const step = Math.abs(this.interval);
      if (!isDenseInterval((d1 - d0) / step, this.getPixelRange())) {
        return range(d0, d1, step);
      }
    }
    return createTicks(d0, d1, count, this.minTickCount, this.maxTickCount);
  }
  update() {
    if (!this.domain || this.domain.length < 2) {
      return;
    }
    if (this.nice) {
      this.updateNiceDomain();
    }
  }
  getTickStep(start, stop) {
    return this.interval ?? tickStep(start, stop, this.tickCount, this.minTickCount, this.maxTickCount);
  }
  /**
   * Extends the domain so that it starts and ends on nice round values.
   */
  updateNiceDomain() {
    const count = this.tickCount;
    if (count < 1) {
      this.niceDomain = [...this.domain];
      return;
    }
    let [start, stop] = this.domain;
    if (count === 1) {
      [start, stop] = niceTicksDomain(start, stop);
    } else {
      const roundStart = start > stop ? Math.ceil : Math.floor;
      const roundStop = stop < start ? Math.floor : Math.ceil;
      const maxAttempts = 4;
      for (let i = 0; i < maxAttempts; i++) {
        const prev0 = start;
        const prev1 = stop;
        const step = this.getTickStep(start, stop);
        const [d0, d1] = this.domain;
        if (step >= 1) {
          start = roundStart(d0 / step) * step;
          stop = roundStop(d1 / step) * step;
        } else {
          const s = 1 / step;
          start = roundStart(d0 * s) / s;
          stop = roundStop(d1 * s) / s;
        }
        if (start === prev0 && stop === prev1) {
          break;
        }
      }
    }
    this.niceDomain = [start, stop];
  }
  tickFormat({ ticks: specifiedTicks, specifier }) {
    return tickFormat(specifiedTicks ?? this.ticks(), specifier);
  }
};

// packages/ag-charts-community/src/util/secondaryAxisTicks.ts
function calculateNiceSecondaryAxis(domain, primaryTickCount, reverse) {
  let [start, stop] = findMinMax(domain);
  start = calculateNiceStart(Math.floor(start), stop, primaryTickCount);
  const step = getTickStep(start, stop, primaryTickCount);
  const segments = primaryTickCount - 1;
  stop = start + segments * step;
  const d = reverse ? [stop, start] : [start, stop];
  const ticks = getTicks(start, step, primaryTickCount);
  return { domain: d, ticks };
}
function calculateNiceStart(a, b, count) {
  const rawStep = Math.abs(b - a) / (count - 1);
  const order = Math.floor(Math.log10(rawStep));
  const magnitude = Math.pow(10, order);
  return Math.floor(a / magnitude) * magnitude;
}
function getTicks(start, step, count) {
  const stepPower = Math.floor(Math.log10(step));
  const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;
  const f = Math.pow(10, fractionDigits);
  const ticks = [];
  for (let i = 0; i < count; i++) {
    const tick = start + step * i;
    ticks[i] = Math.round(tick * f) / f;
  }
  return ticks;
}
function getTickStep(start, stop, count) {
  const segments = count - 1;
  const rawStep = (stop - start) / segments;
  return calculateNextNiceStep(rawStep);
}
function calculateNextNiceStep(rawStep) {
  const order = Math.floor(Math.log10(rawStep));
  const magnitude = Math.pow(10, order);
  const step = rawStep / magnitude * 10;
  if (step > 0 && step <= 1) {
    return magnitude / 10;
  }
  if (step > 1 && step <= 2) {
    return 2 * magnitude / 10;
  }
  if (step > 1 && step <= 5) {
    return 5 * magnitude / 10;
  }
  if (step > 5 && step <= 10) {
    return 10 * magnitude / 10;
  }
  if (step > 10 && step <= 20) {
    return 20 * magnitude / 10;
  }
  if (step > 20 && step <= 40) {
    return 40 * magnitude / 10;
  }
  if (step > 40 && step <= 50) {
    return 50 * magnitude / 10;
  }
  if (step > 50 && step <= 100) {
    return 100 * magnitude / 10;
  }
  return step;
}

// packages/ag-charts-community/src/chart/axis/numberAxis.ts
var NumberAxis = class extends CartesianAxis {
  constructor(moduleCtx, scale2 = new LinearScale()) {
    super(moduleCtx, scale2);
    this.min = NaN;
    this.max = NaN;
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);
    return { domain: extent2, clipped };
  }
  updateSecondaryAxisTicks(primaryTickCount) {
    if (this.dataDomain == null) {
      throw new Error("AG Charts - dataDomain not calculated, cannot perform tick calculation.");
    }
    if (this.dataDomain.domain.length === 0) {
      return [];
    }
    const { domain, ticks } = calculateNiceSecondaryAxis(
      this.dataDomain.domain,
      primaryTickCount ?? 0,
      this.reverse
    );
    this.scale.nice = false;
    this.scale.domain = domain;
    this.scale.update();
    return ticks;
  }
};
NumberAxis.className = "NumberAxis";
NumberAxis.type = "number";
__decorateClass([
  Validate(AND(NUMBER_OR_NAN, LESS_THAN("max"))),
  Default(NaN)
], NumberAxis.prototype, "min", 2);
__decorateClass([
  Validate(AND(NUMBER_OR_NAN, GREATER_THAN("min"))),
  Default(NaN)
], NumberAxis.prototype, "max", 2);

// packages/ag-charts-community/src/chart/axis/logAxis.ts
var NON_ZERO_NUMBER = predicateWithMessage((value) => isNumber(value) && value !== 0, "a non-zero number");
var LogAxis = class extends NumberAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new LogScale());
    this.min = NaN;
    this.max = NaN;
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);
    const isInverted = extent2[0] > extent2[1];
    const crossesZero = extent2[0] < 0 && extent2[1] > 0;
    const hasZeroExtent = extent2[0] === 0 && extent2[1] === 0;
    const invalidDomain = isInverted || crossesZero || hasZeroExtent;
    if (invalidDomain) {
      if (crossesZero) {
        Logger.warn(
          `the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`
        );
      } else if (hasZeroExtent) {
        Logger.warn(`the data domain has 0 extent, no data is rendered.`);
      }
    }
    if (extent2[0] === 0) {
      extent2[0] = 1;
    }
    if (extent2[1] === 0) {
      extent2[1] = -1;
    }
    return { domain: extent2, clipped };
  }
  set base(value) {
    this.scale.base = value;
  }
  get base() {
    return this.scale.base;
  }
};
LogAxis.className = "LogAxis";
LogAxis.type = "log";
__decorateClass([
  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, LESS_THAN("max"))),
  Default(NaN)
], LogAxis.prototype, "min", 2);
__decorateClass([
  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, GREATER_THAN("min"))),
  Default(NaN)
], LogAxis.prototype, "max", 2);

// packages/ag-charts-community/src/chart/axis/timeAxis.ts
var TimeAxis = class extends CartesianAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new TimeScale());
    this.min = void 0;
    this.max = void 0;
  }
  normaliseDataDomain(d) {
    let { min, max } = this;
    let clipped = false;
    if (typeof min === "number") {
      min = new Date(min);
    }
    if (typeof max === "number") {
      max = new Date(max);
    }
    if (d.length > 2) {
      d = extent(d)?.map((x) => new Date(x)) ?? [];
    }
    if (min instanceof Date) {
      clipped || (clipped = min > d[0]);
      d = [min, d[1]];
    }
    if (max instanceof Date) {
      clipped || (clipped = max < d[1]);
      d = [d[0], max];
    }
    if (d[0] > d[1]) {
      d = [];
    }
    return { domain: d, clipped };
  }
  onFormatChange(ticks, fractionDigits, domain, format) {
    if (format) {
      super.onFormatChange(ticks, fractionDigits, domain, format);
    } else {
      this.labelFormatter = this.scale.tickFormat({ ticks, domain });
      this.datumFormatter = this.scale.tickFormat({ ticks, domain, formatOffset: 1 });
    }
  }
};
TimeAxis.className = "TimeAxis";
TimeAxis.type = "time";
__decorateClass([
  Validate(AND(DATE_OR_DATETIME_MS, LESS_THAN("max")), { optional: true })
], TimeAxis.prototype, "min", 2);
__decorateClass([
  Validate(AND(DATE_OR_DATETIME_MS, GREATER_THAN("min")), { optional: true })
], TimeAxis.prototype, "max", 2);

// packages/ag-charts-community/src/scene/util/corner.ts
var drawCorner = (path, { x0, y0, x1, y1, cx, cy }, cornerRadius, move) => {
  if (move) {
    path.moveTo(x0, y0);
  }
  if (x0 !== x1 || y0 !== y1) {
    const r0 = Math.atan2(y0 - cy, x0 - cx);
    const r1 = Math.atan2(y1 - cy, x1 - cx);
    path.arc(cx, cy, cornerRadius, r0, r1);
  } else {
    path.lineTo(x0, y0);
  }
};

// packages/ag-charts-community/src/scene/shape/rect.ts
var epsilon = 1e-6;
var cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius) => {
  let leadingClipped = false;
  let trailingClipped = false;
  let leading0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - leadingInset ** 2, 0));
  let leading1 = 0;
  let trailing0 = 0;
  let trailing1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - trailingInset ** 2, 0));
  if (leading0 > leadingEdge) {
    leadingClipped = true;
    leading0 = leadingEdge;
    leading1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (trailingInset - leadingEdge) ** 2));
  } else if (leading0 < epsilon) {
    leading0 = 0;
  }
  if (trailing1 > trailingEdge) {
    trailingClipped = true;
    trailing0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (leadingInset - trailingEdge) ** 2));
    trailing1 = trailingEdge;
  } else if (trailing1 < epsilon) {
    trailing1 = 0;
  }
  return { leading0, leading1, trailing0, trailing1, leadingClipped, trailingClipped };
};
var insetCornerRadiusRect = (path, x, y, width, height, cornerRadii, clipBBox) => {
  let {
    topLeft: topLeftCornerRadius,
    topRight: topRightCornerRadius,
    bottomRight: bottomRightCornerRadius,
    bottomLeft: bottomLeftCornerRadius
  } = cornerRadii;
  const maxVerticalCornerRadius = Math.max(
    topLeftCornerRadius + bottomLeftCornerRadius,
    topRightCornerRadius + bottomRightCornerRadius
  );
  const maxHorizontalCornerRadius = Math.max(
    topLeftCornerRadius + topRightCornerRadius,
    bottomLeftCornerRadius + bottomRightCornerRadius
  );
  if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {
    if (clipBBox == null) {
      path.rect(x, y, width, height);
    } else {
      path.rect(clipBBox.x, clipBBox.y, clipBBox.width, clipBBox.height);
    }
    return;
  } else if (clipBBox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {
    path.roundRect(x, y, width, height, topLeftCornerRadius);
    return;
  }
  if (width < 0) {
    x += width;
    width = Math.abs(width);
  }
  if (height < 0) {
    y += height;
    height = Math.abs(height);
  }
  if (width <= 0 || height <= 0)
    return;
  if (clipBBox == null) {
    clipBBox = new BBox(x, y, width, height);
  } else {
    const x0 = Math.max(x, clipBBox.x);
    const x1 = Math.min(x + width, clipBBox.x + clipBBox.width);
    const y0 = Math.max(y, clipBBox.y);
    const y1 = Math.min(y + height, clipBBox.y + clipBBox.height);
    clipBBox = new BBox(x0, y0, x1 - x0, y1 - y0);
  }
  const borderScale = Math.max(maxVerticalCornerRadius / height, maxHorizontalCornerRadius / width, 1);
  if (borderScale > 1) {
    topLeftCornerRadius /= borderScale;
    topRightCornerRadius /= borderScale;
    bottomRightCornerRadius /= borderScale;
    bottomLeftCornerRadius /= borderScale;
  }
  let drawTopLeftCorner = true;
  let drawTopRightCorner = true;
  let drawBottomRightCorner = true;
  let drawBottomLeftCorner = true;
  let topLeftCorner;
  let topRightCorner;
  let bottomRightCorner;
  let bottomLeftCorner;
  if (drawTopLeftCorner) {
    const nodes = cornerEdges(
      clipBBox.height,
      clipBBox.width,
      Math.max(x + topLeftCornerRadius - clipBBox.x, 0),
      Math.max(y + topLeftCornerRadius - clipBBox.y, 0),
      topLeftCornerRadius
    );
    if (nodes.leadingClipped)
      drawBottomLeftCorner = false;
    if (nodes.trailingClipped)
      drawTopRightCorner = false;
    const x0 = Math.max(clipBBox.x + nodes.leading1, clipBBox.x);
    const y0 = Math.max(clipBBox.y + nodes.leading0, clipBBox.y);
    const x1 = Math.max(clipBBox.x + nodes.trailing1, clipBBox.x);
    const y1 = Math.max(clipBBox.y + nodes.trailing0, clipBBox.y);
    const cx = x + topLeftCornerRadius;
    const cy = y + topLeftCornerRadius;
    topLeftCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawTopRightCorner) {
    const nodes = cornerEdges(
      clipBBox.width,
      clipBBox.height,
      Math.max(y + topRightCornerRadius - clipBBox.y, 0),
      Math.max(clipBBox.x + clipBBox.width - (x + width - topRightCornerRadius), 0),
      topRightCornerRadius
    );
    if (nodes.leadingClipped)
      drawTopLeftCorner = false;
    if (nodes.trailingClipped)
      drawBottomRightCorner = false;
    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading0, clipBBox.x + clipBBox.width);
    const y0 = Math.max(clipBBox.y + nodes.leading1, clipBBox.y);
    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing0, clipBBox.x + clipBBox.width);
    const y1 = Math.max(clipBBox.y + nodes.trailing1, clipBBox.y);
    const cx = x + width - topRightCornerRadius;
    const cy = y + topRightCornerRadius;
    topRightCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawBottomRightCorner) {
    const nodes = cornerEdges(
      clipBBox.height,
      clipBBox.width,
      Math.max(clipBBox.x + clipBBox.width - (x + width - bottomRightCornerRadius), 0),
      Math.max(clipBBox.y + clipBBox.height - (y + height - bottomRightCornerRadius), 0),
      bottomRightCornerRadius
    );
    if (nodes.leadingClipped)
      drawTopRightCorner = false;
    if (nodes.trailingClipped)
      drawBottomLeftCorner = false;
    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading1, clipBBox.x + clipBBox.width);
    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading0, clipBBox.y + clipBBox.height);
    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing1, clipBBox.x + clipBBox.width);
    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing0, clipBBox.y + clipBBox.height);
    const cx = x + width - bottomRightCornerRadius;
    const cy = y + height - bottomRightCornerRadius;
    bottomRightCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawBottomLeftCorner) {
    const nodes = cornerEdges(
      clipBBox.width,
      clipBBox.height,
      Math.max(clipBBox.y + clipBBox.height - (y + height - bottomLeftCornerRadius), 0),
      Math.max(x + bottomLeftCornerRadius - clipBBox.x, 0),
      bottomLeftCornerRadius
    );
    if (nodes.leadingClipped)
      drawBottomRightCorner = false;
    if (nodes.trailingClipped)
      drawTopLeftCorner = false;
    const x0 = Math.max(clipBBox.x + nodes.leading0, clipBBox.x);
    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading1, clipBBox.y + clipBBox.height);
    const x1 = Math.max(clipBBox.x + nodes.trailing0, clipBBox.x);
    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing1, clipBBox.y + clipBBox.height);
    const cx = x + bottomLeftCornerRadius;
    const cy = y + height - bottomLeftCornerRadius;
    bottomLeftCorner = { x0, y0, x1, y1, cx, cy };
  }
  let didMove = false;
  if (drawTopLeftCorner && topLeftCorner != null) {
    drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawTopRightCorner && topRightCorner != null) {
    drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawBottomRightCorner && bottomRightCorner != null) {
    drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawBottomLeftCorner && bottomLeftCorner != null) {
    drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  path.closePath();
};
var Rect = class extends Path {
  constructor() {
    super(...arguments);
    this.borderPath = new ExtendedPath2D();
    this.x = 0;
    this.y = 0;
    this.width = 10;
    this.height = 10;
    this.topLeftCornerRadius = 0;
    this.topRightCornerRadius = 0;
    this.bottomRightCornerRadius = 0;
    this.bottomLeftCornerRadius = 0;
    this.clipBBox = void 0;
    this.crisp = false;
    this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;
    this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;
    this.hittester = super.isPointInPath;
    this.distanceCalculator = super.distanceSquaredTransformedPoint;
    /**
     * When the rectangle's width or height is less than a pixel
     * and crisp mode is on, the rectangle will still fit into the pixel,
     * but will be less opaque to make an effect of holding less space.
     */
    this.microPixelEffectOpacity = 1;
  }
  set cornerRadius(cornerRadius) {
    this.topLeftCornerRadius = cornerRadius;
    this.topRightCornerRadius = cornerRadius;
    this.bottomRightCornerRadius = cornerRadius;
    this.bottomLeftCornerRadius = cornerRadius;
  }
  isDirtyPath() {
    return this.lastUpdatePathStrokeWidth !== this.strokeWidth || Boolean(this.path.isDirty() || this.borderPath.isDirty());
  }
  updatePath() {
    const {
      path,
      borderPath,
      crisp,
      topLeftCornerRadius: topLeft,
      topRightCornerRadius: topRight,
      bottomRightCornerRadius: bottomRight,
      bottomLeftCornerRadius: bottomLeft
    } = this;
    let { x, y, width: w, height: h, strokeWidth, clipBBox } = this;
    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;
    const pixelSize = 1 / pixelRatio;
    let microPixelEffectOpacity = 1;
    path.clear(true);
    borderPath.clear(true);
    if (crisp) {
      if (w <= pixelSize) {
        microPixelEffectOpacity *= w / pixelSize;
      }
      if (h <= pixelSize) {
        microPixelEffectOpacity *= h / pixelSize;
      }
      w = this.align(x, w);
      h = this.align(y, h);
      x = this.align(x);
      y = this.align(y);
      clipBBox = clipBBox != null ? new BBox(
        this.align(clipBBox.x),
        this.align(clipBBox.y),
        this.align(clipBBox.x, clipBBox.width),
        this.align(clipBBox.y, clipBBox.height)
      ) : void 0;
    }
    if (strokeWidth) {
      if (w < pixelSize) {
        const lx = x + pixelSize / 2;
        borderPath.moveTo(lx, y);
        borderPath.lineTo(lx, y + h);
        strokeWidth = pixelSize;
        this.borderClipPath = void 0;
      } else if (h < pixelSize) {
        const ly = y + pixelSize / 2;
        borderPath.moveTo(x, ly);
        borderPath.lineTo(x + w, ly);
        strokeWidth = pixelSize;
        this.borderClipPath = void 0;
      } else if (strokeWidth < w && strokeWidth < h) {
        const halfStrokeWidth = strokeWidth / 2;
        x += halfStrokeWidth;
        y += halfStrokeWidth;
        w -= strokeWidth;
        h -= strokeWidth;
        const adjustedClipBBox = clipBBox?.clone().shrink(halfStrokeWidth);
        const cornerRadii = {
          topLeft: topLeft > 0 ? topLeft - strokeWidth : 0,
          topRight: topRight > 0 ? topRight - strokeWidth : 0,
          bottomRight: bottomRight > 0 ? bottomRight - strokeWidth : 0,
          bottomLeft: bottomLeft > 0 ? bottomLeft - strokeWidth : 0
        };
        this.borderClipPath = void 0;
        if (w > 0 && h > 0 && (adjustedClipBBox == null || adjustedClipBBox?.width > 0 && adjustedClipBBox?.height > 0)) {
          insetCornerRadiusRect(path, x, y, w, h, cornerRadii, adjustedClipBBox);
          insetCornerRadiusRect(borderPath, x, y, w, h, cornerRadii, adjustedClipBBox);
        }
      } else {
        this.borderClipPath = this.borderClipPath ?? new ExtendedPath2D();
        this.borderClipPath.clear(true);
        this.borderClipPath.rect(x, y, w, h);
        borderPath.rect(x, y, w, h);
      }
    } else {
      const cornerRadii = { topLeft, topRight, bottomRight, bottomLeft };
      this.borderClipPath = void 0;
      insetCornerRadiusRect(path, x, y, w, h, cornerRadii, clipBBox);
    }
    if ([topLeft, topRight, bottomRight, bottomLeft].every((r) => r === 0)) {
      const bbox = this.getBBox();
      this.hittester = bbox.containsPoint.bind(bbox);
      this.distanceSquared = (hitX, hitY) => this.getBBox().distanceSquared(hitX, hitY);
    } else {
      this.hittester = super.isPointInPath;
      this.distanceCalculator = super.distanceSquaredTransformedPoint;
    }
    this.effectiveStrokeWidth = strokeWidth;
    this.lastUpdatePathStrokeWidth = strokeWidth;
    this.microPixelEffectOpacity = microPixelEffectOpacity;
  }
  computeBBox() {
    const { x, y, width, height, clipBBox } = this;
    return clipBBox?.clone() ?? new BBox(x, y, width, height);
  }
  isPointInPath(x, y) {
    return this.hittester(x, y);
  }
  get midPoint() {
    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
  }
  distanceSquared(x, y) {
    return this.distanceCalculator(x, y);
  }
  applyFillAlpha(ctx) {
    const { fillOpacity, microPixelEffectOpacity, opacity } = this;
    ctx.globalAlpha *= opacity * fillOpacity * microPixelEffectOpacity;
  }
  renderStroke(ctx) {
    const { stroke, effectiveStrokeWidth } = this;
    if (stroke && effectiveStrokeWidth) {
      const { globalAlpha } = ctx;
      const {
        strokeOpacity,
        lineDash,
        lineDashOffset,
        lineCap,
        lineJoin,
        borderPath,
        borderClipPath,
        opacity,
        microPixelEffectOpacity
      } = this;
      if (borderClipPath) {
        ctx.clip(borderClipPath.getPath2D());
      }
      ctx.strokeStyle = stroke;
      ctx.globalAlpha *= opacity * strokeOpacity * microPixelEffectOpacity;
      ctx.lineWidth = effectiveStrokeWidth;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      ctx.stroke(borderPath.getPath2D());
      ctx.globalAlpha = globalAlpha;
    }
  }
};
Rect.className = "Rect";
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "x", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "y", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "width", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "height", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "topLeftCornerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "topRightCornerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "bottomRightCornerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "bottomLeftCornerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "clipBBox", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "crisp", 2);

// packages/ag-charts-community/src/chart/background/background.ts
var Background = class extends BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.rectNode = new Rect();
    this.textNode = new Text();
    this.fill = "white";
    this.node = this.createNode();
    this.node.append([this.rectNode, this.textNode]);
    this.visible = true;
    this.destroyFns.push(
      ctx.scene.attachNode(this.node),
      ctx.layoutManager.addListener("layout:complete", (e) => this.onLayoutComplete(e))
    );
  }
  createNode() {
    return new Group({ name: "background", zIndex: 0 /* SERIES_BACKGROUND */ });
  }
  onLayoutComplete(e) {
    const { width, height } = e.chart;
    this.rectNode.width = width;
    this.rectNode.height = height;
  }
};
__decorateClass([
  Validate(BOOLEAN),
  ProxyPropertyOnWrite("node", "visible")
], Background.prototype, "visible", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true }),
  ProxyPropertyOnWrite("rectNode", "fill")
], Background.prototype, "fill", 2);
__decorateClass([
  Validate(OBJECT, { optional: true })
], Background.prototype, "image", 2);
__decorateClass([
  Validate(STRING, { optional: true }),
  ProxyPropertyOnWrite("textNode")
], Background.prototype, "text", 2);

// packages/ag-charts-community/src/chart/background/backgroundModule.ts
var BackgroundModule = {
  type: "root",
  optionsKey: "background",
  packageType: "community",
  chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"],
  moduleFactory: (ctx) => new Background(ctx)
};

// packages/ag-charts-community/src/chart/gridLayout.ts
function gridLayout({
  orientation,
  bboxes,
  maxHeight,
  maxWidth,
  itemPaddingY = 0,
  itemPaddingX = 0,
  forceResult = false
}) {
  const horizontal = orientation === "horizontal";
  const primary = {
    max: horizontal ? maxWidth : maxHeight,
    fn: horizontal ? (b) => b.width : (b) => b.height,
    padding: horizontal ? itemPaddingX : itemPaddingY
  };
  const secondary = {
    max: horizontal ? maxHeight : maxWidth,
    fn: horizontal ? (b) => b.height : (b) => b.width,
    padding: horizontal ? itemPaddingY : itemPaddingX
  };
  let processedBBoxCount = 0;
  const rawPages = [];
  while (processedBBoxCount < bboxes.length) {
    const unprocessedBBoxes = bboxes.slice(processedBBoxCount);
    const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);
    if (!result) {
      return;
    }
    processedBBoxCount += result.processedBBoxCount;
    rawPages.push(result.pageIndices);
  }
  return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);
}
function processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {
  const minGuess = 1;
  let startingGuess = estimateStartingGuess(bboxes, primary);
  if (startingGuess < minGuess) {
    if (!forceResult) {
      return;
    }
    startingGuess = minGuess;
  }
  let guess = startingGuess;
  while (guess >= minGuess) {
    const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);
    if (pageIndices == null && guess <= minGuess) {
      return;
    }
    if (pageIndices == null) {
      guess--;
      continue;
    }
    if (typeof pageIndices === "number") {
      if (pageIndices <= minGuess) {
        return;
      }
      guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;
      guess--;
      continue;
    }
    const processedBBoxCount = pageIndices.length * pageIndices[0].length;
    return { processedBBoxCount, pageIndices };
  }
}
function calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {
  const result = [];
  let sumSecondary = 0;
  let currentMaxSecondary = 0;
  let currentPrimaryIndices = [];
  const maxPrimaryValues = [];
  for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {
    const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;
    if (primaryValueIdx === 0) {
      sumSecondary += currentMaxSecondary;
      currentMaxSecondary = 0;
      if (currentPrimaryIndices.length > 0) {
        result.push(currentPrimaryIndices);
      }
      currentPrimaryIndices = [];
    }
    const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;
    maxPrimaryValues[primaryValueIdx] = Math.max(maxPrimaryValues[primaryValueIdx] ?? 0, primaryValue);
    currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);
    const currentSecondaryDimension = sumSecondary + currentMaxSecondary;
    const returnResult = !forceResult || result.length > 0;
    if (currentSecondaryDimension > secondary.max && returnResult) {
      currentPrimaryIndices = [];
      break;
    }
    const sumPrimary = maxPrimaryValues.reduce((sum, next) => sum + next, 0);
    if (sumPrimary > primary.max && !forceResult) {
      if (maxPrimaryValues.length < primaryCount) {
        return maxPrimaryValues.length;
      }
      return;
    }
    currentPrimaryIndices.push(bboxIndex + indexOffset);
  }
  if (currentPrimaryIndices.length > 0) {
    result.push(currentPrimaryIndices);
  }
  return result.length > 0 ? result : void 0;
}
function buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {
  let maxPageWidth = 0;
  let maxPageHeight = 0;
  const pages = rawPages.map((indices) => {
    if (orientation === "horizontal") {
      indices = transpose(indices);
    }
    let endIndex = 0;
    const columns = indices.map((colIndices) => {
      const colBBoxes = colIndices.map((bboxIndex) => {
        endIndex = Math.max(bboxIndex, endIndex);
        return bboxes[bboxIndex];
      });
      let columnHeight = 0;
      let columnWidth = 0;
      colBBoxes.forEach((bbox) => {
        columnHeight += bbox.height + itemPaddingY;
        columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);
      });
      return {
        indices: colIndices,
        bboxes: colBBoxes,
        columnHeight: Math.ceil(columnHeight),
        columnWidth: Math.ceil(columnWidth)
      };
    });
    let pageWidth = 0;
    let pageHeight = 0;
    columns.forEach((column) => {
      pageWidth += column.columnWidth;
      pageHeight = Math.max(pageHeight, column.columnHeight);
    });
    maxPageWidth = Math.max(pageWidth, maxPageWidth);
    maxPageHeight = Math.max(pageHeight, maxPageHeight);
    return {
      columns,
      startIndex: indices[0][0],
      endIndex,
      pageWidth,
      pageHeight
    };
  });
  return { pages, maxPageWidth, maxPageHeight };
}
function transpose(data) {
  const result = [];
  for (const _ of data[0]) {
    result.push([]);
  }
  data.forEach((innerData, dataIdx) => {
    innerData.forEach((item, itemIdx) => {
      result[itemIdx][dataIdx] = item;
    });
  });
  return result;
}
function estimateStartingGuess(bboxes, primary) {
  const n = bboxes.length;
  let primarySum = 0;
  for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {
    primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;
    if (primarySum > primary.max) {
      const ratio2 = n / bboxIndex;
      if (ratio2 < 2) {
        return Math.ceil(n / 2);
      }
      return bboxIndex;
    }
  }
  return n;
}

// packages/ag-charts-community/src/scene/image.ts
var Image = class extends Node {
  constructor(sourceImage) {
    super();
    this.sourceImage = sourceImage;
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.opacity = 1;
  }
  updateBitmap(newBitmap, bitmapPixelRatio, x, y) {
    this.sourceImage = newBitmap;
    this.width = newBitmap.width / bitmapPixelRatio;
    this.height = newBitmap.height / bitmapPixelRatio;
    this.x = x / bitmapPixelRatio;
    this.y = y / bitmapPixelRatio;
    this.markDirty(3 /* MAJOR */);
  }
  render(renderCtx) {
    const { ctx, forceRender, stats } = renderCtx;
    if (this.dirty === 0 /* NONE */ && !forceRender) {
      if (stats)
        stats.nodesSkipped++;
      return;
    }
    const image = this.sourceImage;
    if (!image)
      return;
    ctx.globalAlpha = this.opacity;
    ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);
    super.render(renderCtx);
  }
};
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Image.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Image.prototype, "y", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Image.prototype, "width", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Image.prototype, "height", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Image.prototype, "opacity", 2);

// packages/ag-charts-community/src/chart/legendMarkerLabel.ts
var LegendMarkerLabel = class extends Translatable(Group) {
  constructor() {
    super({ name: "markerLabelGroup" });
    this.label = new Text();
    this.symbolsGroup = new Group({
      name: "legend-markerLabel-symbols"
    });
    this.bitmap = new Image();
    this.bitmapDirty = true;
    this.enabled = true;
    this.pageIndex = NaN;
    this._markers = [];
    this._lines = [];
    const { markers, label, lines } = this;
    label.textBaseline = "middle";
    label.fontSize = 12;
    label.fontFamily = "Verdana, sans-serif";
    label.fill = "black";
    label.y = 1;
    this.updateSymbols(markers, lines);
    this.append([this.symbolsGroup, label]);
  }
  destroy() {
    super.destroy();
    this.destroyProxyButton();
  }
  destroyProxyButton() {
    this.proxyButton?.button.remove();
    this.proxyButton?.listitem.remove();
    this.proxyButton = void 0;
  }
  get markers() {
    return this._markers;
  }
  get lines() {
    return this._lines;
  }
  updateSymbols(markers, lines) {
    if (arraysEqual(this._markers, markers) && arraysEqual(this._lines, lines))
      return;
    this.bitmapDirty = true;
    this._markers = markers;
    this._lines = lines;
    this.symbolsGroup.clear();
    this.symbolsGroup.append([this.bitmap, ...lines, ...markers]);
  }
  setEnabled(enabled) {
    this.enabled = enabled;
    this.refreshVisibilities();
  }
  refreshVisibilities() {
    const opacity = this.enabled ? 1 : 0.5;
    this.label.opacity = opacity;
    this.opacity = opacity;
    this.bitmap.opacity = opacity;
    this.setBitmapVisibility(!this.enabled);
  }
  setBitmapVisibility(visible) {
    const { lines, markers } = this;
    [lines, markers].forEach((shapes) => shapes.forEach((shape) => shape.visible = !visible));
    this.bitmap.visible = visible;
  }
  // The BBox of this.bitmap is `spritePadding` pixels bigger in each direction than BBox of the markers and lines.
  // This padding allows the SpriteRenderer to draw antialiasing pixels that can extend beyond the shapes' bounds.
  update(spriteRenderer, { spriteAAPadding, spritePixelRatio: scale2 }, dimensionProps) {
    const { markers, lines } = this;
    let spriteX = 0;
    let spriteY = 0;
    let shift = 0;
    for (let i = 0; i < Math.max(markers.length, lines.length); i++) {
      const { length: length2, spacing, isCustomMarker } = dimensionProps[i] ?? 0;
      const marker = markers[i];
      const line = lines[i];
      const size = marker?.size ?? 0;
      let lineTop = Infinity;
      let lineX1 = Infinity;
      let lineX2 = Infinity;
      let markerTop = Infinity;
      let markerLeft = Infinity;
      if (marker) {
        const center = marker.constructor.center;
        const radius = (size + marker.strokeWidth) / 2;
        if (isCustomMarker) {
          marker.x = 0;
          marker.y = 0;
          marker.translationX = (center.x - 0.5) * size + length2 / 2 + shift;
          marker.translationY = (center.y - 0.5) * size;
          markerTop = marker.translationY - radius;
          markerLeft = marker.translationX - radius;
        } else {
          marker.x = (center.x - 0.5) * size + length2 / 2 + shift;
          marker.y = (center.y - 0.5) * size;
          markerTop = marker.y - radius;
          markerLeft = marker.x - radius;
        }
      }
      if (line) {
        line.x1 = shift;
        line.x2 = shift + length2;
        line.y1 = 0;
        line.y2 = 0;
        line.markDirty(3 /* MAJOR */);
        lineTop = -line.strokeWidth / 2;
        lineX1 = line.x1;
        lineX2 = line.x2;
      }
      shift += spacing + Math.max(length2, size);
      spriteX = Math.min(spriteX, lineX1, lineX2, markerLeft);
      spriteY = Math.min(spriteY, lineTop, markerTop);
    }
    const lastSymbolProps = dimensionProps.at(-1);
    const lastLine = this.lines.at(-1);
    const lastMarker = this.markers.at(-1);
    const lineEnd = lastLine ? lastLine.x2 : -Infinity;
    const markerEnd = (lastMarker?.x ?? 0) + (lastMarker?.size ?? 0) / 2;
    this.label.x = Math.max(lineEnd, markerEnd) + (lastSymbolProps?.spacing ?? 0);
    if (this.bitmapDirty) {
      this.setBitmapVisibility(false);
      const translateX = (spriteAAPadding + spriteX) * scale2;
      const translateY = (spriteAAPadding - spriteY) * scale2;
      const sprite = spriteRenderer.renderSprite(this.symbolsGroup, {
        scale: scale2,
        translateX: Math.floor(translateX),
        translateY: Math.floor(translateY)
      });
      this.bitmap.updateBitmap(sprite, scale2, Math.ceil(-translateX), Math.ceil(-translateY));
      this.bitmapDirty = false;
      this.refreshVisibilities();
    }
    if (dimensionProps.length < 2) {
      return;
    }
    const bbox = this.symbolsGroup.getBBox();
    const clippedWidth = Math.max(lastMarker?.size ?? 0, lastSymbolProps?.length ?? 0);
    const clipRect = new BBox(bbox.x + clippedWidth / 2, bbox.y, clippedWidth, bbox.height);
    this.symbolsGroup.setClipRect(clipRect);
  }
  computeBBox() {
    const { label, lines, markers } = this;
    return this.toParent(Group.computeChildrenBBox(iterate([label], lines, markers), false));
  }
};
LegendMarkerLabel.className = "MarkerLabel";
__decorateClass([
  ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "text", 2);
__decorateClass([
  ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "fontStyle", 2);
__decorateClass([
  ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "fontWeight", 2);
__decorateClass([
  ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "fontSize", 2);
__decorateClass([
  ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "fontFamily", 2);
__decorateClass([
  ProxyPropertyOnWrite("label", "fill")
], LegendMarkerLabel.prototype, "color", 2);

// packages/ag-charts-community/src/chart/pagination/pagination.ts
var PaginationLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.color = "black";
    this.fontStyle = void 0;
    this.fontWeight = void 0;
    this.fontSize = 12;
    this.fontFamily = "Verdana, sans-serif";
  }
};
__decorateClass([
  Validate(COLOR_STRING)
], PaginationLabel.prototype, "color", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true })
], PaginationLabel.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT, { optional: true })
], PaginationLabel.prototype, "fontWeight", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PaginationLabel.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING)
], PaginationLabel.prototype, "fontFamily", 2);
var PaginationMarkerStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.size = 15;
    this.fill = void 0;
    this.fillOpacity = void 0;
    this.stroke = void 0;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PaginationMarkerStyle.prototype, "size", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], PaginationMarkerStyle.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], PaginationMarkerStyle.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], PaginationMarkerStyle.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PaginationMarkerStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO)
], PaginationMarkerStyle.prototype, "strokeOpacity", 2);
var PaginationMarker = class extends BaseProperties {
  constructor(parent) {
    super();
    this.parent = parent;
    this.shape = Triangle;
    this.size = 15;
    this.padding = 8;
  }
};
__decorateClass([
  ActionOnSet({
    changeValue() {
      if (this.parent.marker === this) {
        this.parent.onMarkerShapeChange();
      }
    }
  })
], PaginationMarker.prototype, "shape", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PaginationMarker.prototype, "size", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PaginationMarker.prototype, "padding", 2);
var Pagination = class extends BaseProperties {
  constructor(chartUpdateCallback, pageUpdateCallback) {
    super();
    this.chartUpdateCallback = chartUpdateCallback;
    this.pageUpdateCallback = pageUpdateCallback;
    this.id = createId(this);
    this.marker = new PaginationMarker(this);
    this.activeStyle = new PaginationMarkerStyle();
    this.inactiveStyle = new PaginationMarkerStyle();
    this.highlightStyle = new PaginationMarkerStyle();
    this.label = new PaginationLabel();
    this.group = new TranslatableGroup({ name: "pagination" });
    this.labelNode = new Text();
    this.destroyFns = [];
    this.totalPages = 0;
    this.currentPage = 0;
    this.translationX = 0;
    this.translationY = 0;
    this.nextButtonDisabled = false;
    this.previousButtonDisabled = false;
    this._visible = true;
    this._enabled = true;
    this._orientation = "vertical";
    this._nextButton = new Triangle();
    this._previousButton = new Triangle();
    this.labelNode.setProperties({
      textBaseline: "middle",
      fontSize: 12,
      fontFamily: "Verdana, sans-serif",
      fill: "black",
      y: 1
    });
    this.group.append([this.nextButton, this.previousButton, this.labelNode]);
    this.update();
    this.updateMarkers();
  }
  destroy() {
    this.destroyFns.forEach((f) => f());
  }
  set visible(value) {
    this._visible = value;
    this.updateGroupVisibility();
  }
  get visible() {
    return this._visible;
  }
  set enabled(value) {
    this._enabled = value;
    this.updateGroupVisibility();
  }
  get enabled() {
    return this._enabled;
  }
  updateGroupVisibility() {
    this.group.visible = this.enabled && this.visible;
  }
  set orientation(value) {
    this._orientation = value;
    switch (value) {
      case "horizontal": {
        this.previousButton.rotation = -Math.PI / 2;
        this.nextButton.rotation = Math.PI / 2;
        break;
      }
      case "vertical":
      default: {
        this.previousButton.rotation = 0;
        this.nextButton.rotation = Math.PI;
      }
    }
  }
  get orientation() {
    return this._orientation;
  }
  set nextButton(value) {
    if (this._nextButton !== value) {
      this.group.removeChild(this._nextButton);
      this._nextButton = value;
      this.group.appendChild(value);
    }
  }
  get nextButton() {
    return this._nextButton;
  }
  set previousButton(value) {
    if (this._previousButton !== value) {
      this.group.removeChild(this._previousButton);
      this._previousButton = value;
      this.group.appendChild(value);
    }
  }
  get previousButton() {
    return this._previousButton;
  }
  update() {
    this.updateLabel();
    this.updatePositions();
    this.enableOrDisableButtons();
  }
  updatePositions() {
    this.group.translationX = this.translationX;
    this.group.translationY = this.translationY;
    this.updateLabelPosition();
    this.updateNextButtonPosition();
  }
  updateLabelPosition() {
    const { size: markerSize, padding: markerPadding } = this.marker;
    this.nextButton.size = markerSize;
    this.previousButton.size = markerSize;
    this.labelNode.x = markerSize / 2 + markerPadding;
  }
  updateNextButtonPosition() {
    const labelBBox = this.labelNode.getBBox();
    this.nextButton.translationX = labelBBox.width + (this.marker.size / 2 + this.marker.padding) * 2;
  }
  updateLabel() {
    const {
      currentPage,
      totalPages: pages,
      labelNode,
      label: { color, fontStyle, fontWeight, fontSize, fontFamily }
    } = this;
    labelNode.text = `${currentPage + 1} / ${pages}`;
    labelNode.fill = color;
    labelNode.fontStyle = fontStyle;
    labelNode.fontWeight = fontWeight;
    labelNode.fontSize = fontSize;
    labelNode.fontFamily = fontFamily;
  }
  updateMarkers() {
    const {
      nextButton,
      previousButton,
      nextButtonDisabled,
      previousButtonDisabled,
      activeStyle,
      inactiveStyle,
      highlightStyle,
      highlightActive
    } = this;
    const buttonStyle = (button, disabled) => {
      if (disabled) {
        return inactiveStyle;
      } else if (button === highlightActive) {
        return highlightStyle;
      }
      return activeStyle;
    };
    this.updateMarker(nextButton, buttonStyle("next", nextButtonDisabled));
    this.updateMarker(previousButton, buttonStyle("previous", previousButtonDisabled));
  }
  updateMarker(marker, style) {
    const { size } = this.marker;
    marker.size = size;
    marker.fill = style.fill;
    marker.fillOpacity = style.fillOpacity ?? 1;
    marker.stroke = style.stroke;
    marker.strokeWidth = style.strokeWidth;
    marker.strokeOpacity = style.strokeOpacity;
  }
  enableOrDisableButtons() {
    const { currentPage, totalPages } = this;
    const zeroPagesToDisplay = totalPages === 0;
    const onLastPage = currentPage === totalPages - 1;
    const onFirstPage = currentPage === 0;
    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;
    this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;
  }
  setPage(pageNumber) {
    pageNumber = clamp(0, pageNumber, this.totalPages - 1);
    if (this.currentPage !== pageNumber) {
      this.currentPage = pageNumber;
      this.onPaginationChanged();
    }
  }
  getCursor(node) {
    return { previous: this.previousButtonDisabled, next: this.nextButtonDisabled }[node] ? void 0 : "pointer";
  }
  onClick(event, node) {
    event.preventDefault();
    if (node === "next" && !this.nextButtonDisabled) {
      this.incrementPage();
      this.onPaginationChanged();
    } else if (node === "previous" && !this.previousButtonDisabled) {
      this.decrementPage();
      this.onPaginationChanged();
    }
  }
  onMouseHover(node) {
    this.highlightActive = node;
    this.updateMarkers();
    this.chartUpdateCallback(6 /* SCENE_RENDER */);
  }
  onPaginationChanged() {
    this.pageUpdateCallback(this.currentPage);
  }
  incrementPage() {
    this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);
  }
  decrementPage() {
    this.currentPage = Math.max(this.currentPage - 1, 0);
  }
  onMarkerShapeChange() {
    const Marker2 = Rotatable(getMarker(this.marker.shape || Triangle));
    this.previousButton = new Marker2();
    this.nextButton = new Marker2();
    this.updatePositions();
    this.updateMarkers();
    this.chartUpdateCallback(6 /* SCENE_RENDER */);
  }
  attachPagination(node) {
    node.append(this.group);
  }
  getBBox() {
    return this.group.getBBox();
  }
  computeCSSBounds() {
    const prev = Transformable.toCanvas(this.previousButton);
    const next = Transformable.toCanvas(this.nextButton);
    return { prev, next };
  }
};
Pagination.className = "Pagination";
__decorateClass([
  Validate(OBJECT)
], Pagination.prototype, "marker", 2);
__decorateClass([
  Validate(OBJECT)
], Pagination.prototype, "activeStyle", 2);
__decorateClass([
  Validate(OBJECT)
], Pagination.prototype, "inactiveStyle", 2);
__decorateClass([
  Validate(OBJECT)
], Pagination.prototype, "highlightStyle", 2);
__decorateClass([
  Validate(OBJECT)
], Pagination.prototype, "label", 2);

// packages/ag-charts-community/src/chart/legend.ts
var LegendLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.maxLength = void 0;
    this.color = "black";
    this.fontStyle = void 0;
    this.fontWeight = void 0;
    this.fontSize = 12;
    this.fontFamily = "Verdana, sans-serif";
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], LegendLabel.prototype, "maxLength", 2);
__decorateClass([
  Validate(COLOR_STRING)
], LegendLabel.prototype, "color", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true })
], LegendLabel.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT, { optional: true })
], LegendLabel.prototype, "fontWeight", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LegendLabel.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING)
], LegendLabel.prototype, "fontFamily", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], LegendLabel.prototype, "formatter", 2);
var LegendMarker = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.size = 15;
    this.padding = 8;
  }
};
__decorateClass([
  ObserveChanges((target) => target.parent?.onMarkerShapeChange())
], LegendMarker.prototype, "shape", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LegendMarker.prototype, "size", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LegendMarker.prototype, "padding", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], LegendMarker.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(BOOLEAN)
], LegendMarker.prototype, "enabled", 2);
var LegendLine = class extends BaseProperties {
};
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], LegendLine.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], LegendLine.prototype, "length", 2);
var LegendItem = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.paddingX = 16;
    this.paddingY = 8;
    this.showSeriesStroke = false;
    this.marker = new LegendMarker();
    this.label = new LegendLabel();
    this.line = new LegendLine();
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], LegendItem.prototype, "maxWidth", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LegendItem.prototype, "paddingX", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LegendItem.prototype, "paddingY", 2);
__decorateClass([
  Validate(BOOLEAN)
], LegendItem.prototype, "showSeriesStroke", 2);
__decorateClass([
  Validate(OBJECT)
], LegendItem.prototype, "marker", 2);
__decorateClass([
  Validate(OBJECT)
], LegendItem.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], LegendItem.prototype, "line", 2);
var LegendListeners = class extends BaseProperties {
};
__decorateClass([
  Validate(FUNCTION, { optional: true })
], LegendListeners.prototype, "legendItemClick", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], LegendListeners.prototype, "legendItemDoubleClick", 2);
var ID_LEGEND_VISIBILITY = "legend-visibility";
var ID_LEGEND_OTHER_SERIES = "legend-other-series";
var LegendItemEvent = class {
  constructor(type, enabled, itemId, seriesId, event) {
    this.type = type;
    this.enabled = enabled;
    this.itemId = itemId;
    this.seriesId = seriesId;
    this.event = event;
    this.defaultPrevented = false;
  }
  preventDefault() {
    this.defaultPrevented = true;
  }
};
var Legend = class extends BaseProperties {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.id = createId(this);
    this.group = new TranslatableLayer({ name: "legend", zIndex: 15 /* LEGEND */ });
    this.itemSelection = Selection.select(
      this.group,
      LegendMarkerLabel
    );
    this.spriteRenderer = void 0;
    this.oldSize = [0, 0];
    this.pages = [];
    this.maxPageSize = [0, 0];
    /** Item index to track on re-pagination, so current page updates appropriately. */
    this.paginationTrackingIndex = 0;
    this.truncatedItems = /* @__PURE__ */ new Set();
    this._data = [];
    this._symbolsDirty = true;
    this.toggleSeries = true;
    this.item = new LegendItem();
    this.listeners = new LegendListeners();
    this.enabled = true;
    this.position = "bottom";
    this.spacing = 20;
    this.destroyFns = [];
    this.proxyLegendDirty = true;
    this.proxyLegendToolbarDestroyFns = new DestroyFns();
    this.size = [0, 0];
    this._visible = true;
    this.item.marker.parent = this;
    this.pagination = new Pagination(
      (type) => ctx.updateService.update(type),
      (page) => this.updatePageNumber(page)
    );
    this.pagination.attachPagination(this.group);
    this.destroyFns.push(
      ctx.contextMenuRegistry.registerDefaultAction({
        id: ID_LEGEND_VISIBILITY,
        type: "legend",
        label: "contextMenuToggleSeriesVisibility",
        action: (params) => this.contextToggleVisibility(params)
      }),
      ctx.contextMenuRegistry.registerDefaultAction({
        id: ID_LEGEND_OTHER_SERIES,
        type: "legend",
        label: "contextMenuToggleOtherSeries",
        action: (params) => this.contextToggleOtherSeries(params)
      })
    );
    this.destroyFns.push(
      ctx.layoutManager.registerElement(1 /* Legend */, (e) => this.positionLegend(e)),
      ctx.localeManager.addListener("locale-changed", () => this.onLocaleChanged()),
      () => this.group.remove()
    );
    this.proxyLegendToolbar = this.ctx.proxyInteractionService.createProxyContainer({
      type: "list",
      id: `${this.id}-toolbar`,
      classList: ["ag-charts-proxy-legend-toolbar"],
      ariaLabel: { id: "ariaLabelLegend" },
      ariaHidden: true
    });
    this.proxyLegendPagination = this.ctx.proxyInteractionService.createProxyContainer({
      type: "group",
      id: `${this.id}-pagination`,
      classList: ["ag-charts-proxy-legend-pagination"],
      ariaLabel: { id: "ariaLabelLegendPagination" },
      ariaOrientation: "horizontal",
      ariaHidden: true
    });
    this.proxyLegendItemDescription = createElement("p");
    this.proxyLegendItemDescription.style.display = "none";
    this.proxyLegendItemDescription.id = `${this.id}-ariaDescription`;
    this.proxyLegendItemDescription.textContent = this.getItemAriaDescription();
    this.proxyLegendToolbar.append(this.proxyLegendItemDescription);
  }
  set data(value) {
    this.onDataUpdate(this._data, value);
    this._data = value;
    this._symbolsDirty = true;
    this.updateGroupVisibility();
  }
  get data() {
    return this._data;
  }
  destroy() {
    this.ctx.domManager.removeChild("canvas-overlay", `${this.id}-toolbar`);
    this.ctx.domManager.removeChild("canvas-overlay", `${this.id}-pagination`);
    this.destroyFns.forEach((f) => f());
    this.pagination.destroy();
    this.itemSelection.clear();
    this.proxyLegendToolbarDestroyFns.destroy();
  }
  initLegendItemToolbar() {
    if (!this.proxyLegendDirty)
      return;
    this.itemSelection.each((markerLabel, _, i) => {
      markerLabel.destroyProxyButton();
      markerLabel.proxyButton ?? (markerLabel.proxyButton = this.ctx.proxyInteractionService.createProxyElement({
        type: "listswitch",
        id: `ag-charts-legend-item-${i}`,
        textContent: this.getItemAriaText(i),
        ariaChecked: !!markerLabel.datum.enabled,
        ariaDescribedBy: this.proxyLegendItemDescription.id,
        parent: this.proxyLegendToolbar,
        // Retrieve the datum from the node rather than from the method parameter.
        // The method parameter `datum` gets destroyed when the data is refreshed
        // using Series.getLegendData(). But the scene node will stay the same.
        onclick: (ev) => this.onClick(ev, markerLabel.datum, markerLabel.proxyButton.button),
        ondblclick: (ev) => this.onDoubleClick(ev, markerLabel.datum),
        onmouseenter: (ev) => this.onHover(ev, markerLabel),
        onmouseleave: () => this.onLeave(),
        oncontextmenu: (ev) => this.onContextClick(ev, markerLabel),
        onblur: () => this.onLeave(),
        onfocus: (ev) => this.onHover(ev, markerLabel)
      }));
    });
    const buttons = this.itemSelection.nodes().map((markerLabel) => markerLabel.proxyButton?.button).filter(isDefined);
    this.proxyLegendToolbarDestroyFns.setFns([
      ...initRovingTabIndex({ orientation: "horizontal", buttons }),
      ...initRovingTabIndex({ orientation: "vertical", buttons })
    ]);
    this.proxyLegendToolbar.ariaHidden = (buttons.length === 0).toString();
    this.proxyLegendDirty = false;
  }
  onDataUpdate(oldData, newData) {
    this.proxyLegendDirty = oldData.length !== newData.length || oldData.some((_v, index, _a) => {
      const [newValue, oldValue] = [newData[index], oldData[index]];
      return newValue.id !== oldValue.id;
    });
  }
  onMarkerShapeChange() {
    this.itemSelection.clear();
    this.group.markDirty(2 /* MINOR */);
  }
  getOrientation() {
    if (this.orientation !== void 0) {
      return this.orientation;
    }
    switch (this.position) {
      case "right":
      case "left":
        return "vertical";
      case "bottom":
      case "top":
        return "horizontal";
    }
  }
  set visible(value) {
    this._visible = value;
    this.updateGroupVisibility();
  }
  get visible() {
    return this._visible;
  }
  updateGroupVisibility() {
    this.group.visible = this.enabled && this.visible && this.data.length > 0;
  }
  attachLegend(scene) {
    scene.appendChild(this.group);
  }
  getItemLabel(datum) {
    const {
      ctx: { callbackCache }
    } = this;
    const { formatter } = this.item.label;
    if (formatter) {
      return callbackCache.call(formatter, {
        itemId: datum.itemId,
        value: datum.label.text,
        seriesId: datum.seriesId
      });
    }
    return datum.label.text;
  }
  /**
   * The method is given the desired size of the legend, which only serves as a hint.
   * The vertically oriented legend will take as much horizontal space as needed, but will
   * respect the height constraints, and the horizontal legend will take as much vertical
   * space as needed in an attempt not to exceed the given width.
   * After the layout is done, the {@link size} will contain the actual size of the legend.
   * If the actual size is not the same as the previous actual size, the legend will fire
   * the 'layoutChange' event to communicate that another layout is needed, and the above
   * process should be repeated.
   * @param width
   * @param height
   */
  calcLayout(width, height) {
    const {
      paddingX,
      paddingY,
      label,
      maxWidth,
      label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily }
    } = this.item;
    const data = [...this.data];
    if (this.reverseOrder) {
      data.reverse();
    }
    this.itemSelection.update(data);
    this.initLegendItemToolbar();
    const bboxes = [];
    const font = TextUtils.toFontString(label);
    const itemMaxWidthPercentage = 0.8;
    const maxItemWidth = maxWidth ?? width * itemMaxWidthPercentage;
    const spriteDims = this.calculateSpriteDimensions();
    this.spriteRenderer ?? (this.spriteRenderer = new SpriteRenderer());
    this.spriteRenderer.resize(spriteDims);
    this.itemSelection.each((markerLabel, datum) => {
      markerLabel.fontStyle = fontStyle;
      markerLabel.fontWeight = fontWeight;
      markerLabel.fontSize = fontSize;
      markerLabel.fontFamily = fontFamily;
      const paddedSymbolWidth = this.updateMarkerLabel(this.spriteRenderer, markerLabel, datum, spriteDims);
      const id = datum.itemId ?? datum.id;
      const labelText = this.getItemLabel(datum);
      const text = (labelText ?? "<unknown>").replace(/\r?\n/g, " ");
      markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedSymbolWidth, font, id);
      bboxes.push(markerLabel.getBBox());
    });
    this._symbolsDirty = false;
    width = Math.max(1, width);
    height = Math.max(1, height);
    if (!isFinite(width)) {
      return {};
    }
    const size = this.size;
    const oldSize = this.oldSize;
    size[0] = width;
    size[1] = height;
    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
      oldSize[0] = size[0];
      oldSize[1] = size[1];
    }
    const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width, height);
    const oldPages = this.pages;
    this.pages = pages;
    this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];
    const pageNumber = this.pagination.currentPage;
    const page = this.pages[pageNumber];
    if (this.pages.length < 1 || !page) {
      this.visible = false;
      return { oldPages };
    }
    this.visible = true;
    this.updatePositions(pageNumber);
    this.update();
    return { oldPages };
  }
  isCustomMarker(markerEnabled, shape) {
    return markerEnabled && shape !== void 0 && typeof shape !== "string";
  }
  calcSymbolsEnabled(symbol) {
    const { showSeriesStroke, marker } = this.item;
    const markerEnabled = !!marker.enabled || !showSeriesStroke || (symbol.marker.enabled ?? true);
    const lineEnabled = !!(symbol.line && showSeriesStroke);
    const isCustomMarker = this.isCustomMarker(markerEnabled, symbol.marker.shape);
    return { markerEnabled, lineEnabled, isCustomMarker };
  }
  calcSymbolsLengths(symbol) {
    const { marker, line } = this.item;
    const { markerEnabled, lineEnabled } = this.calcSymbolsEnabled(symbol);
    const { strokeWidth: markerStrokeWidth } = this.getMarkerStyles(symbol);
    const { strokeWidth: lineStrokeWidth } = lineEnabled ? this.getLineStyles(symbol) : { strokeWidth: 0 };
    let customMarkerSize;
    const { shape } = symbol.marker;
    if (this.isCustomMarker(markerEnabled, shape)) {
      const tmpShape = new shape();
      tmpShape.updatePath();
      const bbox = tmpShape.getBBox();
      customMarkerSize = Math.max(bbox.width, bbox.height);
    }
    const markerLength = markerEnabled ? marker.size : 0;
    const lineLength = lineEnabled ? line.length ?? 25 : 0;
    return { markerLength, markerStrokeWidth, lineLength, lineStrokeWidth, customMarkerSize };
  }
  calculateSpriteDimensions() {
    let spriteAAPadding = 0;
    let spriteWidth = 0;
    let spriteHeight = 0;
    let markerWidth = 0;
    this.itemSelection.each((_, datum) => {
      datum.symbols.forEach((symbol) => {
        const {
          markerLength,
          markerStrokeWidth,
          lineLength,
          lineStrokeWidth,
          customMarkerSize = -Infinity
        } = this.calcSymbolsLengths(symbol);
        const markerTotalLength = markerLength + markerStrokeWidth;
        markerWidth = Math.max(markerWidth, lineLength, customMarkerSize, markerLength);
        spriteWidth = Math.max(spriteWidth, lineLength, customMarkerSize, markerTotalLength);
        spriteHeight = Math.max(spriteHeight, lineStrokeWidth, markerTotalLength);
        spriteAAPadding = Math.max(spriteAAPadding, markerStrokeWidth + 0.5);
      });
    });
    spriteWidth += spriteAAPadding * 2;
    spriteHeight += spriteAAPadding * 2;
    const spritePixelRatio = getWindow().devicePixelRatio;
    return { spritePixelRatio, spriteAAPadding, spriteWidth, spriteHeight, markerWidth };
  }
  updateMarkerLabel(spriteRenderer, markerLabel, datum, spriteDims) {
    const { marker: itemMarker, paddingX } = this.item;
    const { markerWidth } = spriteDims;
    const dimensionProps = [];
    let paddedSymbolWidth = paddingX;
    if (this._symbolsDirty) {
      const markers = [];
      const lines = [];
      datum.symbols.forEach((symbol) => {
        const { shape: markerShape = symbol.marker.shape } = itemMarker;
        const MarkerCtr = getMarker(markerShape);
        lines.push(new Line({ zIndex: 0 }));
        markers.push(new MarkerCtr({ zIndex: 1 }));
      });
      markerLabel.updateSymbols(markers, lines);
    }
    datum.symbols.forEach((symbol, i) => {
      const spacing = symbol.marker.padding ?? itemMarker.padding;
      const { markerEnabled, lineEnabled, isCustomMarker } = this.calcSymbolsEnabled(symbol);
      markerLabel.markers[i].size = markerEnabled || !lineEnabled ? itemMarker.size : 0;
      dimensionProps.push({ length: markerWidth, spacing, isCustomMarker });
      if (markerEnabled || lineEnabled) {
        paddedSymbolWidth += spacing + markerWidth;
      }
      const marker = markerLabel.markers[i];
      const line = markerLabel.lines[i];
      if (marker) {
        const { strokeWidth, fill, stroke, fillOpacity, strokeOpacity } = this.getMarkerStyles(symbol);
        marker.fill = fill;
        marker.stroke = stroke;
        marker.strokeWidth = strokeWidth;
        marker.fillOpacity = fillOpacity;
        marker.strokeOpacity = strokeOpacity;
      }
      if (line) {
        const lineStyles = this.getLineStyles(symbol);
        line.stroke = lineStyles.stroke;
        line.strokeOpacity = lineStyles.strokeOpacity;
        line.strokeWidth = lineStyles.strokeWidth;
        line.lineDash = lineStyles.lineDash;
      }
    });
    markerLabel.update(spriteRenderer, spriteDims, dimensionProps);
    return paddedSymbolWidth;
  }
  truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, font, id) {
    let addEllipsis = false;
    if (text.length > maxCharLength) {
      text = text.substring(0, maxCharLength);
      addEllipsis = true;
    }
    const measurer = CachedTextMeasurerPool.getMeasurer({ font });
    const result = TextWrapper.truncateLine(text, measurer, maxItemWidth - paddedMarkerWidth, addEllipsis);
    if (result.endsWith(TextUtils.EllipsisChar)) {
      this.truncatedItems.add(id);
    } else {
      this.truncatedItems.delete(id);
    }
    return result;
  }
  updatePagination(bboxes, width, height) {
    const orientation = this.getOrientation();
    const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);
    this.pagination.orientation = orientation;
    this.pagination.translationX = 0;
    this.pagination.translationY = 0;
    const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(
      bboxes,
      width,
      height
    );
    const newCurrentPage = pages.findIndex((p) => p.endIndex >= trackingIndex);
    this.pagination.currentPage = clamp(0, newCurrentPage, pages.length - 1);
    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;
    const paginationComponentPadding = 8;
    const legendItemsWidth = maxPageWidth - itemPaddingX;
    const legendItemsHeight = maxPageHeight - itemPaddingY;
    let paginationX = 0;
    let paginationY = -paginationBBox.y - this.item.marker.size / 2;
    if (paginationVertical) {
      paginationY += legendItemsHeight + paginationComponentPadding;
    } else {
      paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;
      paginationY += (legendItemsHeight - paginationBBox.height) / 2;
    }
    this.pagination.translationX = paginationX;
    this.pagination.translationY = paginationY;
    this.pagination.update();
    this.pagination.updateMarkers();
    let pageIndex = 0;
    this.itemSelection.each((markerLabel, _, nodeIndex) => {
      if (nodeIndex > (pages[pageIndex]?.endIndex ?? Infinity)) {
        pageIndex++;
      }
      markerLabel.pageIndex = pageIndex;
    });
    return {
      maxPageHeight,
      maxPageWidth,
      pages
    };
  }
  updateItemProxyButtons() {
    const pointer = this.toggleSeries ? "pointer" : void 0;
    const maxHeight = Math.max(...this.itemSelection.nodes().map((l) => l.getBBox().height));
    this.itemSelection.each((l) => {
      if (l.proxyButton) {
        const { listitem, button } = l.proxyButton;
        const visible = l.pageIndex === this.pagination.currentPage;
        let bbox = Transformable.toCanvas(l);
        if (bbox.height !== maxHeight) {
          const margin = (maxHeight - bbox.height) / 2;
          bbox = { x: bbox.x, y: bbox.y - margin, height: maxHeight, width: bbox.width };
        }
        setElementStyle(button, "pointer-events", visible ? "auto" : "none");
        setElementStyle(button, "cursor", pointer);
        setElementBBox(listitem, bbox);
      }
    });
  }
  updatePaginationProxyButtons(oldPages) {
    this.proxyLegendPagination.style.display = this.pagination.visible ? "absolute" : "none";
    const oldNeedsButtons = (oldPages?.length ?? this.pages.length) > 1;
    const newNeedsButtons = this.pages.length > 1;
    if (oldNeedsButtons !== newNeedsButtons) {
      if (newNeedsButtons) {
        this.proxyPrevButton = this.ctx.proxyInteractionService.createProxyElement({
          type: "button",
          id: `${this.id}-prev-page`,
          textContent: { id: "ariaLabelLegendPagePrevious" },
          tabIndex: 0,
          parent: this.proxyLegendPagination,
          onclick: (ev) => this.pagination.onClick(ev, "previous"),
          onmouseenter: () => this.pagination.onMouseHover("previous"),
          onmouseleave: () => this.pagination.onMouseHover(void 0)
        });
        this.proxyNextButton ?? (this.proxyNextButton = this.ctx.proxyInteractionService.createProxyElement({
          type: "button",
          id: `${this.id}-next-page`,
          textContent: { id: "ariaLabelLegendPageNext" },
          tabIndex: 0,
          parent: this.proxyLegendPagination,
          onclick: (ev) => this.pagination.onClick(ev, "next"),
          onmouseenter: () => this.pagination.onMouseHover("next"),
          onmouseleave: () => this.pagination.onMouseHover(void 0)
        }));
        this.proxyLegendPagination.ariaHidden = "false";
      } else {
        this.proxyNextButton?.remove();
        this.proxyPrevButton?.remove();
        [this.proxyNextButton, this.proxyPrevButton] = [void 0, void 0];
        this.proxyLegendPagination.ariaHidden = "true";
      }
    }
    const { prev, next } = this.pagination.computeCSSBounds();
    setElementBBox(this.proxyPrevButton, prev);
    setElementBBox(this.proxyNextButton, next);
    setElementStyle(this.proxyNextButton, "cursor", this.pagination.getCursor("next"));
    setElementStyle(this.proxyPrevButton, "cursor", this.pagination.getCursor("previous"));
  }
  calculatePagination(bboxes, width, height) {
    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;
    const orientation = this.getOrientation();
    const paginationVertical = ["left", "right"].includes(this.position);
    let paginationBBox = this.pagination.getBBox();
    let lastPassPaginationBBox = new BBox(0, 0, 0, 0);
    let pages = [];
    let maxPageWidth = 0;
    let maxPageHeight = 0;
    let count = 0;
    const stableOutput = (bbox) => {
      return bbox.width === paginationBBox.width && bbox.height === paginationBBox.height;
    };
    const forceResult = this.maxWidth !== void 0 && this.maxHeight !== void 0;
    do {
      if (count++ > 10) {
        Logger.warn("unable to find stable legend layout.");
        break;
      }
      paginationBBox = lastPassPaginationBBox;
      const maxWidth = width - (paginationVertical ? 0 : paginationBBox.width);
      const maxHeight = height - (paginationVertical ? paginationBBox.height : 0);
      const layout = gridLayout({
        orientation,
        bboxes,
        maxHeight,
        maxWidth,
        itemPaddingY,
        itemPaddingX,
        forceResult
      });
      pages = layout?.pages ?? [];
      maxPageWidth = layout?.maxPageWidth ?? 0;
      maxPageHeight = layout?.maxPageHeight ?? 0;
      const totalPages = pages.length;
      this.pagination.visible = totalPages > 1;
      this.pagination.totalPages = totalPages;
      this.pagination.update();
      this.pagination.updateMarkers();
      lastPassPaginationBBox = this.pagination.getBBox();
      if (!this.pagination.visible) {
        break;
      }
    } while (!stableOutput(lastPassPaginationBBox));
    return { maxPageWidth, maxPageHeight, pages, paginationBBox: lastPassPaginationBBox, paginationVertical };
  }
  updatePositions(pageNumber = 0) {
    const {
      item: { paddingY },
      itemSelection,
      pages
    } = this;
    if (pages.length < 1 || !pages[pageNumber]) {
      return;
    }
    const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];
    let x = 0;
    let y = 0;
    const columnCount = columns.length;
    const rowCount = columns[0].indices.length;
    const horizontal = this.getOrientation() === "horizontal";
    const itemHeight = columns[0].bboxes[0].height + paddingY;
    const rowSumColumnWidths = [];
    itemSelection.each((markerLabel, _, i) => {
      if (i < visibleStart || i > visibleEnd) {
        markerLabel.visible = false;
        return;
      }
      const pageIndex = i - visibleStart;
      let columnIndex;
      let rowIndex;
      if (horizontal) {
        columnIndex = pageIndex % columnCount;
        rowIndex = Math.floor(pageIndex / columnCount);
      } else {
        columnIndex = Math.floor(pageIndex / rowCount);
        rowIndex = pageIndex % rowCount;
      }
      markerLabel.visible = true;
      const column = columns[columnIndex];
      if (!column) {
        return;
      }
      y = Math.floor(itemHeight * rowIndex);
      x = Math.floor(rowSumColumnWidths[rowIndex] ?? 0);
      rowSumColumnWidths[rowIndex] = (rowSumColumnWidths[rowIndex] ?? 0) + column.columnWidth;
      markerLabel.translationX = x;
      markerLabel.translationY = y;
    });
    this.updateItemProxyButtons();
  }
  updatePageNumber(pageNumber) {
    const { pages } = this;
    const { startIndex, endIndex } = pages[pageNumber];
    if (startIndex === 0) {
      this.paginationTrackingIndex = 0;
    } else if (pageNumber === pages.length - 1) {
      this.paginationTrackingIndex = endIndex;
    } else {
      this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);
    }
    this.pagination.update();
    this.pagination.updateMarkers();
    this.updatePositions(pageNumber);
    setElementStyle(this.proxyNextButton, "cursor", this.pagination.getCursor("next"));
    setElementStyle(this.proxyPrevButton, "cursor", this.pagination.getCursor("previous"));
    this.ctx.updateService.update(6 /* SCENE_RENDER */);
  }
  update() {
    const {
      label: { color }
    } = this.item;
    this.itemSelection.each((markerLabel, datum) => {
      markerLabel.setEnabled(datum.enabled);
      markerLabel.color = color;
    });
    this.updateContextMenu();
  }
  updateContextMenu() {
    const {
      toggleSeries,
      ctx: { contextMenuRegistry }
    } = this;
    if (toggleSeries) {
      contextMenuRegistry.hideAction(ID_LEGEND_VISIBILITY);
      contextMenuRegistry.hideAction(ID_LEGEND_OTHER_SERIES);
    } else {
      contextMenuRegistry.showAction(ID_LEGEND_VISIBILITY);
      contextMenuRegistry.showAction(ID_LEGEND_OTHER_SERIES);
    }
  }
  getLineStyles(datum) {
    const { stroke, strokeOpacity = 1, strokeWidth, lineDash } = datum.line ?? {};
    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);
    return {
      stroke,
      strokeOpacity,
      strokeWidth: this.item.line.strokeWidth ?? defaultLineStrokeWidth,
      lineDash
    };
  }
  getMarkerStyles(datum) {
    const { fill, stroke, strokeOpacity = 1, fillOpacity = 1, strokeWidth } = datum.marker;
    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);
    return {
      fill,
      stroke,
      strokeOpacity,
      fillOpacity,
      strokeWidth: this.item.marker.strokeWidth ?? defaultLineStrokeWidth
    };
  }
  computePagedBBox() {
    const actualBBox = Group.computeChildrenBBox(this.group.children());
    if (this.pages.length > 1) {
      const [maxPageWidth, maxPageHeight] = this.maxPageSize;
      actualBBox.height = Math.max(maxPageHeight, actualBBox.height);
      actualBBox.width = Math.max(maxPageWidth, actualBBox.width);
    }
    return actualBBox;
  }
  findNode(params) {
    const { datum, proxyButton } = this.itemSelection.select((ml) => ml.datum?.itemId === params.itemId)[0] ?? {};
    if (datum === void 0 || proxyButton === void 0) {
      throw new Error(`AG Charts - Missing required properties { datum: ${datum}, proxyButton: ${proxyButton} }`);
    }
    return { datum, proxyButton };
  }
  contextToggleVisibility(params) {
    const { datum, proxyButton } = this.findNode(params);
    this.doClick(params.event, datum, proxyButton.button);
  }
  contextToggleOtherSeries(params) {
    this.doDoubleClick(params.event, this.findNode(params).datum);
  }
  onContextClick(sourceEvent, node) {
    const legendItem = node.datum;
    if (this.preventHidingAll && this.contextMenuDatum?.enabled && this.getVisibleItemCount() <= 1) {
      this.ctx.contextMenuRegistry.disableAction(ID_LEGEND_VISIBILITY);
    } else {
      this.ctx.contextMenuRegistry.enableAction(ID_LEGEND_VISIBILITY);
    }
    const { button, offsetX, offsetY } = sourceEvent;
    const { x: canvasOffsetX, y: canvasOffsetY } = Transformable.toCanvasPoint(node, offsetX, offsetY);
    const event = {
      type: "contextmenu",
      sourceEvent,
      button,
      offsetX: canvasOffsetX,
      offsetY: canvasOffsetY,
      deltaX: 0,
      deltaY: 0,
      pageX: NaN,
      pageY: NaN,
      preventDefault: () => sourceEvent.preventDefault(),
      pointerHistory: []
    };
    this.ctx.contextMenuRegistry.dispatchContext("legend", event, { legendItem });
  }
  onClick(event, datum, proxyButton) {
    if (this.doClick(event, datum, proxyButton)) {
      event.preventDefault();
    }
  }
  getVisibleItemCount() {
    return this.ctx.chartService.series.flatMap((s) => s.getLegendData("category")).filter((d) => d.enabled).length;
  }
  doClick(event, datum, proxyButton) {
    const {
      listeners: { legendItemClick },
      ctx: { chartService, highlightManager },
      preventHidingAll,
      toggleSeries
    } = this;
    if (!datum) {
      return false;
    }
    const { id, itemId, enabled } = datum;
    const series = chartService.series.find((s) => s.id === id);
    if (!series) {
      return false;
    }
    let newEnabled = enabled;
    const clickEvent = new LegendItemEvent("click", newEnabled, itemId, series.id, event);
    legendItemClick?.(clickEvent);
    if (clickEvent.defaultPrevented)
      return true;
    if (toggleSeries) {
      newEnabled = !enabled;
      if (preventHidingAll && !newEnabled) {
        const numVisibleItems = this.getVisibleItemCount();
        if (numVisibleItems < 2) {
          newEnabled = true;
        }
      }
      proxyButton.ariaChecked = newEnabled.toString();
      this.ctx.chartEventManager.legendItemClick(series, itemId, newEnabled, datum.legendItemName);
    }
    if (newEnabled) {
      highlightManager.updateHighlight(this.id, {
        series,
        itemId,
        datum: void 0
      });
    } else {
      highlightManager.updateHighlight(this.id);
    }
    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });
    return true;
  }
  onDoubleClick(event, datum) {
    if (this.doDoubleClick(event, datum)) {
      event.preventDefault();
    }
  }
  doDoubleClick(event, datum) {
    const {
      listeners: { legendItemDoubleClick },
      ctx: { chartService },
      toggleSeries
    } = this;
    if (chartService.mode === "integrated") {
      return false;
    }
    if (!datum) {
      return false;
    }
    const { id, itemId, seriesId } = datum;
    const series = chartService.series.find((s) => s.id === id);
    if (!series) {
      return false;
    }
    const doubleClickEvent = new LegendItemEvent("dblclick", true, itemId, series.id, event);
    legendItemDoubleClick?.(doubleClickEvent);
    if (doubleClickEvent.defaultPrevented)
      return true;
    if (toggleSeries) {
      const legendData = chartService.series.flatMap((s) => s.getLegendData("category"));
      const numVisibleItems = legendData.filter((d) => d.enabled).length;
      const clickedItem = legendData.find((d) => d.itemId === itemId && d.seriesId === seriesId);
      this.ctx.chartEventManager.legendItemDoubleClick(
        series,
        itemId,
        clickedItem?.enabled ?? false,
        numVisibleItems,
        clickedItem?.legendItemName
      );
    }
    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });
    return true;
  }
  toTooltipMeta(event, node) {
    let lastPointerEvent;
    if (event instanceof FocusEvent) {
      const { x, y } = Transformable.toCanvas(node).computeCenter();
      lastPointerEvent = { type: "keyboard", offsetX: x, offsetY: y };
    } else {
      event.preventDefault();
      const { x, y } = Transformable.toCanvasPoint(node, event.offsetX, event.offsetY);
      lastPointerEvent = { type: "hover", offsetX: x, offsetY: y };
    }
    const { offsetX, offsetY } = lastPointerEvent;
    return { offsetX, offsetY, lastPointerEvent, showArrow: false };
  }
  onHover(event, node) {
    if (!this.enabled)
      throw new Error("AG Charts - onHover handler called on disabled legend");
    this.pagination.setPage(node.pageIndex);
    const datum = node.datum;
    const series = datum ? this.ctx.chartService.series.find((s) => s.id === datum?.id) : void 0;
    if (datum && this.truncatedItems.has(datum.itemId ?? datum.id)) {
      const meta = this.toTooltipMeta(event, node);
      this.ctx.tooltipManager.updateTooltip(this.id, meta, toTooltipHtml({ content: this.getItemLabel(datum) }));
    } else {
      this.ctx.tooltipManager.removeTooltip(this.id);
    }
    if (datum?.enabled && series) {
      this.updateHighlight({ series, itemId: datum?.itemId, datum: void 0 });
    } else {
      this.updateHighlight();
    }
  }
  onLeave() {
    this.ctx.tooltipManager.removeTooltip(this.id);
    this.updateHighlight();
  }
  updateHighlight(datum) {
    const state = this.ctx.interactionManager.getState();
    if (state === 32 /* Default */) {
      this.ctx.highlightManager.updateHighlight(this.id, datum);
    } else if (state === 2 /* Animation */) {
      this.pendingHighlightDatum = datum;
      this.ctx.animationManager.onBatchStop(() => {
        this.ctx.highlightManager.updateHighlight(this.id, this.pendingHighlightDatum);
      });
    }
  }
  onLocaleChanged() {
    this.itemSelection.each(({ proxyButton }, _, i) => {
      if (proxyButton?.button != null) {
        proxyButton.button.textContent = this.getItemAriaText(i);
      }
    });
    this.proxyLegendItemDescription.textContent = this.getItemAriaDescription();
  }
  getItemAriaText(nodeIndex) {
    const datum = this.data[nodeIndex];
    const label = datum && this.getItemLabel(datum);
    const lm = this.ctx.localeManager;
    if (nodeIndex >= 0 && label) {
      const index = nodeIndex + 1;
      const count = this.data.length;
      return lm.t("ariaLabelLegendItem", { label, index, count });
    }
    return lm.t("ariaLabelLegendItemUnknown");
  }
  getItemAriaDescription() {
    return this.ctx.localeManager.t("ariaDescriptionLegendItem");
  }
  positionLegend(ctx) {
    setElementStyle(this.proxyLegendToolbar, "display", this.visible && this.enabled ? void 0 : "none");
    if (!this.enabled || !this.data.length)
      return;
    const { layoutBox } = ctx;
    const { x, y, width, height } = layoutBox;
    const [legendWidth, legendHeight] = this.calculateLegendDimensions(layoutBox);
    const { oldPages } = this.calcLayout(legendWidth, legendHeight);
    const legendBBox = this.computePagedBBox();
    const calculateTranslationPerpendicularDimension = () => {
      switch (this.position) {
        case "top":
        case "left":
          return 0;
        case "bottom":
          return height - legendBBox.height;
        case "right":
        default:
          return width - legendBBox.width;
      }
    };
    if (this.visible) {
      const legendPadding = this.spacing;
      let translationX;
      let translationY;
      switch (this.position) {
        case "top":
        case "bottom":
          translationX = (width - legendBBox.width) / 2;
          translationY = calculateTranslationPerpendicularDimension();
          layoutBox.shrink(legendBBox.height + legendPadding, this.position);
          break;
        case "left":
        case "right":
        default:
          translationX = calculateTranslationPerpendicularDimension();
          translationY = (height - legendBBox.height) / 2;
          layoutBox.shrink(legendBBox.width + legendPadding, this.position);
      }
      this.group.translationX = Math.floor(x + translationX - legendBBox.x);
      this.group.translationY = Math.floor(y + translationY - legendBBox.y);
      this.proxyLegendToolbar.ariaOrientation = this.getOrientation();
    }
    this.updateItemProxyButtons();
    this.updatePaginationProxyButtons(oldPages);
  }
  calculateLegendDimensions(shrinkRect) {
    const { width, height } = shrinkRect;
    const aspectRatio = width / height;
    const maxCoefficient = 0.5;
    const minHeightCoefficient = 0.2;
    const minWidthCoefficient = 0.25;
    let legendWidth, legendHeight;
    switch (this.position) {
      case "top":
      case "bottom": {
        const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;
        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : width;
        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : Math.round(height * heightCoefficient);
        break;
      }
      case "left":
      case "right":
      default: {
        const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;
        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : Math.round(width * widthCoefficient);
        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : height;
      }
    }
    return [legendWidth, legendHeight];
  }
};
Legend.className = "Legend";
__decorateClass([
  Validate(BOOLEAN)
], Legend.prototype, "toggleSeries", 2);
__decorateClass([
  Validate(OBJECT)
], Legend.prototype, "pagination", 2);
__decorateClass([
  Validate(OBJECT)
], Legend.prototype, "item", 2);
__decorateClass([
  Validate(OBJECT)
], Legend.prototype, "listeners", 2);
__decorateClass([
  ObserveChanges((target) => target.updateGroupVisibility()),
  Validate(BOOLEAN)
], Legend.prototype, "enabled", 2);
__decorateClass([
  ObserveChanges((target) => target.proxyLegendDirty = true),
  Validate(POSITION)
], Legend.prototype, "position", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], Legend.prototype, "maxWidth", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], Legend.prototype, "maxHeight", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], Legend.prototype, "reverseOrder", 2);
__decorateClass([
  Validate(UNION(["horizontal", "vertical"], "an orientation"), { optional: true })
], Legend.prototype, "orientation", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], Legend.prototype, "preventHidingAll", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Legend.prototype, "spacing", 2);

// packages/ag-charts-community/src/chart/legendModule.ts
var CommunityLegendModule = {
  type: "legend",
  optionsKey: "legend",
  identifier: "category",
  chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"],
  moduleFactory: (ctx) => new Legend(ctx),
  packageType: "community"
};

// packages/ag-charts-community/src/chart/navigator/shapes/rangeHandle.ts
var RangeHandle = class extends Path {
  constructor() {
    super(...arguments);
    this.zIndex = 3;
    this.centerX = 0;
    this.centerY = 0;
    this.width = 8;
    this.height = 16;
    this.gripLineGap = 2;
    this.gripLineLength = 8;
  }
  setCenter(x, y) {
    this.dirtyPath = true;
    if (this.centerX !== x || this.centerY !== y) {
      this.centerX = x;
      this.centerY = y;
      this.markDirty(3 /* MAJOR */);
    }
  }
  static align(minHandle, maxHandle, x, y, width, height, min, max) {
    const handlePixelAlign = minHandle.strokeWidth / 2;
    const minHandleX = minHandle.align(x + width * min) + handlePixelAlign;
    const maxHandleX = minHandleX + minHandle.align(x + width * min, width * (max - min)) - 2 * handlePixelAlign;
    const handleY = minHandle.align(y + height / 2) + handlePixelAlign;
    minHandle.setCenter(minHandleX, handleY);
    maxHandle.setCenter(maxHandleX, handleY);
  }
  computeBBox() {
    const { centerX, centerY, width, height } = this;
    const x = centerX - width / 2;
    const y = centerY - height / 2;
    return new BBox(x, y, width, height);
  }
  isPointInPath(x, y) {
    const bbox = this.getBBox();
    return bbox.containsPoint(x, y);
  }
  updatePath() {
    const { centerX, centerY, path, strokeWidth, gripLineGap, gripLineLength } = this;
    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;
    path.clear();
    const halfWidth = Math.floor(this.width / 2 * pixelRatio) / pixelRatio;
    const halfHeight = Math.floor(this.height / 2 * pixelRatio) / pixelRatio;
    path.moveTo(centerX - halfWidth, centerY - halfHeight);
    path.lineTo(centerX + halfWidth, centerY - halfHeight);
    path.lineTo(centerX + halfWidth, centerY + halfHeight);
    path.lineTo(centerX - halfWidth, centerY + halfHeight);
    path.closePath();
    const dx = Math.floor((gripLineGap + strokeWidth) / 2 * pixelRatio) / pixelRatio;
    const dy = Math.floor(gripLineLength / 2 * pixelRatio) / pixelRatio;
    path.moveTo(centerX - dx, centerY - dy);
    path.lineTo(centerX - dx, centerY + dy);
    path.moveTo(centerX + dx, centerY - dy);
    path.lineTo(centerX + dx, centerY + dy);
  }
};
RangeHandle.className = "RangeHandle";
__decorateClass([
  Validate(POSITIVE_NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: "path" })
], RangeHandle.prototype, "width", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: "path" })
], RangeHandle.prototype, "height", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: "path" })
], RangeHandle.prototype, "gripLineGap", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: "path" })
], RangeHandle.prototype, "gripLineLength", 2);

// packages/ag-charts-community/src/chart/navigator/shapes/rangeMask.ts
var RangeMask = class extends Path {
  constructor() {
    super(...arguments);
    this.zIndex = 2;
    this.x = 0;
    this.y = 0;
    this.width = 200;
    this.height = 30;
    this.min = 0;
    this.max = 1;
  }
  layout(x, y, width, height) {
    if (x !== this.x || y !== this.y || width !== this.width || this.height !== height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.dirtyPath = true;
      this.markDirty(3 /* MAJOR */);
    }
  }
  update(min, max) {
    min = isNaN(min) ? this.min : min;
    max = isNaN(max) ? this.max : max;
    if (min !== this.min || max !== this.max) {
      this.min = min;
      this.max = max;
      this.dirtyPath = true;
      this.markDirty(3 /* MAJOR */);
    }
  }
  computeBBox() {
    const { x, y, width, height } = this;
    return new BBox(x, y, width, height);
  }
  computeVisibleRangeBBox() {
    const { x, y, width, height, min, max } = this;
    const minX = x + width * min;
    const maxX = x + width * max;
    return new BBox(minX, y, maxX - minX, height);
  }
  updatePath() {
    const { path, x, y, width, height, min, max, strokeWidth } = this;
    const pixelAlign = strokeWidth / 2;
    path.clear();
    const ax = this.align(x) + pixelAlign;
    const ay = this.align(y) + pixelAlign;
    const axw = ax + this.align(x, width) - 2 * pixelAlign;
    const ayh = ay + this.align(y, height) - 2 * pixelAlign;
    path.moveTo(ax, ay);
    path.lineTo(axw, ay);
    path.lineTo(axw, ayh);
    path.lineTo(ax, ayh);
    path.closePath();
    const minX = this.align(x + width * min) + pixelAlign;
    const maxX = minX + this.align(x + width * min, width * (max - min)) - 2 * pixelAlign;
    path.moveTo(minX, ay);
    path.lineTo(minX, ayh);
    path.lineTo(maxX, ayh);
    path.lineTo(maxX, ay);
    path.closePath();
  }
};
RangeMask.className = "RangeMask";

// packages/ag-charts-community/src/chart/navigator/shapes/rangeSelector.ts
var RangeSelector = class extends Layer {
  constructor(children) {
    super({ name: "rangeSelectorGroup", zIndex: 16 /* NAVIGATOR */ });
    this.x = 0;
    this.y = 0;
    this.width = 200;
    this.height = 30;
    this.lOffset = 0;
    this.rOffset = 0;
    this.background = this.appendChild(new TranslatableGroup({ name: "navigator-background", zIndex: 1 }));
    this.append(children);
  }
  layout(x, y, width, height, lOffset, rOffset) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.lOffset = lOffset;
    this.rOffset = rOffset;
    this.background.translationX = x;
    this.background.translationY = y;
    this.markDirty(3 /* MAJOR */);
  }
  updateBackground(oldGroup, newGroup) {
    if (oldGroup != null) {
      this.background.removeChild(oldGroup);
    }
    if (newGroup != null) {
      this.background.appendChild(newGroup);
    }
    this.markDirty(3 /* MAJOR */);
  }
  computeBBox() {
    const { x, y, width, height, lOffset, rOffset } = this;
    return new BBox(x - lOffset, y, width + (lOffset + rOffset), height);
  }
};

// packages/ag-charts-community/src/chart/navigator/navigator.ts
var Navigator = class extends BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.miniChart = void 0;
    this.enabled = false;
    this.mask = new RangeMask();
    this.minHandle = new RangeHandle();
    this.maxHandle = new RangeHandle();
    this.maskVisibleRange = {
      id: "navigator-mask-visible-range",
      getBBox: () => this.mask.computeVisibleRangeBBox(),
      toCanvasBBox: () => this.mask.computeVisibleRangeBBox(),
      fromCanvasPoint: (x, y) => ({ x, y })
    };
    this.height = 30;
    this.spacing = 10;
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.rangeSelector = new RangeSelector([this.mask, this.minHandle, this.maxHandle]);
    this._min = 0;
    this._max = 1;
    this.minRange = 1e-3;
    const region = ctx.regionManager.addRegion("navigator", this.rangeSelector);
    const dragStates = 32 /* Default */ | 2 /* Animation */ | 16 /* ZoomDrag */;
    this.destroyFns.push(
      ctx.scene.attachNode(this.rangeSelector),
      region.addListener("hover", (event) => this.onHover(event), dragStates),
      region.addListener("drag-start", (event) => this.onDragStart(event), dragStates),
      region.addListener("drag", (event) => this.onDrag(event), dragStates),
      region.addListener("drag-end", (event) => this.onDragEnd(event), dragStates),
      region.addListener("leave", (event) => this.onLeave(event), dragStates),
      this.ctx.localeManager.addListener("locale-changed", () => this.updateZoom()),
      this.ctx.layoutManager.registerElement(3 /* Navigator */, (e) => this.onLayoutStart(e)),
      this.ctx.layoutManager.addListener("layout:complete", (e) => this.onLayoutComplete(e)),
      ctx.zoomManager.addListener("zoom-change", (event) => this.onZoomChange(event))
    );
    this.proxyNavigatorToolbar = this.ctx.proxyInteractionService.createProxyContainer({
      type: "toolbar",
      id: `navigator-toolbar`,
      classList: ["ag-charts-proxy-navigator-toolbar"],
      ariaOrientation: "vertical",
      ariaLabel: { id: "ariaLabelNavigator" }
    });
    this.updateGroupVisibility();
    this.proxyNavigatorElements = [
      this.ctx.proxyInteractionService.createProxyElement({
        type: "slider",
        id: "ag-charts-navigator-min",
        ariaLabel: { id: "ariaLabelNavigatorMinimum" },
        ariaOrientation: "horizontal",
        parent: this.proxyNavigatorToolbar,
        onchange: (ev) => this.onMinSliderChange(ev)
      }),
      this.ctx.proxyInteractionService.createProxyElement({
        type: "slider",
        id: "ag-charts-navigator-pan",
        ariaLabel: { id: "ariaLabelNavigatorRange" },
        ariaOrientation: "horizontal",
        parent: this.proxyNavigatorToolbar,
        onchange: (ev) => this.onPanSliderChange(ev)
      }),
      this.ctx.proxyInteractionService.createProxyElement({
        type: "slider",
        id: "ag-charts-navigator-max",
        ariaLabel: { id: "ariaLabelNavigatorMaximum" },
        ariaOrientation: "horizontal",
        parent: this.proxyNavigatorToolbar,
        onchange: (ev) => this.onMaxSliderChange(ev)
      })
    ];
    this.proxyNavigatorElements.forEach((slider) => setAttribute(slider, "data-preventdefault", false));
    this.setSliderRatio(this.proxyNavigatorElements[0], this._min);
    this.setSliderRatio(this.proxyNavigatorElements[2], this._max);
    this.setPanSliderValue(this._min, this._max);
    initToolbarKeyNav({
      orientation: "vertical",
      toolbar: this.proxyNavigatorToolbar,
      buttons: this.proxyNavigatorElements
    });
    this.destroyFns.push(() => {
      this.proxyNavigatorElements.forEach((e) => e.remove());
      this.proxyNavigatorToolbar.remove();
    });
  }
  updateBackground(oldGroup, newGroup) {
    this.rangeSelector?.updateBackground(oldGroup, newGroup);
  }
  updateGroupVisibility() {
    const { enabled } = this;
    if (this.rangeSelector == null || enabled === this.rangeSelector.visible)
      return;
    this.rangeSelector.visible = enabled;
    this.proxyNavigatorToolbar.ariaHidden = (!enabled).toString();
    if (enabled) {
      this.updateZoom();
    } else {
      this.ctx.zoomManager.updateZoom("navigator");
    }
  }
  onLayoutStart(ctx) {
    if (this.enabled) {
      const { layoutBox } = ctx;
      const navigatorTotalHeight = this.height + this.spacing;
      layoutBox.shrink(navigatorTotalHeight, "bottom");
      this.y = layoutBox.y + layoutBox.height + this.spacing;
    } else {
      this.y = 0;
    }
  }
  onLayoutComplete(opts) {
    const { x, width } = opts.series.rect;
    if (this.enabled) {
      const { y, height } = this;
      this.layoutNodes(x, y, width, height);
      setElementBBox(this.proxyNavigatorToolbar, { x, y, width, height });
      this.proxyNavigatorToolbar.style.removeProperty("display");
    } else {
      this.proxyNavigatorToolbar.style.display = "none";
    }
    this.x = x;
    this.width = width;
  }
  onHover(event) {
    if (!this.enabled)
      return;
    this.updateCursor(event);
  }
  updateCursor(event) {
    if (!this.enabled)
      return;
    const { mask, minHandle, maxHandle } = this;
    const { regionOffsetX, regionOffsetY } = event;
    if (minHandle.containsPoint(regionOffsetX, regionOffsetY) || maxHandle.containsPoint(regionOffsetX, regionOffsetY)) {
      this.ctx.cursorManager.updateCursor("navigator", "ew-resize");
    } else if (mask.computeVisibleRangeBBox().containsPoint(regionOffsetX, regionOffsetY)) {
      this.ctx.cursorManager.updateCursor("navigator", "grab");
    } else {
      this.ctx.cursorManager.updateCursor("navigator");
    }
  }
  onDragStart(event) {
    if (!this.enabled)
      return;
    this.updateCursor(event);
    const { mask, minHandle, maxHandle, x, width, _min: min } = this;
    const { regionOffsetX, regionOffsetY } = event;
    if (minHandle.zIndex < maxHandle.zIndex) {
      if (maxHandle.containsPoint(regionOffsetX, regionOffsetY)) {
        this.dragging = "max";
      } else if (minHandle.containsPoint(regionOffsetX, regionOffsetY)) {
        this.dragging = "min";
      }
    } else if (minHandle.containsPoint(regionOffsetX, regionOffsetY)) {
      this.dragging = "min";
    } else if (maxHandle.containsPoint(regionOffsetX, regionOffsetY)) {
      this.dragging = "max";
    }
    if (this.dragging == null && mask.computeVisibleRangeBBox().containsPoint(regionOffsetX, regionOffsetY)) {
      this.dragging = "pan";
      this.panStart = (regionOffsetX - x) / width - min;
    }
    if (this.dragging != null) {
      this.ctx.zoomManager.fireZoomPanStartEvent("navigator");
    }
  }
  onDrag(event) {
    if (!this.enabled || this.dragging == null)
      return;
    const { dragging, minRange, panStart, x, width } = this;
    let { _min: min, _max: max } = this;
    const { regionOffsetX } = event;
    const ratio2 = (regionOffsetX - x) / width;
    if (dragging === "min") {
      min = clamp(0, ratio2, max - minRange);
    } else if (dragging === "max") {
      max = clamp(min + minRange, ratio2, 1);
    } else if (dragging === "pan" && panStart != null) {
      const span = max - min;
      min = clamp(0, ratio2 - panStart, 1 - span);
      max = min + span;
    }
    this._min = min;
    this._max = max;
    this.updateZoom();
  }
  onDragEnd(event) {
    this.dragging = void 0;
    this.updateCursor(event);
  }
  onLeave(_event) {
    this.ctx.cursorManager.updateCursor("navigator");
  }
  onZoomChange(event) {
    const { x } = event;
    if (!x)
      return;
    this._min = x.min;
    this._max = x.max;
    this.updateNodes(x.min, x.max);
    this.setPanSliderValue(x.min, x.max);
    this.setSliderRatio(this.proxyNavigatorElements[0], x.min);
    this.setSliderRatio(this.proxyNavigatorElements[2], x.max);
  }
  onPanSliderChange(_event) {
    const ratio2 = this.getSliderRatio(this.proxyNavigatorElements[1]);
    const span = this._max - this._min;
    this._min = clamp(0, ratio2, 1 - span);
    this._max = this._min + span;
    this.updateZoom();
  }
  onMinSliderChange(_event) {
    const slider = this.proxyNavigatorElements[0];
    this._min = this.setSliderRatioClamped(slider, 0, this._max - this.minRange);
    this.updateZoom();
  }
  onMaxSliderChange(_event) {
    const slider = this.proxyNavigatorElements[2];
    this._max = this.setSliderRatioClamped(slider, this._min + this.minRange, 1);
    this.updateZoom();
  }
  setPanSliderValue(min, max) {
    this.proxyNavigatorElements[1].value = `${Math.round(min * 100)}`;
    this.proxyNavigatorElements[1].ariaValueText = this.ctx.localeManager.t("ariaValuePanRange", { min, max });
  }
  setSliderRatioClamped(slider, clampMin, clampMax) {
    const ratio2 = this.getSliderRatio(slider);
    const clampedRatio = clamp(clampMin, ratio2, clampMax);
    if (clampedRatio !== ratio2) {
      this.setSliderRatio(slider, clampedRatio);
    }
    return clampedRatio;
  }
  setSliderRatio(slider, ratio2) {
    const value = Math.round(ratio2 * 100);
    slider.value = `${value}`;
    slider.ariaValueText = formatPercentage(value);
  }
  getSliderRatio(slider) {
    return parseFloat(slider.value) / 100;
  }
  layoutNodes(x, y, width, height) {
    const { rangeSelector, mask, minHandle, maxHandle, _min: min, _max: max } = this;
    rangeSelector.layout(x, y, width, height, minHandle.width / 2, maxHandle.width / 2);
    mask.layout(x, y, width, height);
    RangeHandle.align(minHandle, maxHandle, x, y, width, height, min, max);
    if (min + (max - min) / 2 < 0.5) {
      minHandle.zIndex = 3;
      maxHandle.zIndex = 4;
    } else {
      minHandle.zIndex = 4;
      maxHandle.zIndex = 3;
    }
    [minHandle, this.maskVisibleRange, maxHandle].forEach((node, index) => {
      const bbox = node.getBBox();
      const tbox = { x: bbox.x - x, y: bbox.y - y, height: bbox.height, width: bbox.width };
      setElementBBox(this.proxyNavigatorElements[index], tbox);
    });
  }
  updateNodes(min, max) {
    this.mask.update(min, max);
  }
  updateZoom() {
    if (!this.enabled)
      return;
    const { _min: min, _max: max } = this;
    if (min == null || max == null)
      return;
    const warnOnConflict = (stateId) => {
      if (this.min == null && this.max == null)
        return;
      Logger.warnOnce(
        `Could not apply [navigator.min] or [navigator.max] as [${stateId}] has modified the initial zoom state.`
      );
    };
    return this.ctx.zoomManager.updateZoom("navigator", { x: { min, max } }, false, warnOnConflict);
  }
};
__decorateClass([
  Validate(OBJECT, { optional: true })
], Navigator.prototype, "miniChart", 2);
__decorateClass([
  Validate(BOOLEAN),
  ObserveChanges((target) => target.updateGroupVisibility())
], Navigator.prototype, "enabled", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Navigator.prototype, "height", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Navigator.prototype, "spacing", 2);
__decorateClass([
  ActionOnSet({
    newValue(min) {
      this._min = min;
      this.updateZoom();
    }
  }),
  Validate(AND(RATIO, LESS_THAN("max")), { optional: true })
], Navigator.prototype, "min", 2);
__decorateClass([
  ActionOnSet({
    newValue(max) {
      this._max = max;
      this.updateZoom();
    }
  }),
  Validate(AND(RATIO, GREATER_THAN("min")), { optional: true })
], Navigator.prototype, "max", 2);

// packages/ag-charts-community/src/chart/navigator/navigatorModule.ts
var NavigatorModule = {
  type: "root",
  optionsKey: "navigator",
  packageType: "community",
  chartTypes: ["cartesian"],
  moduleFactory: (ctx) => new Navigator(ctx),
  themeTemplate: {
    navigator: {
      enabled: false,
      height: 30,
      mask: {
        fill: "#999999",
        stroke: "#999999",
        strokeWidth: 1,
        fillOpacity: 0.2
      },
      minHandle: {
        fill: "#f2f2f2",
        stroke: "#999999",
        strokeWidth: 1,
        width: 9,
        height: 16,
        gripLineGap: 1,
        gripLineLength: 8
      },
      maxHandle: {
        fill: "#f2f2f2",
        stroke: "#999999",
        strokeWidth: 1,
        width: 9,
        height: 16,
        gripLineGap: 1,
        gripLineLength: 8
      }
    }
  }
};

// packages/ag-charts-community/src/module/theme.ts
function singleSeriesPaletteFactory({ takeColors }) {
  const {
    fills: [fill],
    strokes: [stroke]
  } = takeColors(1);
  return { fill, stroke };
}
function markerPaletteFactory(params) {
  return { marker: singleSeriesPaletteFactory(params) };
}

// packages/ag-charts-community/src/chart/themes/symbols.ts
var IS_DARK_THEME = Symbol("is-dark-theme");
var IS_COMMUNITY = Symbol("is-community");
var IS_ENTERPRISE = Symbol("is-enterprise");
var DEFAULT_FONT_FAMILY = Symbol("default-font");
var DEFAULT_LABEL_COLOUR = Symbol("default-label-colour");
var DEFAULT_INVERTED_LABEL_COLOUR = Symbol("default-inverted-label-colour");
var DEFAULT_INSIDE_SERIES_LABEL_COLOUR = Symbol("default-inside-series-label-colour");
var DEFAULT_MUTED_LABEL_COLOUR = Symbol("default-muted-label-colour");
var DEFAULT_AXIS_GRID_COLOUR = Symbol("default-axis-grid-colour");
var DEFAULT_AXIS_LINE_COLOUR = Symbol("default-axis-line-colour");
var DEFAULT_CROSS_LINES_COLOUR = Symbol("default-cross-lines-colour");
var DEFAULT_BACKGROUND_COLOUR = Symbol("default-background-colour");
var DEFAULT_SHADOW_COLOUR = Symbol("default-shadow-colour");
var DEFAULT_COLOURS = Symbol("default-colours");
var DEFAULT_PADDING = Symbol("default-padding");
var DEFAULT_CAPTION_LAYOUT_STYLE = Symbol("default-caption-layout-style");
var DEFAULT_CAPTION_ALIGNMENT = Symbol("default-caption-alignment");
var PALETTE_UP_STROKE = Symbol("palette-up-stroke");
var PALETTE_DOWN_STROKE = Symbol("palette-down-stroke");
var PALETTE_UP_FILL = Symbol("palette-up-fill");
var PALETTE_DOWN_FILL = Symbol("palette-down-fill");
var PALETTE_NEUTRAL_STROKE = Symbol("palette-neutral-stroke");
var PALETTE_NEUTRAL_FILL = Symbol("palette-neutral-fill");
var PALETTE_ALT_UP_STROKE = Symbol("palette-alt-up-stroke");
var PALETTE_ALT_DOWN_STROKE = Symbol("palette-alt-down-stroke");
var PALETTE_ALT_UP_FILL = Symbol("palette-alt-up-fill");
var PALETTE_ALT_DOWN_FILL = Symbol("palette-alt-down-fill");
var PALETTE_ALT_NEUTRAL_FILL = Symbol("palette-gray-fill");
var PALETTE_ALT_NEUTRAL_STROKE = Symbol("palette-gray-stroke");
var DEFAULT_POLAR_SERIES_STROKE = Symbol("default-polar-series-stroke");
var DEFAULT_DIVERGING_SERIES_COLOR_RANGE = Symbol(
  "default-diverging-series-colour-range"
);
var DEFAULT_GAUGE_SERIES_COLOR_RANGE = Symbol("default-gauge-series-colour-range");
var DEFAULT_FUNNEL_SERIES_COLOR_RANGE = Symbol("default-funnel-series-colour-range");
var DEFAULT_HIERARCHY_FILLS = Symbol("default-hierarchy-fills");
var DEFAULT_HIERARCHY_STROKES = Symbol("default-hierarchy-strokes");
var DEFAULT_ANNOTATION_COLOR = Symbol("default-annotation-stroke");
var DEFAULT_TEXT_ANNOTATION_COLOR = Symbol("default-text-annotation-color");
var DEFAULT_ANNOTATION_BACKGROUND_FILL = Symbol("default-annotation-background-fill");
var DEFAULT_ANNOTATION_HANDLE_FILL = Symbol("default-annotation-handle-fill");
var DEFAULT_ANNOTATION_STATISTICS_FILL = Symbol("default-annotation-statistics-fill");
var DEFAULT_ANNOTATION_STATISTICS_STROKE = Symbol("default-annotation-statistics-stroke");
var DEFAULT_ANNOTATION_STATISTICS_COLOR = Symbol("default-annotation-statistics-color");
var DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE = Symbol(
  "default-annotation-statistics-divider-stroke"
);
var DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL = Symbol(
  "default-annotation-statistics-fill"
);
var DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE = Symbol(
  "default-annotation-statistics-stroke"
);
var DEFAULT_TEXTBOX_FILL = Symbol("default-textbox-fill");
var DEFAULT_TEXTBOX_STROKE = Symbol("default-textbox-stroke");
var DEFAULT_TEXTBOX_COLOR = Symbol("default-textbox-color");
var DEFAULT_TOOLBAR_POSITION = Symbol("default-toolbar-position");
var DEFAULT_GRIDLINE_ENABLED = Symbol("default-gridline-enabled");

// packages/ag-charts-community/src/motion/pathMotion.ts
function pathMotion(groupId, subId, animationManager, paths, fns) {
  const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;
  const animate = (phase, path, updateFn) => {
    animationManager.animate({
      id: `${groupId}_${subId}_${path.id}_${phase}`,
      groupId,
      from: 0,
      to: 1,
      ease: easeOut,
      collapsable: false,
      onUpdate(ratio2, preInit) {
        if (preInit && phase !== "removed")
          return;
        path.path.clear(true);
        updateFn(ratio2, path);
        path.checkPathDirty();
      },
      onStop() {
        if (phase !== "added")
          return;
        path.path.clear(true);
        updateFn(1, path);
        path.checkPathDirty();
      },
      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]
    });
  };
  for (const path of paths) {
    if (!animationManager.isSkipped()) {
      animate("removed", path, removePhaseFn);
      animate("updated", path, updatePhaseFn);
    }
    animate("added", path, addPhaseFn);
  }
}

// packages/ag-charts-community/src/util/format.util.ts
function formatValue(value) {
  if (typeof value === "number") {
    return value.toFixed(2);
  }
  return String(value ?? "");
}

// packages/ag-charts-community/src/util/sanitize.ts
var element = null;
function sanitizeHtml(text) {
  if (text == null) {
    return;
  } else if (text === "") {
    return "";
  }
  element ?? (element = createElement("div"));
  element.textContent = String(text);
  return element.innerHTML;
}

// packages/ag-charts-community/src/util/memo.ts
var memorizedFns = /* @__PURE__ */ new WeakMap();
function memo(params, fnGenerator) {
  const serialisedParams = JSON.stringify(params, null, 0);
  if (!memorizedFns.has(fnGenerator)) {
    memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());
  }
  if (!memorizedFns.get(fnGenerator)?.has(serialisedParams)) {
    memorizedFns.get(fnGenerator)?.set(serialisedParams, fnGenerator(params));
  }
  return memorizedFns.get(fnGenerator)?.get(serialisedParams);
}

// packages/ag-charts-community/src/chart/data/aggregateFunctions.ts
function sumValues(values, accumulator = [0, 0]) {
  for (const value of values) {
    if (typeof value !== "number") {
      continue;
    }
    if (value < 0) {
      accumulator[0] += value;
    }
    if (value > 0) {
      accumulator[1] += value;
    }
  }
  return accumulator;
}
function groupSum(id, matchGroupId) {
  return {
    id,
    type: "aggregate",
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    aggregateFunction: (values) => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0]) => {
      acc[0] += next?.[0] ?? 0;
      acc[1] += next?.[1] ?? 0;
      return acc;
    }
  };
}
function range2(id, matchGroupId) {
  const result = {
    id,
    matchGroupIds: [matchGroupId],
    type: "aggregate",
    aggregateFunction: (values) => ContinuousDomain.extendDomain(values)
  };
  return result;
}
function groupCount(id) {
  return {
    id,
    type: "aggregate",
    aggregateFunction: () => [0, 1],
    groupAggregateFunction: (next, acc = [0, 0]) => {
      acc[0] += next?.[0] ?? 0;
      acc[1] += next?.[1] ?? 0;
      return acc;
    }
  };
}
function groupAverage(id, matchGroupId) {
  const def = {
    id,
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    type: "aggregate",
    aggregateFunction: (values) => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0, -1]) => {
      acc[0] += next?.[0] ?? 0;
      acc[1] += next?.[1] ?? 0;
      acc[2]++;
      return acc;
    },
    finalFunction: (acc = [0, 0, 0]) => {
      const result = acc[0] + acc[1];
      if (result >= 0) {
        return [0, result / acc[2]];
      }
      return [result / acc[2], 0];
    }
  };
  return def;
}
function area(id, aggFn, matchGroupId) {
  const result = {
    id,
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    type: "aggregate",
    aggregateFunction: (values, keyRange = []) => {
      const keyWidth = keyRange[1] - keyRange[0];
      return aggFn.aggregateFunction(values).map((v) => v / keyWidth);
    }
  };
  if (aggFn.groupAggregateFunction) {
    result.groupAggregateFunction = aggFn.groupAggregateFunction;
  }
  return result;
}
function accumulatedValue(onlyPositive) {
  return () => {
    let value = 0;
    return (datum) => {
      if (!isFiniteNumber(datum)) {
        return datum;
      }
      value += onlyPositive ? Math.max(0, datum) : datum;
      return value;
    };
  };
}

// packages/ag-charts-community/src/chart/data/processors.ts
function basicContinuousCheckDatumValidation(value) {
  return value != null && isContinuous(value);
}
function basicDiscreteCheckDatumValidation(value) {
  return value != null;
}
function getValidationFn(scaleType) {
  switch (scaleType) {
    case "number":
    case "log":
    case "ordinal-time":
    case "time":
    case "color":
      return basicContinuousCheckDatumValidation;
    default:
      return basicDiscreteCheckDatumValidation;
  }
}
function getValueType(scaleType) {
  switch (scaleType) {
    case "number":
    case "log":
    case "time":
    case "color":
      return "range";
    default:
      return "category";
  }
}
function keyProperty(propName, scaleType, opts = {}) {
  const result = {
    property: propName,
    type: "key",
    valueType: getValueType(scaleType),
    validation: getValidationFn(scaleType),
    ...opts
  };
  return result;
}
function valueProperty(propName, scaleType, opts = {}) {
  const result = {
    property: propName,
    type: "value",
    valueType: getValueType(scaleType),
    validation: getValidationFn(scaleType),
    ...opts
  };
  return result;
}
function rangedValueProperty(propName, opts = {}) {
  const { min = -Infinity, max = Infinity, ...defOpts } = opts;
  return {
    type: "value",
    property: propName,
    valueType: "range",
    validation: basicContinuousCheckDatumValidation,
    processor: () => (datum) => isFiniteNumber(datum) ? clamp(min, datum, max) : datum,
    ...defOpts
  };
}
function accumulativeValueProperty(propName, scaleType, opts = {}) {
  const { onlyPositive, ...defOpts } = opts;
  const result = {
    ...valueProperty(propName, scaleType, defOpts),
    processor: accumulatedValue(onlyPositive)
  };
  return result;
}
function groupAccumulativeValueProperty(propName, mode, sum = "current", opts, scaleType) {
  return [
    valueProperty(propName, scaleType, opts),
    accumulateGroup(opts.groupId, mode, sum, opts.separateNegative),
    ...opts.rangeId != null ? [range2(opts.rangeId, opts.groupId)] : []
  ];
}
function groupStackValueProperty(propName, scaleType, opts) {
  return [valueProperty(propName, scaleType, opts), accumulateStack(opts.groupId)];
}
var SMALLEST_KEY_INTERVAL = {
  type: "reducer",
  property: "smallestKeyInterval",
  initialValue: Infinity,
  reducer: () => {
    let prevX = NaN;
    return (smallestSoFar = Infinity, next) => {
      const nextX = next.keys[0];
      const interval = Math.abs(nextX - prevX);
      prevX = nextX;
      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {
        return interval;
      }
      return smallestSoFar;
    };
  }
};
var LARGEST_KEY_INTERVAL = {
  type: "reducer",
  property: "largestKeyInterval",
  initialValue: -Infinity,
  reducer: () => {
    let prevX = NaN;
    return (largestSoFar = -Infinity, next) => {
      const nextX = next.keys[0];
      const interval = Math.abs(nextX - prevX);
      prevX = nextX;
      if (!isNaN(interval) && interval > 0 && interval > largestSoFar) {
        return interval;
      }
      return largestSoFar;
    };
  }
};
var SORT_DOMAIN_GROUPS = {
  type: "processor",
  property: "sortedGroupDomain",
  calculate: ({ domain: { groups } }) => groups?.slice().sort((a, b) => {
    for (let i = 0; i < a.length; i++) {
      const result = a[i] - b[i];
      if (result !== 0) {
        return result;
      }
    }
    return 0;
  })
};
function normaliseFnBuilder({ normaliseTo, mode }) {
  const normalise = (val, extent2) => {
    const result = val * normaliseTo / extent2;
    if (result >= 0) {
      return Math.min(normaliseTo, result);
    }
    return Math.max(-normaliseTo, result);
  };
  return () => () => (values, valueIndexes) => {
    const valuesExtent = [0, 0];
    for (const valueIdx of valueIndexes) {
      const value = values[valueIdx];
      const valueExtent = typeof value === "number" ? value : Math.max(...value);
      const valIdx = valueExtent < 0 ? 0 : 1;
      if (mode === "sum") {
        valuesExtent[valIdx] += valueExtent;
      } else if (valIdx === 0) {
        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], valueExtent);
      } else {
        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], valueExtent);
      }
    }
    const extent2 = Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);
    for (const valueIdx of valueIndexes) {
      const value = values[valueIdx];
      values[valueIdx] = typeof value === "number" ? normalise(value, extent2) : value.map((v) => normalise(v, extent2));
    }
  };
}
function normaliseGroupTo(matchGroupIds, normaliseTo, mode = "sum") {
  return {
    type: "group-value-processor",
    matchGroupIds,
    adjust: memo({ normaliseTo, mode }, normaliseFnBuilder)
  };
}
function normalisePropertyFnBuilder({
  normaliseTo,
  zeroDomain,
  rangeMin,
  rangeMax
}) {
  const normaliseSpan = normaliseTo[1] - normaliseTo[0];
  const normalise = (val, start, span) => {
    const result = normaliseTo[0] + (val - start) / span * normaliseSpan;
    if (span === 0) {
      return zeroDomain;
    } else if (result >= normaliseTo[1]) {
      return normaliseTo[1];
    } else if (result < normaliseTo[0]) {
      return normaliseTo[0];
    }
    return result;
  };
  return () => (pData, pIdx) => {
    let [start, end] = pData.domain.values[pIdx];
    if (rangeMin != null)
      start = rangeMin;
    if (rangeMax != null)
      end = rangeMax;
    const span = end - start;
    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];
    for (const group of pData.data) {
      let groupValues = group.values;
      if (pData.type === "ungrouped") {
        groupValues = [groupValues];
      }
      for (const values of groupValues) {
        values[pIdx] = normalise(values[pIdx], start, span);
      }
    }
  };
}
function normalisePropertyTo(property, normaliseTo, zeroDomain, rangeMin, rangeMax) {
  return {
    type: "property-value-processor",
    property,
    adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder)
  };
}
function animationValidation(valueKeyIds) {
  return {
    type: "processor",
    property: "animationValidation",
    calculate(result) {
      const { keys, values } = result.defs;
      const { input, data } = result;
      let uniqueKeys = true;
      let orderedKeys = true;
      const valueKeys = [];
      for (let k = 0; k < values.length; k++) {
        if (!valueKeyIds?.includes(values[k].id))
          continue;
        valueKeys.push([k, values[k]]);
      }
      const processKey = (idx, def, type) => {
        if (def.valueType === "category") {
          const keyValues = result.domain[type][idx];
          uniqueKeys && (uniqueKeys = keyValues.length === input.count);
          return;
        }
        let lastValue = data[0]?.[type][idx];
        for (let d = 1; (uniqueKeys || orderedKeys) && d < data.length; d++) {
          const keyValue = data[d][type][idx];
          orderedKeys && (orderedKeys = lastValue <= keyValue);
          uniqueKeys && (uniqueKeys = lastValue !== keyValue);
          lastValue = keyValue;
        }
      };
      for (let k = 0; (uniqueKeys || orderedKeys) && k < keys.length; k++) {
        processKey(k, keys[k], "keys");
      }
      for (let k = 0; (uniqueKeys || orderedKeys) && k < valueKeys.length; k++) {
        const [idx, key] = valueKeys[k];
        processKey(idx, key, "values");
      }
      return { uniqueKeys, orderedKeys };
    }
  };
}
function buildGroupAccFn({ mode, separateNegative }) {
  return () => () => (values, valueIndexes) => {
    const acc = [0, 0];
    for (const valueIdx of valueIndexes) {
      const currentVal = values[valueIdx];
      const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;
      if (!isFiniteNumber(currentVal))
        continue;
      if (mode === "normal")
        acc[accIndex] += currentVal;
      values[valueIdx] = acc[accIndex];
      if (mode === "trailing")
        acc[accIndex] += currentVal;
    }
  };
}
function buildGroupWindowAccFn({ mode, sum }) {
  return () => {
    const lastValues = [];
    let firstRow = true;
    return () => {
      return (values, valueIndexes) => {
        let acc = 0;
        for (const valueIdx of valueIndexes) {
          const currentVal = values[valueIdx];
          const lastValue = firstRow && sum === "current" ? 0 : lastValues[valueIdx];
          lastValues[valueIdx] = currentVal;
          const sumValue = sum === "current" ? currentVal : lastValue;
          if (!isFiniteNumber(currentVal) || !isFiniteNumber(lastValue)) {
            values[valueIdx] = acc;
            continue;
          }
          if (mode === "normal") {
            acc += sumValue;
          }
          values[valueIdx] = acc;
          if (mode === "trailing") {
            acc += sumValue;
          }
        }
        firstRow = false;
      };
    };
  };
}
function accumulateGroup(matchGroupId, mode, sum, separateNegative = false) {
  let adjust;
  if (mode.startsWith("window")) {
    const modeParam = mode.endsWith("-trailing") ? "trailing" : "normal";
    adjust = memo({ mode: modeParam, sum }, buildGroupWindowAccFn);
  } else {
    adjust = memo({ mode, separateNegative }, buildGroupAccFn);
  }
  return {
    type: "group-value-processor",
    matchGroupIds: [matchGroupId],
    adjust
  };
}
function groupStackAccFn() {
  return () => (values, valueIndexes) => {
    const acc = new Float64Array(32);
    let stackCount = 0;
    for (const valueIdx of valueIndexes) {
      const currentValue = values[valueIdx];
      acc[stackCount] = Number.isFinite(currentValue) ? currentValue : NaN;
      stackCount += 1;
      values[valueIdx] = acc.subarray(0, stackCount);
    }
  };
}
function accumulateStack(matchGroupId) {
  return {
    type: "group-value-processor",
    matchGroupIds: [matchGroupId],
    adjust: groupStackAccFn
  };
}
function diff(previousData, updateMovedData = true) {
  return {
    type: "processor",
    property: "diff",
    calculate: (processedData) => {
      const moved = /* @__PURE__ */ new Map();
      const added = /* @__PURE__ */ new Map();
      const updated = /* @__PURE__ */ new Map();
      const removed = /* @__PURE__ */ new Map();
      const length2 = Math.max(previousData.data.length, processedData.data.length);
      for (let i = 0; i < length2; i++) {
        const prev = previousData.data[i];
        const datum = processedData.data[i];
        const prevId = prev ? createDatumId(prev.keys) : "";
        const datumId = datum ? createDatumId(datum.keys) : "";
        if (datum && prev && prevId === datumId) {
          if (!arraysEqual(prev.values, datum.values)) {
            updated.set(datumId, datum);
          }
          continue;
        }
        if (removed.has(datumId)) {
          if (updateMovedData || !arraysEqual(removed.get(datumId).values, datum.values)) {
            updated.set(datumId, datum);
            moved.set(datumId, datum);
          }
          removed.delete(datumId);
        } else if (datum) {
          added.set(datumId, datum);
        }
        if (added.has(prevId)) {
          if (updateMovedData || !arraysEqual(added.get(prevId).values, prev.values)) {
            updated.set(prevId, prev);
            moved.set(prevId, prev);
          }
          added.delete(prevId);
        } else if (prev) {
          updated.delete(prevId);
          removed.set(prevId, prev);
        }
      }
      const changed = added.size > 0 || updated.size > 0 || removed.size > 0;
      return { changed, added, updated, removed, moved };
    }
  };
}
function createDatumId(keys, ...extraKeys) {
  let result;
  if (isArray(keys)) {
    result = keys.map((key) => transformIntegratedCategoryValue(key)).join("___");
  } else {
    result = transformIntegratedCategoryValue(keys);
  }
  const primitiveType = typeof result === "string" || typeof result === "number" || typeof result === "boolean" || result instanceof Date;
  if (primitiveType && extraKeys.length > 0) {
    result += `___${extraKeys.join("___")}`;
  }
  return result;
}

// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts
function seriesLabelFadeInAnimation({ id }, subId, animationManager, ...labelSelections) {
  staticFromToMotion(
    id,
    subId,
    animationManager,
    labelSelections,
    { opacity: 0 },
    { opacity: 1 },
    { phase: "trailing" }
  );
}
function seriesLabelFadeOutAnimation({ id }, subId, animationManager, ...labelSelections) {
  staticFromToMotion(
    id,
    subId,
    animationManager,
    labelSelections,
    { opacity: 1 },
    { opacity: 0 },
    { phase: "remove" }
  );
}
function resetLabelFn(_node) {
  return { opacity: 1 };
}

// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts
var ChangeDetectableProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this._dirty = 3 /* MAJOR */;
  }
  markDirty(type = 1 /* TRIVIAL */) {
    if (this._dirty < type) {
      this._dirty = type;
    }
  }
  markClean(_opts) {
    this._dirty = 0 /* NONE */;
  }
  isDirty() {
    return this._dirty > 0 /* NONE */;
  }
};

// packages/ag-charts-community/src/scene/dropShadow.ts
var DropShadow = class extends ChangeDetectableProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.color = "rgba(0, 0, 0, 0.5)";
    this.xOffset = 0;
    this.yOffset = 0;
    this.blur = 5;
  }
};
__decorateClass([
  Validate(BOOLEAN),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], DropShadow.prototype, "enabled", 2);
__decorateClass([
  Validate(COLOR_STRING),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], DropShadow.prototype, "color", 2);
__decorateClass([
  Validate(NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], DropShadow.prototype, "xOffset", 2);
__decorateClass([
  Validate(NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], DropShadow.prototype, "yOffset", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], DropShadow.prototype, "blur", 2);

// packages/ag-charts-community/src/chart/series/seriesMarker.ts
var MARKER_SHAPE = predicateWithMessage(
  (value) => isMarkerShape(value) || typeof value === "function" && Object.create(value.prototype) instanceof Marker,
  `a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`
);
var SeriesMarker = class extends ChangeDetectableProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.shape = Circle;
    this.size = 6;
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
  }
  getStyle() {
    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = this;
    return { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };
  }
  getDiameter() {
    return this.size + this.strokeWidth;
  }
};
__decorateClass([
  Validate(BOOLEAN),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "enabled", 2);
__decorateClass([
  Validate(MARKER_SHAPE),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "shape", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "size", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true }),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true }),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true }),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "itemStyler", 2);

// packages/ag-charts-community/src/chart/series/seriesTooltip.ts
var SeriesTooltipInteraction = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = false;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], SeriesTooltipInteraction.prototype, "enabled", 2);
var SeriesTooltip = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.interaction = new SeriesTooltipInteraction();
    this.position = new TooltipPosition();
    this.range = void 0;
  }
  toTooltipHtml(defaults, params) {
    if (this.renderer) {
      return toTooltipHtml(this.renderer(params), defaults);
    }
    return toTooltipHtml(defaults);
  }
};
__decorateClass([
  Validate(BOOLEAN)
], SeriesTooltip.prototype, "enabled", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], SeriesTooltip.prototype, "showArrow", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], SeriesTooltip.prototype, "renderer", 2);
__decorateClass([
  Validate(OBJECT)
], SeriesTooltip.prototype, "interaction", 2);
__decorateClass([
  Validate(OBJECT)
], SeriesTooltip.prototype, "position", 2);
__decorateClass([
  Validate(INTERACTION_RANGE, { optional: true })
], SeriesTooltip.prototype, "range", 2);

// packages/ag-charts-community/src/chart/series/cartesian/interpolationProperties.ts
var INTERPOLATION_TYPE = UNION(["linear", "smooth", "step"], "a line style");
var INTERPOLATION_STEP_POSITION = UNION(["start", "middle", "end"]);
var InterpolationProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.type = "linear";
    this.tension = 1;
    this.position = "end";
  }
};
__decorateClass([
  Validate(INTERPOLATION_TYPE)
], InterpolationProperties.prototype, "type", 2);
__decorateClass([
  Validate(RATIO)
], InterpolationProperties.prototype, "tension", 2);
__decorateClass([
  Validate(INTERPOLATION_STEP_POSITION)
], InterpolationProperties.prototype, "position", 2);

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts
var AreaSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.xName = void 0;
    this.fill = "#c16068";
    this.fillOpacity = 1;
    this.stroke = "#874349";
    this.strokeWidth = 2;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.interpolation = new InterpolationProperties();
    this.shadow = new DropShadow();
    this.marker = new SeriesMarker();
    this.label = new Label();
    this.tooltip = new SeriesTooltip();
    this.connectMissingData = false;
  }
};
__decorateClass([
  Validate(STRING)
], AreaSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], AreaSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate(STRING)
], AreaSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], AreaSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], AreaSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], AreaSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Validate(COLOR_STRING)
], AreaSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO)
], AreaSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING)
], AreaSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AreaSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO)
], AreaSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH)
], AreaSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AreaSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate(OBJECT)
], AreaSeriesProperties.prototype, "interpolation", 2);
__decorateClass([
  Validate(OBJECT)
], AreaSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Validate(OBJECT)
], AreaSeriesProperties.prototype, "marker", 2);
__decorateClass([
  Validate(OBJECT)
], AreaSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], AreaSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Validate(BOOLEAN)
], AreaSeriesProperties.prototype, "connectMissingData", 2);

// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolation.ts
function spanRange(span) {
  switch (span.type) {
    case "linear":
    case "step":
      return [
        { x: span.x0, y: span.y0 },
        { x: span.x1, y: span.y1 }
      ];
    case "cubic":
      return [
        { x: span.cp0x, y: span.cp0y },
        { x: span.cp3x, y: span.cp3y }
      ];
  }
}
function spanRangeNormalized(span) {
  const range3 = spanRange(span);
  if (range3[0].x > range3[1].x) {
    range3.reverse();
  }
  return range3;
}
function rescaleSpan(span, nextStart, nextEnd) {
  const [prevStart, prevEnd] = spanRange(span);
  const widthScale = prevEnd.x !== prevStart.x ? (nextEnd.x - nextStart.x) / (prevEnd.x - prevStart.x) : 0;
  const heightScale = prevEnd.y !== prevStart.y ? (nextEnd.y - nextStart.y) / (prevEnd.y - prevStart.y) : 0;
  switch (span.type) {
    case "linear":
      return {
        type: "linear",
        moveTo: span.moveTo,
        x0: nextStart.x,
        y0: nextStart.y,
        x1: nextEnd.x,
        y1: nextEnd.y
      };
    case "cubic":
      return {
        type: "cubic",
        moveTo: span.moveTo,
        cp0x: nextStart.x,
        cp0y: nextStart.y,
        cp1x: nextEnd.x - (span.cp2x - prevStart.x) * widthScale,
        cp1y: nextEnd.y - (span.cp2y - prevStart.y) * heightScale,
        cp2x: nextEnd.x - (span.cp1x - prevStart.x) * widthScale,
        cp2y: nextEnd.y - (span.cp1y - prevStart.y) * heightScale,
        cp3x: nextEnd.x,
        cp3y: nextEnd.y
      };
    case "step":
      return {
        type: "step",
        moveTo: span.moveTo,
        x0: nextStart.x,
        y0: nextStart.y,
        x1: nextEnd.x,
        y1: nextEnd.y,
        stepX: nextEnd.x - (span.stepX - prevStart.x) * widthScale
      };
  }
}
function clipSpanX(span, x0, x1) {
  const { moveTo } = span;
  const [start, end] = spanRangeNormalized(span);
  const { x: spanX0, y: spanY0 } = start;
  const { x: spanX1, y: spanY1 } = end;
  if (x1 < spanX0) {
    return rescaleSpan(span, start, start);
  } else if (x0 > spanX1) {
    return rescaleSpan(span, end, end);
  }
  switch (span.type) {
    case "linear": {
      const m = spanY0 === spanY1 ? void 0 : (spanY1 - spanY0) / (spanX1 - spanX0);
      const y0 = m == null ? spanY0 : m * (x0 - spanX0) + spanY0;
      const y1 = m == null ? spanY0 : m * (x1 - spanX0) + spanY0;
      return { type: "linear", moveTo, x0, y0, x1, y1 };
    }
    case "step":
      if (x1 <= span.stepX) {
        const y = span.y0;
        return { type: "step", moveTo, x0, y0: y, x1, y1: y, stepX: x1 };
      } else if (x0 >= span.stepX) {
        const y = span.y1;
        return { type: "step", moveTo, x0, y0: y, x1, y1: y, stepX: x0 };
      } else {
        const { y0, y1, stepX } = span;
        return { type: "step", moveTo, x0, y0, x1, y1, stepX };
      }
    case "cubic": {
      const t0 = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x0);
      let [_unused, bezier] = splitBezier(
        span.cp0x,
        span.cp0y,
        span.cp1x,
        span.cp1y,
        span.cp2x,
        span.cp2y,
        span.cp3x,
        span.cp3y,
        t0
      );
      const t1 = solveBezier(bezier[0].x, bezier[1].x, bezier[2].x, bezier[3].x, x1);
      [bezier, _unused] = splitBezier(
        bezier[0].x,
        bezier[0].y,
        bezier[1].x,
        bezier[1].y,
        bezier[2].x,
        bezier[2].y,
        bezier[3].x,
        bezier[3].y,
        t1
      );
      return {
        type: "cubic",
        moveTo,
        cp0x: bezier[0].x,
        cp0y: bezier[0].y,
        cp1x: bezier[1].x,
        cp1y: bezier[1].y,
        cp2x: bezier[2].x,
        cp2y: bezier[2].y,
        cp3x: bezier[3].x,
        cp3y: bezier[3].y
      };
    }
  }
}
function linearPoints(points) {
  const spans = [];
  let i = 0;
  let x0 = NaN;
  let y0 = NaN;
  for (const { x: x1, y: y1 } of points) {
    if (i > 0) {
      const moveTo = i === 1;
      spans.push({ type: "linear", moveTo, x0, y0, x1, y1 });
    }
    i += 1;
    x0 = x1;
    y0 = y1;
  }
  return spans;
}
var lineSteps = {
  start: 0,
  middle: 0.5,
  end: 1
};
function stepPoints(points, position) {
  const spans = [];
  let i = 0;
  let x0 = NaN;
  let y0 = NaN;
  const p0 = typeof position === "number" ? position : lineSteps[position];
  for (const { x: x1, y: y1 } of points) {
    if (i > 0) {
      const moveTo = i === 1;
      const stepX = x0 + (x1 - x0) * p0;
      spans.push({ type: "step", moveTo, x0, y0, x1, y1, stepX });
    }
    i += 1;
    x0 = x1;
    y0 = y1;
  }
  return spans;
}
var flatnessRatio = 0.05;
function smoothPoints(iPoints, tension) {
  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);
  if (points.length <= 1)
    return [];
  const gradients = points.map((c, i) => {
    const p = i === 0 ? c : points[i - 1];
    const n = i === points.length - 1 ? c : points[i + 1];
    const isTerminalPoint = i === 0 || i === points.length - 1;
    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {
      return 0;
    }
    if (!isTerminalPoint) {
      const range3 = Math.abs(p.y - n.y);
      const prevRatio = Math.abs(c.y - p.y) / range3;
      const nextRatio = Math.abs(c.y - n.y) / range3;
      if (prevRatio <= flatnessRatio || 1 - prevRatio <= flatnessRatio || nextRatio <= flatnessRatio || 1 - nextRatio <= flatnessRatio) {
        return 0;
      }
    }
    return (n.y - p.y) / (n.x - p.x);
  });
  if (gradients[1] === 0) {
    gradients[0] *= 2;
  }
  if (gradients[gradients.length - 2] === 0) {
    gradients[gradients.length - 1] *= 2;
  }
  const spans = [];
  for (let i = 1; i < points.length; i += 1) {
    const prev = points[i - 1];
    const prevM = gradients[i - 1];
    const cur = points[i];
    const curM = gradients[i];
    const dx = cur.x - prev.x;
    const dy = cur.y - prev.y;
    let dcp1x = dx * tension / 3;
    let dcp1y = dx * prevM * tension / 3;
    let dcp2x = dx * tension / 3;
    let dcp2y = dx * curM * tension / 3;
    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {
      dcp1x *= Math.abs(dy / dcp1y);
      dcp1y = Math.sign(dcp1y) * Math.abs(dy);
    }
    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {
      dcp2x *= Math.abs(dy / dcp2y);
      dcp2y = Math.sign(dcp2y) * Math.abs(dy);
    }
    spans.push({
      type: "cubic",
      moveTo: i === 1,
      cp0x: prev.x,
      cp0y: prev.y,
      cp1x: prev.x + dcp1x,
      cp1y: prev.y + dcp1y,
      cp2x: cur.x - dcp2x,
      cp2y: cur.y - dcp2y,
      cp3x: cur.x,
      cp3y: cur.y
    });
  }
  return spans;
}

// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationPlotting.ts
function lerp2(a, b, ratio2) {
  return (b - a) * ratio2 + a;
}
function linearSupertype(span, stepX) {
  const { x0, y0, x1, y1 } = span;
  const m = (y1 - y0) / (x1 - x0);
  const stepY = m * (stepX - x0) + y0;
  return {
    leftCp1x: x0,
    leftCp1y: y0,
    leftCp2x: stepX,
    leftCp2y: stepY,
    stepX,
    stepY0: stepY,
    stepY1: stepY,
    rightCp1x: stepX,
    rightCp1y: stepY,
    rightCp2x: x1,
    rightCp2y: y1
  };
}
function bezierSupertype(span, stepX) {
  const { cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y } = span;
  const t = solveBezier(cp0x, cp1x, cp2x, cp3x, stepX);
  const [left, right] = splitBezier(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, t);
  const stepY = left[3].y;
  return {
    leftCp1x: left[1].x,
    leftCp1y: left[1].y,
    leftCp2x: left[2].x,
    leftCp2y: left[2].y,
    stepX,
    stepY0: stepY,
    stepY1: stepY,
    rightCp1x: right[1].x,
    rightCp1y: right[1].y,
    rightCp2x: right[2].x,
    rightCp2y: right[2].y
  };
}
function stepSupertype(span) {
  const { x0, y0, x1, y1, stepX } = span;
  return {
    leftCp1x: (x0 + stepX) / 2,
    leftCp1y: y0,
    leftCp2x: (x0 + stepX) / 2,
    leftCp2y: y0,
    stepX,
    stepY0: y0,
    stepY1: y1,
    rightCp1x: (stepX + x1) / 2,
    rightCp1y: y1,
    rightCp2x: (stepX + x1) / 2,
    rightCp2y: y1
  };
}
function spanSupertype(span, stepX) {
  if (span.type === "linear") {
    return linearSupertype(span, stepX);
  } else if (span.type === "cubic") {
    return bezierSupertype(span, stepX);
  } else {
    return stepSupertype(span);
  }
}
function plotStart(path, moveTo, x0, y0, x1, y1, reversed) {
  switch (moveTo) {
    case 1 /* MoveTo */:
      if (reversed) {
        path.moveTo(x1, y1);
      } else {
        path.moveTo(x0, y0);
      }
      break;
    case 2 /* LineTo */:
      if (reversed) {
        path.lineTo(x1, y1);
      } else {
        path.lineTo(x0, y0);
      }
      break;
  }
}
function plotLinear(path, x0, y0, x1, y1, reversed) {
  if (reversed) {
    path.lineTo(x0, y0);
  } else {
    path.lineTo(x1, y1);
  }
}
function plotCubic(path, cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, reversed) {
  if (reversed) {
    path.cubicCurveTo(cp2x, cp2y, cp1x, cp1y, cp0x, cp0y);
  } else {
    path.cubicCurveTo(cp1x, cp1y, cp2x, cp2y, cp3x, cp3y);
  }
}
function plotStep(path, x0, y0, x1, y1, stepX, reversed) {
  if (reversed) {
    path.lineTo(stepX, y1);
    path.lineTo(stepX, y0);
    path.lineTo(x0, y0);
  } else {
    path.lineTo(stepX, y0);
    path.lineTo(stepX, y1);
    path.lineTo(x1, y1);
  }
}
function plotSpan(path, span, moveTo, reversed) {
  const [start, end] = spanRange(span);
  plotStart(path, moveTo, start.x, start.y, end.x, end.y, reversed);
  switch (span.type) {
    case "linear":
      plotLinear(path, span.x0, span.y0, span.x1, span.y1, reversed);
      break;
    case "cubic":
      plotCubic(
        path,
        span.cp0x,
        span.cp0y,
        span.cp1x,
        span.cp1y,
        span.cp2x,
        span.cp2y,
        span.cp3x,
        span.cp3y,
        reversed
      );
      break;
    case "step":
      plotStep(path, span.x0, span.y0, span.x1, span.y1, span.stepX, reversed);
      break;
  }
}
function plotInterpolatedSpans(path, a, b, ratio2, moveTo, reversed) {
  const [aStart, aEnd] = spanRange(a);
  const [bStart, bEnd] = spanRange(b);
  const x0 = lerp2(aStart.x, bStart.x, ratio2);
  const y0 = lerp2(aStart.y, bStart.y, ratio2);
  const x1 = lerp2(aEnd.x, bEnd.x, ratio2);
  const y1 = lerp2(aEnd.y, bEnd.y, ratio2);
  plotStart(path, moveTo, x0, y0, x1, y1, reversed);
  if (a.type === "cubic" && b.type === "cubic") {
    const cp1x = lerp2(a.cp1x, b.cp1x, ratio2);
    const cp1y = lerp2(a.cp1y, b.cp1y, ratio2);
    const cp2x = lerp2(a.cp2x, b.cp2x, ratio2);
    const cp2y = lerp2(a.cp2y, b.cp2y, ratio2);
    plotCubic(path, x0, y0, cp1x, cp1y, cp2x, cp2y, x1, y1, reversed);
  } else if (a.type === "step" && b.type === "step") {
    const stepX = lerp2(a.stepX, b.stepX, ratio2);
    plotStep(path, x0, y0, x1, y1, stepX, reversed);
  } else if (a.type === "linear" && b.type === "linear") {
    plotLinear(path, x0, y0, x1, y1, reversed);
  } else {
    let defaultStepX;
    if (a.type === "step") {
      defaultStepX = a.stepX;
    } else if (b.type === "step") {
      defaultStepX = b.stepX;
    } else {
      defaultStepX = (x0 + x1) / 2;
    }
    const as = spanSupertype(a, defaultStepX);
    const bs = spanSupertype(b, defaultStepX);
    const leftCp1x = lerp2(as.leftCp1x, bs.leftCp1x, ratio2);
    const leftCp1y = lerp2(as.leftCp1y, bs.leftCp1y, ratio2);
    const leftCp2x = lerp2(as.leftCp2x, bs.leftCp2x, ratio2);
    const leftCp2y = lerp2(as.leftCp2y, bs.leftCp2y, ratio2);
    const stepX = lerp2(as.stepX, bs.stepX, ratio2);
    const stepY0 = lerp2(as.stepY0, bs.stepY0, ratio2);
    const stepY1 = lerp2(as.stepY1, bs.stepY1, ratio2);
    const rightCp1x = lerp2(as.rightCp1x, bs.rightCp1x, ratio2);
    const rightCp1y = lerp2(as.rightCp1y, bs.rightCp1y, ratio2);
    const rightCp2x = lerp2(as.rightCp2x, bs.rightCp2x, ratio2);
    const rightCp2y = lerp2(as.rightCp2y, bs.rightCp2y, ratio2);
    if (reversed) {
      path.cubicCurveTo(rightCp2x, rightCp2y, rightCp1x, rightCp1y, stepX, stepY1);
      path.lineTo(stepX, stepY0);
      path.cubicCurveTo(leftCp2x, leftCp2y, leftCp1x, leftCp1y, x0, y0);
    } else {
      path.cubicCurveTo(leftCp1x, leftCp1y, leftCp2x, leftCp2y, stepX, stepY0);
      path.lineTo(stepX, stepY1);
      path.cubicCurveTo(rightCp1x, rightCp1y, rightCp2x, rightCp2y, x1, y1);
    }
  }
}

// packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts
function markerFadeInAnimation({ id }, animationManager, status, ...markerSelections) {
  const params = { phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : "trailing" };
  staticFromToMotion(id, "markers", animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);
  markerSelections.forEach((s) => s.cleanup());
}
function markerScaleInAnimation({ id }, animationManager, ...markerSelections) {
  staticFromToMotion(
    id,
    "markers",
    animationManager,
    markerSelections,
    { scalingX: 0, scalingY: 0 },
    { scalingX: 1, scalingY: 1 },
    { phase: "initial" }
  );
  markerSelections.forEach((s) => s.cleanup());
}
function markerSwipeScaleInAnimation({ id, nodeDataDependencies }, animationManager, ...markerSelections) {
  const seriesWidth = nodeDataDependencies.seriesRectWidth;
  const fromFn = (_, datum) => {
    const x = datum.midPoint?.x ?? seriesWidth;
    let delay = clamp(0, inverseEaseOut(x / seriesWidth), 1);
    if (isNaN(delay)) {
      delay = 0;
    }
    return { scalingX: 0, scalingY: 0, delay, duration: QUICK_TRANSITION, phase: "initial" };
  };
  const toFn = () => {
    return { scalingX: 1, scalingY: 1 };
  };
  fromToMotion(id, "markers", animationManager, markerSelections, { fromFn, toFn });
}
function resetMarkerFn(_node) {
  return { opacity: 1, scalingX: 1, scalingY: 1 };
}
function resetMarkerPositionFn(_node, datum) {
  return {
    translationX: datum.point?.x ?? NaN,
    translationY: datum.point?.y ?? NaN
  };
}
function prepareMarkerAnimation(pairMap, parentStatus) {
  const readFirstPair = (xValue, type) => {
    const val = pairMap[type][xValue];
    return Array.isArray(val) ? val[0] : val;
  };
  const markerStatus = (datum) => {
    const { xValue } = datum;
    if (pairMap.moved[xValue]) {
      return { point: readFirstPair(xValue, "moved"), status: "updated" };
    } else if (pairMap.removed[xValue]) {
      return { point: readFirstPair(xValue, "removed"), status: "removed" };
    } else if (pairMap.added[xValue]) {
      return { point: readFirstPair(xValue, "added"), status: "added" };
    }
    return { status: "unknown" };
  };
  const fromFn = (marker, datum) => {
    const { status, point } = markerStatus(datum);
    if (status === "unknown")
      return { opacity: 0 };
    const defaults = {
      translationX: point?.from?.x ?? marker.translationX,
      translationY: point?.from?.y ?? marker.translationY,
      opacity: marker.opacity,
      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
    };
    if (parentStatus === "added") {
      return {
        ...defaults,
        opacity: 0,
        translationX: point?.to?.x,
        translationY: point?.to?.y,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["added"]
      };
    }
    if (status === "added") {
      defaults.opacity = 0;
    }
    return defaults;
  };
  const toFn = (_marker, datum) => {
    const { status, point } = markerStatus(datum);
    if (status === "unknown")
      return { opacity: 0 };
    const defaults = {
      translationX: datum.point.x,
      translationY: datum.point.y,
      opacity: 1,
      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
    };
    if (status === "removed" || parentStatus === "removed") {
      return {
        ...defaults,
        translationX: point?.to?.x,
        translationY: point?.to?.y,
        opacity: 0,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["removed"]
      };
    }
    return defaults;
  };
  return { fromFn, toFn };
}
function computeMarkerFocusBounds(series, { datumIndex }) {
  const nodeData = series.getNodeData();
  if (nodeData === void 0)
    return void 0;
  const datum = nodeData[datumIndex];
  const { point } = datum;
  if (datum == null || point == null)
    return void 0;
  const size = point.focusSize ?? series.getFormattedMarkerStyle(datum).size;
  const radius = size / 2;
  const x = datum.point.x - radius;
  const y = datum.point.y - radius;
  return Transformable.toCanvas(series.contentGroup, new BBox(x, y, size, size));
}

// packages/ag-charts-community/src/chart/series/cartesian/linePlotter.ts
function plotLinearPoints(path, points, continuePath) {
  let didMove = continuePath;
  for (const { x, y } of points) {
    if (didMove) {
      path.lineTo(x, y);
    } else {
      path.moveTo(x, y);
      didMove = true;
    }
  }
}
var flatnessRatio2 = 0.05;
function plotSmoothPoints(path, iPoints, tension, continuePath) {
  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);
  if (points.length === 0)
    return;
  if (continuePath) {
    path.lineTo(points[0].x, points[0].y);
  } else {
    path.moveTo(points[0].x, points[0].y);
  }
  if (points.length <= 1)
    return;
  const gradients = points.map((c, i) => {
    const p = i === 0 ? c : points[i - 1];
    const n = i === points.length - 1 ? c : points[i + 1];
    const isTerminalPoint = i === 0 || i === points.length - 1;
    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {
      return 0;
    }
    if (!isTerminalPoint) {
      const range3 = Math.abs(p.y - n.y);
      const prevRatio = Math.abs(c.y - p.y) / range3;
      const nextRatio = Math.abs(c.y - n.y) / range3;
      if (prevRatio <= flatnessRatio2 || 1 - prevRatio <= flatnessRatio2 || nextRatio <= flatnessRatio2 || 1 - nextRatio <= flatnessRatio2) {
        return 0;
      }
    }
    return (n.y - p.y) / (n.x - p.x);
  });
  if (gradients[1] === 0) {
    gradients[0] *= 2;
  }
  if (gradients[gradients.length - 2] === 0) {
    gradients[gradients.length - 1] *= 2;
  }
  for (let i = 1; i < points.length; i += 1) {
    const prev = points[i - 1];
    const prevM = gradients[i - 1];
    const cur = points[i];
    const curM = gradients[i];
    const dx = cur.x - prev.x;
    const dy = cur.y - prev.y;
    let dcp1x = dx * tension / 3;
    let dcp1y = dx * prevM * tension / 3;
    let dcp2x = dx * tension / 3;
    let dcp2y = dx * curM * tension / 3;
    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {
      dcp1x *= Math.abs(dy / dcp1y);
      dcp1y = Math.sign(dcp1y) * Math.abs(dy);
    }
    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {
      dcp2x *= Math.abs(dy / dcp2y);
      dcp2y = Math.sign(dcp2y) * Math.abs(dy);
    }
    path.cubicCurveTo(prev.x + dcp1x, prev.y + dcp1y, cur.x - dcp2x, cur.y - dcp2y, cur.x, cur.y);
  }
}
function plotStepPoints(path, points, align, continuePath) {
  let lastPoint;
  for (const point of points) {
    if (lastPoint != null) {
      const directionalAlign = lastPoint.x < point.x ? align : 1 - align;
      const x = (point.x - lastPoint.x) * directionalAlign + lastPoint.x;
      path.lineTo(x, lastPoint?.y ?? point.y);
      path.lineTo(x, point.y);
      path.lineTo(point.x, point.y);
    } else if (continuePath) {
      path.lineTo(point.x, point.y);
    } else {
      path.moveTo(point.x, point.y);
    }
    lastPoint = point;
  }
}

// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts
function minMax(nodeData) {
  return nodeData.reduce(
    ({ min, max }, node) => {
      if (min == null || min.point.x > node.point.x) {
        min = node;
      }
      if (max == null || max.point.x < node.point.x) {
        max = node;
      }
      return { min, max };
    },
    {}
  );
}
function intersectionOnLine(a, b, targetX) {
  const m = (b.y - a.y) / (b.x - a.x);
  const y = (targetX - a.x) * m + a.y;
  return { x: targetX, y };
}
function backfillPathPoint(results, process, skip, processFn) {
  let prevMarkerIdx = -1, nextMarkerIdx = 0;
  const toProcess = [];
  while (nextMarkerIdx < results.length) {
    if (results[nextMarkerIdx].change === process) {
      toProcess.push(results[nextMarkerIdx]);
      nextMarkerIdx++;
      continue;
    }
    if (results[nextMarkerIdx].change === skip) {
      nextMarkerIdx++;
      continue;
    }
    if (toProcess.length > 0) {
      processFn(toProcess, prevMarkerIdx, nextMarkerIdx);
      toProcess.length = 0;
    }
    prevMarkerIdx = nextMarkerIdx;
    nextMarkerIdx++;
  }
  if (toProcess.length > 0) {
    processFn(toProcess, prevMarkerIdx, nextMarkerIdx);
  }
}
function backfillPathPointData(result, splitMode) {
  backfillPathPoint(result, "out", "in", (toProcess, sIdx, eIdx) => {
    if (sIdx === -1 && result[eIdx]) {
      toProcess.forEach((d) => d.to = result[eIdx].from);
    } else if (eIdx === result.length && result[sIdx]) {
      toProcess.forEach((d) => d.to = result[sIdx].from);
    } else if (splitMode === "intersect" && result[sIdx]?.from && result[eIdx]?.from) {
      toProcess.forEach((d) => d.to = intersectionOnLine(result[sIdx].from, result[eIdx].from, d.from.x));
    } else {
      toProcess.forEach((d) => d.to = d.from);
    }
  });
  backfillPathPoint(result, "in", "out", (toProcess, sIdx, eIdx) => {
    if (sIdx === -1 && result[eIdx]) {
      toProcess.forEach((d) => d.from = result[eIdx].to);
    } else if (eIdx === result.length && result[sIdx]) {
      toProcess.forEach((d) => d.from = result[sIdx].to);
    } else if (splitMode === "intersect" && result[sIdx]?.to && result[eIdx]?.to) {
      toProcess.forEach((d) => d.from = intersectionOnLine(result[sIdx].to, result[eIdx].to, d.to.x));
    } else {
      toProcess.forEach((d) => d.from = d.to);
    }
  });
}
function calculatePoint(from2, to, ratio2) {
  const x1 = isNaN(from2.x) ? to.x : from2.x;
  const y1 = isNaN(from2.y) ? to.y : from2.y;
  const xd = to.x - from2.x;
  const yd = to.y - from2.y;
  const xr = isNaN(xd) ? 0 : xd * ratio2;
  const yr = isNaN(yd) ? 0 : yd * ratio2;
  return {
    x: x1 + xr,
    y: y1 + yr
  };
}
var lineSteps2 = {
  start: 0,
  middle: 0.5,
  end: 1
};
function plotPath(points, path, interpolation, continuePath = false) {
  const { path: linePath } = path;
  if (interpolation?.type === "smooth") {
    plotSmoothPoints(linePath, points, interpolation.tension ?? 1, continuePath);
  } else if (interpolation?.type === "step") {
    plotStepPoints(linePath, points, lineSteps2[interpolation.position ?? "end"], continuePath);
  } else {
    plotLinearPoints(linePath, points, continuePath);
  }
}
function splitPairData(pairData, ratios) {
  let previousTo;
  let points = void 0;
  const out = [];
  const flushCurrent = () => {
    if (points != null) {
      out.push(points);
      points = void 0;
    }
  };
  for (const data of pairData) {
    const { from: from2, to } = data;
    const ratio2 = ratios[data.change];
    if (ratio2 == null || from2 == null || to == null)
      continue;
    const point = calculatePoint(from2, to, ratio2);
    if (data.moveTo === false) {
      points ?? (points = []);
      points.push(point);
    } else if (data.moveTo === true || !previousTo) {
      flushCurrent();
      points = [point];
    } else if (previousTo) {
      const moveToRatio = data.moveTo === "in" ? ratio2 : 1 - ratio2;
      const { x: midPointX, y: midPointY } = calculatePoint(previousTo, point, moveToRatio);
      points ?? (points = []);
      points.push({ x: midPointX, y: midPointY });
      flushCurrent();
      points = [point];
    }
    previousTo = point;
  }
  flushCurrent();
  return out;
}
function renderPartialPath(pairData, ratios, path, interpolation) {
  splitPairData(pairData, ratios).forEach((points) => {
    plotPath(points, path, interpolation);
  });
}
function pathSwipeInAnimation({ id, visible, nodeDataDependencies }, animationManager, ...paths) {
  const { seriesRectWidth: width, seriesRectHeight: height } = nodeDataDependencies;
  staticFromToMotion(
    id,
    "path_properties",
    animationManager,
    paths,
    { clipX: 0 },
    { clipX: width },
    {
      phase: "initial",
      start: { clip: true, clipY: height, visible },
      finish: { clip: false, visible }
    }
  );
}
function pathFadeInAnimation({ id }, subId, animationManager, phase = "add", ...selection) {
  staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, { phase });
}
function buildResetPathFn(opts) {
  return (_node) => ({
    visible: opts.getVisible(),
    opacity: opts.getOpacity(),
    clipScalingX: 1,
    clip: false
  });
}
function updateClipPath({ nodeDataDependencies }, path) {
  const toFinite = (value) => isFinite(value) ? value : 0;
  path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);
  path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);
}

// packages/ag-charts-community/src/chart/series/cartesian/scaling.ts
function isContinuousScaling(scaling) {
  return scaling.type === "continuous" || scaling.type === "log";
}
function isCategoryScaling(scaling) {
  return scaling.type === "category";
}
function areEqual(a, b) {
  return a.domain.length === b.domain.length && a.range.length === b.range.length && a.domain.every((val, index) => val === b.domain[index]) && a.range.every((val, index) => val === b.range[index]);
}
function areScalingEqual(a, b) {
  if (a === void 0 || b === void 0) {
    return a !== void 0 || b !== void 0;
  }
  if (isContinuousScaling(a) && isContinuousScaling(b)) {
    return a.type === b.type && areEqual(a, b);
  }
  if (isCategoryScaling(a) && isCategoryScaling(b)) {
    return areEqual(a, b);
  }
  return false;
}
function isScaleValid(scale2) {
  if (scale2 == null)
    return false;
  if (!scale2.range.every((v) => Number.isFinite(v)))
    return false;
  if (scale2.type === "category") {
    return scale2.domain.every((v) => v != null);
  }
  return scale2.domain.every((v) => Number.isFinite(v) || v instanceof Date);
}

// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts
function* pathRanges(points) {
  let start = -1;
  let end = 0;
  for (const { point } of points) {
    if (point.moveTo) {
      const range3 = start >= 0 ? { start, end } : void 0;
      start = end;
      end = start;
      if (range3 !== void 0) {
        yield range3;
      }
    }
    end += 1;
  }
  if (start !== -1) {
    yield { start, end };
  }
}
function* pathRangePoints(points, { start, end }) {
  for (let i = start; i < end; i += 1) {
    yield points[i].point;
  }
}
function integratedCategoryMatch(a, b) {
  if (a == null || b == null)
    return false;
  if (typeof a !== "object" || typeof b !== "object")
    return false;
  if ("id" in a && "id" in b) {
    return a.id === b.id;
  }
  return a.toString() === b.toString();
}
function scale(val, scaling) {
  if (!scaling)
    return NaN;
  if (val instanceof Date) {
    val = val.getTime();
  }
  if (scaling.type === "continuous" && typeof val === "number") {
    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);
    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];
  }
  if (scaling.type === "log" && typeof val === "number") {
    return scaling.convert(val);
  }
  const matchingIndex = scaling.domain.findIndex((d) => d === val);
  if (matchingIndex >= 0) {
    return scaling.range[matchingIndex];
  }
  const matchingIntegratedIndex = scaling.domain.findIndex((d) => integratedCategoryMatch(val, d));
  if (matchingIntegratedIndex >= 0) {
    return scaling.range[matchingIntegratedIndex];
  }
  return NaN;
}
function scalesChanged(newData, oldData) {
  return !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y);
}
function closeMatch(a, b) {
  const an = Number(a);
  const bn = Number(b);
  if (!isNaN(an) && !isNaN(bn)) {
    return Math.abs(bn - an) < 0.25;
  }
  return a === b;
}
function calculateMoveTo(from2 = false, to = false) {
  if (from2 === to) {
    return Boolean(from2);
  }
  return from2 ? "in" : "out";
}
function pairContinuousData(newData, oldData, opts = {}) {
  const { backfillSplitMode = "intersect" } = opts;
  const result = [];
  const resultMap = {
    added: {},
    moved: {},
    removed: {}
  };
  const pairUp = (from2, to, xValue, change = "move") => {
    if (from2 && (isNaN(from2.point.x) || isNaN(from2.point.y))) {
      from2 = to;
    }
    const resultPoint = {
      from: from2?.point,
      to: to?.point,
      moveTo: calculateMoveTo(from2?.point.moveTo, to?.point.moveTo),
      change
    };
    if (change === "move") {
      resultMap.moved[xValue] = resultPoint;
      oldIdx++;
      newIdx++;
    } else if (change === "in") {
      resultMap.added[xValue] = resultPoint;
      newIdx++;
    } else if (change === "out") {
      resultMap.removed[xValue] = resultPoint;
      oldIdx++;
    }
    result.push(resultPoint);
  };
  const { min: minFromNode, max: maxFromNode } = minMax(oldData.nodeData);
  const { min: minToNode, max: maxToNode } = minMax(newData.nodeData);
  let oldIdx = 0;
  let newIdx = 0;
  while (oldIdx < oldData.nodeData.length || newIdx < newData.nodeData.length) {
    const from2 = oldData.nodeData[oldIdx];
    const to = newData.nodeData[newIdx];
    const fromShifted = from2 ? scale(from2.xValue ?? NaN, newData.scales.x) : void 0;
    const toUnshifted = to ? scale(to.xValue ?? NaN, oldData.scales.x) : void 0;
    const NA = void 0;
    if (fromShifted != null && closeMatch(fromShifted, to?.point.x)) {
      pairUp(from2, to, to.xValue, "move");
    } else if (fromShifted != null && fromShifted < (minToNode?.point.x ?? -Infinity)) {
      pairUp(from2, NA, from2.xValue, "out");
    } else if (fromShifted != null && fromShifted > (maxToNode?.point.x ?? Infinity)) {
      pairUp(from2, NA, from2.xValue, "out");
    } else if (toUnshifted != null && toUnshifted < (minFromNode?.point.x ?? -Infinity)) {
      pairUp(NA, to, to.xValue, "in");
    } else if (toUnshifted != null && toUnshifted > (maxFromNode?.point.x ?? Infinity)) {
      pairUp(NA, to, to.xValue, "in");
    } else if (fromShifted != null && fromShifted < to?.point.x) {
      pairUp(from2, NA, from2.xValue, "out");
    } else if (toUnshifted != null && toUnshifted < from2?.point.x) {
      pairUp(NA, to, to.xValue, "in");
    } else if (from2) {
      pairUp(from2, NA, from2.xValue, "out");
    } else if (to) {
      pairUp(NA, to, to.xValue, "in");
    } else {
      throw new Error("Unable to process points");
    }
  }
  backfillPathPointData(result, backfillSplitMode);
  return { result, resultMap };
}
function pairCategoryData(newData, oldData, diff2, opts = {}) {
  const { backfillSplitMode = "intersect", multiDatum = false } = opts;
  const result = [];
  const resultMapSingle = {
    added: {},
    moved: {},
    removed: {}
  };
  const resultMapMulti = {
    added: {},
    moved: {},
    removed: {}
  };
  const pointResultMapping = {
    in: "added",
    move: "moved",
    out: "removed"
  };
  let previousResultPoint = void 0;
  let previousXValue = void 0;
  const addToResultMap = (xValue, newPoint) => {
    var _a;
    const type = pointResultMapping[newPoint.change];
    if (multiDatum) {
      (_a = resultMapMulti[type])[xValue] ?? (_a[xValue] = []);
      resultMapMulti[type][xValue].push(newPoint);
    } else {
      resultMapSingle[type][xValue] = newPoint;
    }
    previousResultPoint = newPoint;
    previousXValue = transformIntegratedCategoryValue(xValue);
  };
  let oldIndex = 0;
  let newIndex = 0;
  let isXUnordered = false;
  while (oldIndex < oldData.nodeData.length || newIndex < newData.nodeData.length) {
    const before = oldData.nodeData[oldIndex];
    const after = newData.nodeData[newIndex];
    const bXValue = transformIntegratedCategoryValue(before?.xValue);
    const aXValue = transformIntegratedCategoryValue(after?.xValue);
    let resultPoint;
    if (bXValue === aXValue) {
      resultPoint = {
        change: "move",
        moveTo: calculateMoveTo(before.point.moveTo ?? false, after.point.moveTo),
        from: before.point,
        to: after.point
      };
      addToResultMap(before?.xValue, resultPoint);
      oldIndex++;
      newIndex++;
    } else if (diff2?.removed.has(String(bXValue))) {
      resultPoint = {
        change: "out",
        moveTo: before.point.moveTo ?? false,
        from: before.point
      };
      addToResultMap(before?.xValue, resultPoint);
      oldIndex++;
    } else if (diff2?.added.has(String(aXValue))) {
      resultPoint = {
        change: "in",
        moveTo: after.point.moveTo ?? false,
        to: after.point
      };
      addToResultMap(after?.xValue, resultPoint);
      newIndex++;
    } else if (multiDatum && previousResultPoint && previousXValue === bXValue) {
      resultPoint = {
        ...previousResultPoint
      };
      addToResultMap(before?.xValue, resultPoint);
      oldIndex++;
    } else if (multiDatum && previousResultPoint && previousXValue === aXValue) {
      resultPoint = {
        ...previousResultPoint
      };
      addToResultMap(after?.xValue, resultPoint);
      newIndex++;
    } else {
      isXUnordered = true;
      break;
    }
    result.push(resultPoint);
  }
  let previousX = -Infinity;
  isXUnordered || (isXUnordered = result.some((pathPoint) => {
    const { change: marker, to: { x = -Infinity } = {} } = pathPoint;
    if (marker === "out")
      return;
    const unordered = x < previousX;
    previousX = x;
    return unordered;
  }));
  if (isXUnordered) {
    return { result: void 0, resultMap: void 0 };
  }
  backfillPathPointData(result, backfillSplitMode);
  return { result, resultMap: multiDatum ? resultMapMulti : resultMapSingle };
}
function determinePathStatus(newData, oldData, pairData) {
  let status = "updated";
  const visible = (data) => {
    return data.visible;
  };
  if (!visible(oldData) && visible(newData)) {
    status = "added";
  } else if (visible(oldData) && !visible(newData)) {
    status = "removed";
  } else {
    for (let i = 0; i < pairData.length; i++) {
      if (pairData[i].change !== "move")
        break;
      if (pairData[i].from?.x !== pairData[i].to?.x)
        break;
      if (pairData[i].from?.y !== pairData[i].to?.y)
        break;
      if (i === pairData.length - 1)
        return "no-op";
    }
  }
  return status;
}
function prepareLinePathPropertyAnimation(status, visibleToggleMode) {
  const phase = visibleToggleMode === "none" ? "updated" : status;
  const result = {
    fromFn: (_path) => {
      let mixin;
      if (status === "removed") {
        mixin = { finish: { visible: false } };
      } else if (status === "added") {
        mixin = { start: { visible: true } };
      } else {
        mixin = {};
      }
      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase], ...mixin };
    },
    toFn: (_path) => {
      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] };
    }
  };
  if (visibleToggleMode === "fade") {
    return {
      fromFn: (path) => {
        const opacity = status === "added" ? 0 : path.opacity;
        return { opacity, ...result.fromFn(path) };
      },
      toFn: (path) => {
        const opacity = status === "removed" ? 0 : 1;
        return { opacity, ...result.toFn(path) };
      }
    };
  }
  return result;
}
function prepareLinePathAnimationFns(newData, oldData, pairData, visibleToggleMode, interpolation, render) {
  const status = determinePathStatus(newData, oldData, pairData);
  const removePhaseFn = (ratio2, path) => {
    render(pairData, { move: 0, out: ratio2 }, path, interpolation);
  };
  const updatePhaseFn = (ratio2, path) => {
    render(pairData, { move: ratio2 }, path, interpolation);
  };
  const addPhaseFn = (ratio2, path) => {
    render(pairData, { move: 1, in: ratio2 }, path, interpolation);
  };
  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);
  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };
}
function prepareLinePathAnimation(newData, oldData, diff2, interpolation) {
  const isCategoryBased = newData.scales.x?.type === "category";
  const wasCategoryBased = oldData.scales.x?.type === "category";
  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {
    return;
  }
  const { result: pairData, resultMap: pairMap } = isCategoryBased ? pairCategoryData(newData, oldData, diff2) : pairContinuousData(newData, oldData);
  let status = "updated";
  if (oldData.visible && !newData.visible) {
    status = "removed";
  } else if (!oldData.visible && newData.visible) {
    status = "added";
  }
  if (pairData === void 0 || pairMap === void 0) {
    return;
  }
  const hasMotion = (diff2?.changed ?? true) || scalesChanged(newData, oldData) || status !== "updated";
  const pathFns = prepareLinePathAnimationFns(newData, oldData, pairData, "fade", interpolation, renderPartialPath);
  const marker = prepareMarkerAnimation(pairMap, status);
  return { ...pathFns, marker, hasMotion };
}

// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationUtil.ts
function toAxisValue(value) {
  return transformIntegratedCategoryValue(value).valueOf();
}
function getAxisIndices({ data }, axisValues) {
  return data.map((datum, datumIndex) => ({
    xValue0Index: axisValues.indexOf(toAxisValue(datum.xValue0)),
    xValue1Index: axisValues.indexOf(toAxisValue(datum.xValue1)),
    datumIndex
  }));
}
function validateAxisValuesOrder(axisValues, data) {
  let x0 = -Infinity;
  for (const axisValue of axisValues) {
    const x = scale(axisValue, data.scales.x);
    if (!Number.isFinite(x)) {
      continue;
    } else if (x < x0) {
      return false;
    } else {
      x0 = x;
    }
  }
  return true;
}
function getAxisValues(newData, oldData) {
  const allAxisValues = /* @__PURE__ */ new Set();
  for (const { xValue0, xValue1 } of newData.data) {
    const xValue0Value = toAxisValue(xValue0);
    const xValue1Value = toAxisValue(xValue1);
    allAxisValues.add(xValue0Value).add(xValue1Value);
  }
  const newAxisValues = Array.from(allAxisValues).sort((a, b) => {
    return scale(a, newData.scales.x) - scale(b, newData.scales.x);
  });
  const exclusivelyOldAxisValues = [];
  for (const { xValue0, xValue1 } of oldData.data) {
    const xValue0Value = toAxisValue(xValue0);
    const xValue1Value = toAxisValue(xValue1);
    if (!allAxisValues.has(xValue0Value)) {
      allAxisValues.add(xValue0Value);
      exclusivelyOldAxisValues.push(xValue0Value);
    }
    if (!allAxisValues.has(xValue1Value)) {
      allAxisValues.add(xValue1Value);
      exclusivelyOldAxisValues.push(xValue1Value);
    }
  }
  exclusivelyOldAxisValues.sort((a, b) => {
    return scale(a, oldData.scales.x) - scale(b, oldData.scales.x);
  });
  const axisValues = newAxisValues;
  let insertionIndex = 0;
  for (const oldValue of exclusivelyOldAxisValues) {
    inner:
      for (let i = axisValues.length; i > insertionIndex; i -= 1) {
        const oldValueX = scale(oldValue, oldData.scales.x);
        const newValueX = scale(axisValues[i], oldData.scales.x);
        if (oldValueX > newValueX) {
          insertionIndex = i + 1;
          break inner;
        }
      }
    axisValues.splice(insertionIndex, 0, oldValue);
    insertionIndex += 1;
  }
  if (!validateAxisValuesOrder(axisValues, oldData))
    return;
  const oldDataAxisIndices = getAxisIndices(oldData, axisValues);
  const newDataAxisIndices = getAxisIndices(newData, axisValues);
  return { axisValues, oldDataAxisIndices, newDataAxisIndices };
}
function clipSpan(span, xValue0Index, xIndices) {
  if (xIndices.xValue1Index === xIndices.xValue0Index + 1)
    return span;
  const range3 = spanRange(span);
  const step = (range3[1].x - range3[0].x) / (xIndices.xValue1Index - xIndices.xValue0Index);
  const start = range3[0].x + (xValue0Index - xIndices.xValue0Index) * step;
  const end = start + step;
  return clipSpanX(span, start, end);
}
function axisZeroSpan(span, data) {
  const [r0, r1] = spanRange(span);
  const y0 = scale(0, data.scales.y);
  return rescaleSpan(span, { x: r0.x, y: y0 }, { x: r1.x, y: y0 });
}
function collapseSpan(span, data, axisIndices, indices, range3) {
  let xValue;
  let yValue;
  if (indices.xValue0Index >= range3.xValue1Index) {
    const datumIndex = axisIndices.findLast((i) => i.xValue1Index <= range3.xValue1Index)?.datumIndex;
    const datum = datumIndex != null ? data.data[datumIndex] : void 0;
    xValue = datum?.xValue1;
    yValue = datum?.yValue1;
  } else if (indices.xValue0Index <= range3.xValue0Index) {
    const datumIndex = axisIndices.find((i) => i.xValue0Index >= range3.xValue0Index)?.datumIndex;
    const datum = datumIndex != null ? data.data[datumIndex] : void 0;
    xValue = datum?.xValue0;
    yValue = datum?.yValue0;
  }
  if (xValue == null || yValue == null) {
    return axisZeroSpan(span, data);
  }
  const x = scale(xValue, data.scales.x);
  const y = scale(yValue, data.scales.y);
  const point = { x, y };
  return rescaleSpan(span, point, point);
}
function zeroDataSpan(spanDatum, zeroData) {
  const newSpanXValue0 = toAxisValue(spanDatum.xValue0);
  const newSpanXValue1 = toAxisValue(spanDatum.xValue1);
  return zeroData?.find(
    (span) => toAxisValue(span.xValue0) === newSpanXValue0 && toAxisValue(span.xValue1) === newSpanXValue1
  )?.span;
}
function addSpan(newData, newAxisIndices, newIndices, oldZeroData, range3, out) {
  const newSpanDatum = newData.data[newIndices.datumIndex];
  const newSpan = newSpanDatum.span;
  const zeroSpan = zeroDataSpan(newSpanDatum, oldZeroData);
  if (zeroSpan != null) {
    out.removed.push({ from: zeroSpan, to: zeroSpan });
    out.moved.push({ from: zeroSpan, to: newSpan });
    out.added.push({ from: newSpan, to: newSpan });
  } else {
    const oldSpan = collapseSpan(newSpan, newData, newAxisIndices, newIndices, range3);
    out.added.push({ from: oldSpan, to: newSpan });
  }
}
function removeSpan(oldData, oldAxisIndices, oldIndices, newZeroData, range3, out) {
  const oldSpanDatum = oldData.data[oldIndices.datumIndex];
  const oldSpan = oldSpanDatum.span;
  const zeroSpan = zeroDataSpan(oldSpanDatum, newZeroData);
  if (zeroSpan != null) {
    out.removed.push({ from: oldSpan, to: oldSpan });
    out.moved.push({ from: oldSpan, to: zeroSpan });
    out.added.push({ from: zeroSpan, to: zeroSpan });
  } else {
    const newSpan = collapseSpan(oldSpan, oldData, oldAxisIndices, oldIndices, range3);
    out.removed.push({ from: oldSpan, to: newSpan });
  }
}
function alignSpanToContainingSpan(span, axisValues, preData, postData, postSpanIndices) {
  const startXValue0 = axisValues[postSpanIndices.xValue0Index];
  const startDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue0) === startXValue0);
  const endXValue1 = axisValues[postSpanIndices.xValue1Index];
  const endDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue1) === endXValue1);
  if (startDatum == null || endDatum == null)
    return;
  const [{ x: x0 }, { x: x1 }] = spanRange(span);
  const startX = scale(startDatum.xValue0, preData.scales.x);
  const startY = scale(startDatum.yValue0, preData.scales.y);
  const endX = scale(endDatum.xValue1, preData.scales.x);
  const endY = scale(endDatum.yValue1, preData.scales.y);
  let altSpan = postData.data[postSpanIndices.datumIndex].span;
  altSpan = rescaleSpan(altSpan, { x: startX, y: startY }, { x: endX, y: endY });
  altSpan = clipSpanX(altSpan, x0, x1);
  return altSpan;
}
function appendSpanPhases(newData, oldData, axisValues, xValue0Index, newAxisIndices, oldAxisIndices, range3, out) {
  const xValue1Index = xValue0Index + 1;
  const oldIndices = oldAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);
  const newIndices = newAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);
  const oldZeroData = oldData.zeroData;
  const newZeroData = newData.zeroData;
  if (oldIndices == null && newIndices != null) {
    addSpan(newData, newAxisIndices, newIndices, oldZeroData, range3, out);
    return;
  } else if (oldIndices != null && newIndices == null) {
    removeSpan(oldData, oldAxisIndices, oldIndices, newZeroData, range3, out);
    return;
  } else if (oldIndices == null || newIndices == null) {
    return;
  }
  let ordering;
  if (oldIndices.xValue0Index === newIndices.xValue0Index && oldIndices.xValue1Index === newIndices.xValue1Index) {
    ordering = 0;
  } else if (oldIndices.xValue0Index <= newIndices.xValue0Index && oldIndices.xValue1Index >= newIndices.xValue1Index) {
    ordering = -1;
  } else if (oldIndices.xValue0Index >= newIndices.xValue0Index && oldIndices.xValue1Index <= newIndices.xValue1Index) {
    ordering = 1;
  } else {
    ordering = 0;
  }
  const oldSpanDatum = oldData.data[oldIndices.datumIndex];
  const clippedOldSpanOldScale = clipSpan(oldSpanDatum.span, xValue0Index, oldIndices);
  const newSpanDatum = newData.data[newIndices.datumIndex];
  const clippedNewSpanNewScale = clipSpan(newSpanDatum.span, xValue0Index, newIndices);
  if (ordering === 1) {
    const clippedPostRemoveOldSpanOldScale = alignSpanToContainingSpan(
      clippedOldSpanOldScale,
      axisValues,
      oldData,
      newData,
      newIndices
    );
    if (clippedPostRemoveOldSpanOldScale != null) {
      out.removed.push({ from: clippedOldSpanOldScale, to: clippedPostRemoveOldSpanOldScale });
      out.moved.push({ from: clippedPostRemoveOldSpanOldScale, to: clippedNewSpanNewScale });
      out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });
    } else {
      removeSpan(oldData, oldAxisIndices, oldIndices, newZeroData, range3, out);
    }
  } else if (ordering === -1) {
    const clippedPreAddedNewSpanNewScale = alignSpanToContainingSpan(
      clippedNewSpanNewScale,
      axisValues,
      newData,
      oldData,
      oldIndices
    );
    if (clippedPreAddedNewSpanNewScale != null) {
      out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });
      out.moved.push({ from: clippedOldSpanOldScale, to: clippedPreAddedNewSpanNewScale });
      out.added.push({ from: clippedPreAddedNewSpanNewScale, to: clippedNewSpanNewScale });
    } else {
      addSpan(newData, newAxisIndices, newIndices, oldZeroData, range3, out);
    }
  } else {
    out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });
    out.moved.push({ from: clippedOldSpanOldScale, to: clippedNewSpanNewScale });
    out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });
  }
}
function phaseAnimation(axisContext, newData, oldData, out) {
  const { axisValues, oldDataAxisIndices, newDataAxisIndices } = axisContext;
  const range3 = {
    xValue0Index: Math.max(
      oldDataAxisIndices.at(0)?.xValue0Index ?? -Infinity,
      newDataAxisIndices.at(0)?.xValue0Index ?? -Infinity
    ),
    xValue1Index: Math.min(
      oldDataAxisIndices.at(-1)?.xValue1Index ?? Infinity,
      newDataAxisIndices.at(-1)?.xValue1Index ?? Infinity
    )
  };
  for (let xValue0Index = 0; xValue0Index < axisValues.length - 1; xValue0Index += 1) {
    appendSpanPhases(
      newData,
      oldData,
      axisValues,
      xValue0Index,
      newDataAxisIndices,
      oldDataAxisIndices,
      range3,
      out
    );
  }
}
function resetAnimation(newData, oldData, out) {
  for (const oldSpanDatum of oldData.data) {
    const oldSpan = oldSpanDatum.span;
    const zeroSpan = zeroDataSpan(oldSpanDatum, oldData.zeroData) ?? axisZeroSpan(oldSpan, oldData);
    out.removed.push({ from: oldSpan, to: zeroSpan });
  }
  for (const newSpanDatum of newData.data) {
    const newSpan = newSpanDatum.span;
    const zeroSpan = zeroDataSpan(newSpanDatum, newData.zeroData) ?? axisZeroSpan(newSpan, newData);
    out.added.push({ from: zeroSpan, to: newSpan });
  }
}
function pairUpSpans(newData, oldData) {
  const out = {
    removed: [],
    moved: [],
    added: []
  };
  const axisContext = getAxisValues(newData, oldData);
  if (axisContext == null) {
    resetAnimation(newData, oldData, out);
  } else {
    phaseAnimation(axisContext, newData, oldData, out);
  }
  return out;
}

// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts
function plotFillSpans(ratio2, path, spans, fillPhantomSpans) {
  for (let i = 0; i < spans.length; i += 1) {
    const span = spans[i];
    const reversedPhantomSpan = fillPhantomSpans[i];
    plotInterpolatedSpans(path.path, span.from, span.to, ratio2, 1 /* MoveTo */, false);
    plotInterpolatedSpans(
      path.path,
      reversedPhantomSpan.from,
      reversedPhantomSpan.to,
      ratio2,
      2 /* LineTo */,
      true
    );
    path.path.closePath();
  }
}
function prepareAreaFillAnimationFns(status, spans, fillPhantomSpans, visibleToggleMode) {
  const removePhaseFn = (ratio2, path) => plotFillSpans(ratio2, path, spans.removed, fillPhantomSpans.removed);
  const updatePhaseFn = (ratio2, path) => plotFillSpans(ratio2, path, spans.moved, fillPhantomSpans.moved);
  const addPhaseFn = (ratio2, path) => plotFillSpans(ratio2, path, spans.added, fillPhantomSpans.added);
  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);
  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };
}
function plotStrokeSpans(ratio2, path, spans) {
  for (const span of spans) {
    plotInterpolatedSpans(path.path, span.from, span.to, ratio2, 1 /* MoveTo */, false);
  }
}
function prepareAreaStrokeAnimationFns(status, spans, visibleToggleMode) {
  const removePhaseFn = (ratio2, path) => plotStrokeSpans(ratio2, path, spans.removed);
  const updatePhaseFn = (ratio2, path) => plotStrokeSpans(ratio2, path, spans.moved);
  const addPhaseFn = (ratio2, path) => plotStrokeSpans(ratio2, path, spans.added);
  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);
  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };
}
function prepareAreaPathAnimation(newData, oldData) {
  const isCategoryBased = newData.scales.x?.type === "category";
  const wasCategoryBased = oldData.scales.x?.type === "category";
  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {
    return;
  }
  let status = "updated";
  if (oldData.visible && !newData.visible) {
    status = "removed";
  } else if (!oldData.visible && newData.visible) {
    status = "added";
  }
  const fillSpans = pairUpSpans(
    { scales: newData.scales, data: newData.fillData.spans, visible: newData.visible },
    { scales: oldData.scales, data: oldData.fillData.spans, visible: oldData.visible }
  );
  const fillPhantomSpans = pairUpSpans(
    { scales: newData.scales, data: newData.fillData.phantomSpans, visible: newData.visible },
    { scales: oldData.scales, data: oldData.fillData.phantomSpans, visible: oldData.visible }
  );
  const strokeSpans = pairUpSpans(
    {
      scales: newData.scales,
      data: newData.strokeData.spans,
      visible: newData.visible,
      zeroData: newData.fillData.phantomSpans
    },
    {
      scales: oldData.scales,
      data: oldData.strokeData.spans,
      visible: oldData.visible,
      zeroData: oldData.fillData.phantomSpans
    }
  );
  const fadeMode = "none";
  const fill = prepareAreaFillAnimationFns(status, fillSpans, fillPhantomSpans, fadeMode);
  const stroke = prepareAreaStrokeAnimationFns(status, strokeSpans, fadeMode);
  return { status, fill, stroke };
}

// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts
var CROSS_FILTER_AREA_FILL_OPACITY_FACTOR = 0.125;
var CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR = 0.25;
var AreaSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      pathsPerSeries: ["fill", "stroke"],
      pathsZIndexSubOrderOffset: [0, 1e3],
      hasMarkers: true,
      markerSelectionGarbageCollection: false,
      pickModes: [2 /* AXIS_ALIGNED */, 0 /* EXACT_SHAPE_MATCH */],
      animationResetFns: {
        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),
        label: resetLabelFn,
        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })
      }
    });
    this.properties = new AreaSeriesProperties();
  }
  async processData(dataController) {
    if (this.data == null || !this.properties.isValid()) {
      return;
    }
    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;
    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const idMap = {
      value: `area-stack-${groupIndex}-yValue`,
      values: `area-stack-${groupIndex}-yValues`,
      stack: `area-stack-${groupIndex}-yValue-stack`,
      marker: `area-stack-${groupIndex}-yValues-marker`
    };
    const extraProps = [];
    if (isDefined(normalizedTo)) {
      extraProps.push(normaliseGroupTo(Object.values(idMap), normalizedTo, "range"));
    }
    if (animationEnabled) {
      extraProps.push(animationValidation());
    }
    const common = { invalidValue: null };
    if (connectMissingData && stackCount > 1) {
      common.invalidValue = 0;
    }
    if (!visible) {
      common.forceValue = 0;
    }
    await this.requestDataModel(dataController, data, {
      props: [
        keyProperty(xKey, xScaleType, { id: "xValue" }),
        valueProperty(yKey, yScaleType, { id: `yValueRaw`, ...common }),
        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: "yFilterRaw" })] : [],
        ...groupStackValueProperty(yKey, yScaleType, { id: `yValueStack`, ...common, groupId: idMap.stack }),
        valueProperty(yKey, yScaleType, { id: `yValue`, ...common, groupId: idMap.value }),
        ...groupAccumulativeValueProperty(
          yKey,
          "window",
          "current",
          { id: `yValueEnd`, ...common, groupId: idMap.values },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "normal",
          "current",
          { id: `yValueCumulative`, ...common, groupId: idMap.marker },
          yScaleType
        ),
        ...extraProps
      ],
      groupByKeys: true,
      groupByData: false
    });
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel, axes } = this;
    if (!processedData || !dataModel || processedData.data.length === 0)
      return [];
    const yAxis = axes["y" /* Y */];
    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
    const keys = dataModel.getDomain(this, `xValue`, "key", processedData);
    const yExtent = dataModel.getDomain(this, `yValueEnd`, "value", processedData);
    if (direction === "x" /* X */) {
      if (keyDef?.def.type === "key" && keyDef.def.valueType === "category") {
        return keys;
      }
      return fixNumericExtent(extent(keys));
    } else if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {
      return fixNumericExtent(yExtent);
    } else {
      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];
      return fixNumericExtent(fixedYExtent);
    }
  }
  async createNodeData() {
    const { axes, data, processedData: { data: groupedData } = {}, dataModel } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!xAxis || !yAxis || !data || !dataModel || !this.properties.isValid()) {
      return;
    }
    const {
      yKey,
      xKey,
      yFilterKey,
      marker,
      label,
      fill: seriesFill,
      stroke: seriesStroke,
      connectMissingData
    } = this.properties;
    const { scale: xScale } = xAxis;
    const { scale: yScale } = yAxis;
    const { isContinuousY } = this.getScaleInformation({ xScale, yScale });
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const defs = dataModel.resolveProcessedDataDefsByIds(this, [`yValueEnd`, `yValueRaw`, `yValueCumulative`]);
    const yFilterIndex = yFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, "yFilterRaw") : void 0;
    const yValueStackIndex = dataModel.resolveProcessedDataIndexById(this, "yValueStack");
    const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {
      let currY;
      if (isDefined(this.properties.normalizedTo) ? isContinuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {
        currY = yEnd;
      }
      return {
        x: xScale.convert(xDatum) + xOffset,
        y: yScale.convert(currY),
        size: marker.size
      };
    };
    const itemId = yKey;
    const labelData = [];
    const markerData = [];
    const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
    let datumIdx = -1;
    let crossFiltering = false;
    groupedData?.forEach((datumGroup) => {
      const {
        keys,
        keys: [xDatum],
        datum: datumArray,
        values: valuesArray
      } = datumGroup;
      valuesArray.forEach((values, valueIdx) => {
        datumIdx++;
        const seriesDatum = datumArray[valueIdx];
        const dataValues2 = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });
        const { yValueRaw: yDatum, yValueCumulative, yValueEnd } = dataValues2;
        const validPoint = Number.isFinite(yDatum);
        const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);
        const selected = yFilterIndex != null ? values[yFilterIndex] === yDatum : void 0;
        if (selected === false) {
          crossFiltering = true;
        }
        if (validPoint && marker) {
          markerData.push({
            index: datumIdx,
            series: this,
            itemId,
            datum: seriesDatum,
            midPoint: { x: point.x, y: point.y },
            cumulativeValue: yValueEnd,
            yValue: yDatum,
            xValue: xDatum,
            yKey,
            xKey,
            point,
            fill: marker.fill ?? seriesFill,
            stroke: marker.stroke ?? seriesStroke,
            strokeWidth: marker.strokeWidth ?? this.getStrokeWidth(this.properties.strokeWidth),
            selected
          });
        }
        if (validPoint && label) {
          const labelText = this.getLabelText(
            label,
            {
              value: yDatum,
              datum: seriesDatum,
              xKey,
              yKey,
              xName: this.properties.xName,
              yName: this.properties.yName
            },
            formatValue
          );
          labelData.push({
            index: datumIdx,
            series: this,
            itemId: yKey,
            datum: seriesDatum,
            x: point.x,
            y: point.y,
            labelText
          });
        }
      });
    });
    const { interpolation } = this.properties;
    const interpolatePoints = (points) => {
      let spans;
      const pointsIter = points.map((point) => point.point);
      switch (interpolation.type) {
        case "linear":
          spans = linearPoints(pointsIter);
          break;
        case "smooth":
          spans = smoothPoints(pointsIter, interpolation.tension);
          break;
        case "step":
          spans = stepPoints(pointsIter, interpolation.position);
          break;
      }
      return spans.map((span, i) => ({
        span,
        xValue0: points[i].xDatum,
        yValue0: points[i].yDatum,
        xValue1: points[i + 1].xDatum,
        yValue1: points[i + 1].yDatum
      }));
    };
    const spansForPoints = (points) => {
      return points.flatMap((p) => {
        return Array.isArray(p) ? interpolatePoints(p) : new Array(p.skip).fill(null);
      });
    };
    const dataValues = groupedData?.flatMap((datumGroup) => {
      const {
        keys: [xDatum],
        values: valuesArray
      } = datumGroup;
      return valuesArray.map((values) => ({ xDatum, values }));
    });
    const createPoint = (xDatum, yDatum) => ({
      point: {
        x: xScale.convert(xDatum) + xOffset,
        y: yScale.convert(yDatum)
      },
      xDatum,
      yDatum
    });
    const getSeriesSpans = (index) => {
      const points = [];
      if (dataValues == null)
        return [];
      for (let i = 0; i < dataValues.length; i += 1) {
        const { xDatum, values } = dataValues[i];
        const yValueStack = values[yValueStackIndex];
        const yDatum = yValueStack[index];
        const yDatumIsFinite = Number.isFinite(yDatum);
        if (connectMissingData && !yDatumIsFinite)
          continue;
        const lastYValueStack = dataValues[i - 1]?.values[yValueStackIndex];
        const nextYValueStack = dataValues[i + 1]?.values[yValueStackIndex];
        let yValueEndBackwards = 0;
        let yValueEndForwards = 0;
        for (let j = 0; j <= index; j += 1) {
          const value = yValueStack[j];
          if (Number.isFinite(value)) {
            const lastWasFinite = lastYValueStack == null || Number.isFinite(lastYValueStack[j]);
            const nextWasFinite = nextYValueStack == null || Number.isFinite(nextYValueStack[j]);
            if (lastWasFinite) {
              yValueEndBackwards += value;
            }
            if (nextWasFinite) {
              yValueEndForwards += value;
            }
          }
        }
        const currentPoints = points[points.length - 1];
        if (!connectMissingData && (yValueEndBackwards !== yValueEndForwards || !yDatumIsFinite)) {
          if (!yDatumIsFinite && Array.isArray(currentPoints) && currentPoints.length === 1) {
            points[points.length - 1] = { skip: 1 };
          } else {
            const pointBackwards = createPoint(xDatum, yValueEndBackwards);
            const pointForwards = createPoint(xDatum, yValueEndForwards);
            if (Array.isArray(currentPoints)) {
              currentPoints.push(pointBackwards);
            } else if (currentPoints != null) {
              currentPoints.skip += 1;
            }
            points.push(yDatumIsFinite ? [pointForwards] : { skip: 0 });
          }
        } else {
          const yValueEnd = Math.max(yValueEndBackwards, yValueEndForwards);
          const point = createPoint(xDatum, yValueEnd);
          if (Array.isArray(currentPoints)) {
            currentPoints.push(point);
          } else if (currentPoints != null) {
            currentPoints.skip += 1;
            points.push([point]);
          } else {
            points.push([point]);
          }
        }
      }
      return spansForPoints(points);
    };
    const stackIndex = this.seriesGrouping?.stackIndex ?? 0;
    const getAxisSpans = () => {
      if (dataValues == null)
        return [];
      const yValueZeroPoints = dataValues.map(({ xDatum, values }) => {
        const yValueStack = values[yValueStackIndex];
        const yDatum = yValueStack[stackIndex];
        if (connectMissingData && !Number.isFinite(yDatum))
          return;
        return createPoint(xDatum, 0);
      }).filter((x) => x != null);
      return interpolatePoints(yValueZeroPoints);
    };
    const currentSeriesSpans = getSeriesSpans(stackIndex);
    const phantomSpans = currentSeriesSpans.map(() => null);
    for (let j = stackIndex - 1; j >= -1; j -= 1) {
      let spans;
      for (let i = 0; i < phantomSpans.length; i += 1) {
        if (phantomSpans[i] != null)
          continue;
        spans ?? (spans = j !== -1 ? getSeriesSpans(j) : getAxisSpans());
        phantomSpans[i] = spans[i];
      }
    }
    const fillSpans = currentSeriesSpans.map((span, index) => span ?? phantomSpans[index]);
    const strokeSpans = currentSeriesSpans.filter((span) => span != null);
    const context = {
      itemId,
      fillData: { itemId, spans: fillSpans, phantomSpans },
      strokeData: { itemId, spans: strokeSpans },
      labelData,
      nodeData: markerData,
      scales: this.calculateScaling(),
      visible: this.visible,
      stackVisible: visibleSameStackCount > 0,
      crossFiltering
    };
    return context;
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  markerFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker(shape);
    return new MarkerShape();
  }
  async updatePathNodes(opts) {
    const { opacity, visible, animationEnabled } = opts;
    const [fill, stroke] = opts.paths;
    const crossFiltering = this.contextNodeData?.crossFiltering === true;
    const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);
    stroke.setProperties({
      fill: void 0,
      lineJoin: stroke.lineCap = "round",
      pointerEvents: 1 /* None */,
      stroke: this.properties.stroke,
      strokeWidth,
      strokeOpacity: this.properties.strokeOpacity * (crossFiltering ? CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR : 1),
      lineDash: this.properties.lineDash,
      lineDashOffset: this.properties.lineDashOffset,
      opacity,
      visible: visible || animationEnabled
    });
    fill.setProperties({
      stroke: void 0,
      lineJoin: "round",
      pointerEvents: 1 /* None */,
      fill: this.properties.fill,
      fillOpacity: this.properties.fillOpacity * (crossFiltering ? CROSS_FILTER_AREA_FILL_OPACITY_FACTOR : 1),
      fillShadow: this.properties.shadow,
      opacity,
      visible: visible || animationEnabled
    });
    updateClipPath(this, stroke);
    updateClipPath(this, fill);
  }
  async updatePaths(opts) {
    this.updateAreaPaths(opts.paths, opts.contextData);
  }
  updateAreaPaths(paths, contextData) {
    for (const path of paths) {
      path.visible = contextData.visible;
    }
    if (contextData.visible) {
      this.updateFillPath(paths, contextData);
      this.updateStrokePath(paths, contextData);
    } else {
      for (const path of paths) {
        path.path.clear();
        path.checkPathDirty();
      }
    }
  }
  updateFillPath(paths, contextData) {
    const { spans, phantomSpans } = contextData.fillData;
    const [fill] = paths;
    const { path } = fill;
    path.clear(true);
    for (let i = 0; i < spans.length; i += 1) {
      const { span } = spans[i];
      const phantomSpan = phantomSpans[i].span;
      plotSpan(path, span, 1 /* MoveTo */, false);
      plotSpan(path, phantomSpan, 2 /* LineTo */, true);
      path.closePath();
    }
    fill.checkPathDirty();
  }
  updateStrokePath(paths, contextData) {
    const { spans } = contextData.strokeData;
    const [, stroke] = paths;
    const { path } = stroke;
    path.clear(true);
    for (const { span } of spans) {
      plotSpan(path, span, 1 /* MoveTo */, false);
    }
    stroke.checkPathDirty();
  }
  async updateMarkerSelection(opts) {
    const { nodeData, markerSelection } = opts;
    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;
    if (this.properties.marker.isDirty()) {
      markerSelection.clear();
      markerSelection.cleanup();
    }
    return markerSelection.update(markersEnabled ? nodeData : []);
  }
  async updateMarkerNodes(opts) {
    const { markerSelection, isHighlight: highlighted } = opts;
    const { xKey, yKey, marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, highlightStyle } = this.properties;
    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {
      fill,
      stroke,
      strokeWidth,
      fillOpacity,
      strokeOpacity
    });
    markerSelection.each((node, datum) => {
      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, {
        selected: datum.selected
      });
    });
    if (!highlighted) {
      this.properties.marker.markClean();
    }
  }
  async updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData);
  }
  async updateLabelNodes(opts) {
    const { labelSelection } = opts;
    const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;
    labelSelection.each((text, datum) => {
      const { x, y, labelText } = datum;
      if (labelText && labelEnabled && this.visible) {
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontSize = fontSize;
        text.fontFamily = fontFamily;
        text.textAlign = "center";
        text.textBaseline = "bottom";
        text.text = labelText;
        text.x = x;
        text.y = y - 10;
        text.fill = color;
        text.visible = true;
      } else {
        text.visible = false;
      }
    });
  }
  getTooltipHtml(nodeDatum) {
    const { id: seriesId, axes, dataModel } = this;
    const { xKey, xName, yName, tooltip, marker } = this.properties;
    const { yKey, xValue, yValue, datum, itemId } = nodeDatum;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!this.properties.isValid() || !(xAxis && yAxis && isFiniteNumber(yValue)) || !dataModel) {
      return EMPTY_TOOLTIP_CONTENT;
    }
    const xString = xAxis.formatDatum(xValue);
    const yString = yAxis.formatDatum(yValue);
    const title = sanitizeHtml(yName);
    const content = sanitizeHtml(xString + ": " + yString);
    const baseStyle = mergeDefaults({ fill: this.properties.fill }, marker.getStyle(), {
      stroke: this.properties.stroke,
      strokeWidth: this.properties.strokeWidth
    });
    const { fill: color } = this.getMarkerStyle(
      marker,
      { datum: nodeDatum, xKey, yKey, highlighted: false },
      baseStyle
    );
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        datum,
        itemId,
        xKey,
        xName,
        yKey,
        yName,
        color,
        title,
        seriesId
      }
    );
  }
  getLegendData(legendType) {
    if (!this.data?.length || !this.properties.isValid() || !this.properties.showInLegend || legendType !== "category") {
      return [];
    }
    const {
      yKey,
      yName,
      fill,
      stroke,
      fillOpacity,
      strokeOpacity,
      strokeWidth,
      lineDash,
      marker,
      visible,
      legendItemName
    } = this.properties;
    const useAreaFill = !marker.enabled || marker.fill === void 0;
    return [
      {
        legendType,
        id: this.id,
        itemId: yKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: legendItemName ?? yName ?? yKey
        },
        symbols: [
          {
            marker: {
              shape: marker.shape,
              fill: useAreaFill ? fill : marker.fill,
              fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity,
              stroke: marker.stroke ?? stroke,
              strokeOpacity: marker.strokeOpacity ?? strokeOpacity,
              strokeWidth: marker.strokeWidth ?? 0,
              enabled: marker.enabled || strokeWidth <= 0
            },
            line: {
              stroke,
              strokeOpacity,
              strokeWidth,
              lineDash
            }
          }
        ],
        legendItemName
      }
    ];
  }
  animateEmptyUpdateReady(animationData) {
    const { markerSelection, labelSelection, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateAreaPaths(paths, contextData);
    pathSwipeInAnimation(this, animationManager, ...paths);
    resetMotion([markerSelection], resetMarkerPositionFn);
    markerSwipeScaleInAnimation(this, animationManager, markerSelection);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateAreaPaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    const { animationManager } = this.ctx;
    const { markerSelection, labelSelection, contextData, paths, previousContextData } = animationData;
    const [fill, stroke] = paths;
    if (fill == null && stroke == null)
      return;
    this.resetMarkerAnimation(animationData);
    this.resetLabelAnimation(animationData);
    const update = () => {
      this.resetPathAnimation(animationData);
      this.updateAreaPaths(paths, contextData);
    };
    const skip = () => {
      animationManager.skipCurrentBatch();
      update();
    };
    if (contextData == null || previousContextData == null) {
      update();
      markerFadeInAnimation(this, animationManager, "added", markerSelection);
      pathFadeInAnimation(this, "fill_path_properties", animationManager, "add", fill);
      pathFadeInAnimation(this, "stroke_path_properties", animationManager, "add", stroke);
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
      return;
    }
    if (contextData.crossFiltering !== previousContextData.crossFiltering) {
      skip();
      return;
    }
    const fns = prepareAreaPathAnimation(contextData, previousContextData);
    if (fns === void 0) {
      skip();
      return;
    } else if (fns.status === "no-op") {
      return;
    }
    markerFadeInAnimation(this, animationManager, void 0, markerSelection);
    fromToMotion(this.id, "fill_path_properties", animationManager, [fill], fns.fill.pathProperties);
    pathMotion(this.id, "fill_path_update", animationManager, [fill], fns.fill.path);
    fromToMotion(this.id, "stroke_path_properties", animationManager, [stroke], fns.stroke.pathProperties);
    pathMotion(this.id, "stroke_path_update", animationManager, [stroke], fns.stroke.path);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
    this.ctx.animationManager.animate({
      id: this.id,
      groupId: "reset_after_animation",
      phase: "trailing",
      from: {},
      to: {},
      onComplete: () => this.updateAreaPaths(paths, contextData)
    });
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  nodeFactory() {
    return new Group();
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yKey } = datum;
    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
};
AreaSeries.className = "AreaSeries";
AreaSeries.type = "area";

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts
var AreaSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "area",
  moduleFactory: (ctx) => new AreaSeries(ctx),
  stackable: true,
  tooltipDefaults: { range: "nearest" },
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    },
    {
      type: "category" /* CATEGORY */,
      position: "bottom" /* BOTTOM */
    }
  ],
  themeTemplate: {
    series: {
      nodeClickRange: "nearest",
      tooltip: { position: { type: "node" } },
      fillOpacity: 0.8,
      strokeOpacity: 1,
      strokeWidth: 0,
      lineDash: [0],
      lineDashOffset: 0,
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      },
      interpolation: {
        type: "linear",
        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work
        tension: 1,
        position: "end"
      },
      marker: {
        enabled: false,
        shape: "circle",
        size: 7,
        strokeWidth: 0
      },
      label: {
        enabled: false,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_LABEL_COLOUR
      }
    }
  },
  paletteFactory: (params) => {
    const { marker } = markerPaletteFactory(params);
    return { fill: marker.fill, stroke: marker.stroke, marker };
  }
};

// packages/ag-charts-community/src/chart/themes/util.ts
function swapAxisCondition(axes, swap) {
  return (series) => {
    if (!swap(series))
      return axes;
    return [
      { ...axes[0], position: axes[1].position },
      { ...axes[1], position: axes[0].position }
    ];
  };
}

// packages/ag-charts-community/src/chart/series/cartesian/quadtreeUtil.ts
function addHitTestersToQuadtree(quadtree, hitTesters) {
  for (const node of hitTesters) {
    const datum = node.datum;
    if (datum === void 0) {
      Logger.error("undefined datum");
    } else {
      quadtree.addValue(node, datum);
    }
  }
}
function findQuadtreeMatch(series, point) {
  const { x, y } = point;
  const { nearest, distanceSquared: distanceSquared3 } = series.getQuadTree().find(x, y);
  if (nearest !== void 0) {
    return { datum: nearest.value, distance: Math.sqrt(distanceSquared3) };
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts
var AbstractBarSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.direction = "vertical";
  }
};
__decorateClass([
  Validate(DIRECTION)
], AbstractBarSeriesProperties.prototype, "direction", 2);
var AbstractBarSeries = class extends CartesianSeries {
  constructor() {
    super(...arguments);
    /**
     * Used to get the position of bars within each group.
     */
    this.groupScale = new BandScale();
    this.smallestDataInterval = void 0;
    this.largestDataInterval = void 0;
  }
  padBandExtent(keys, alignStart) {
    const ratio2 = typeof alignStart === "boolean" ? 1 : 0.5;
    const scalePadding = isFiniteNumber(this.smallestDataInterval) ? this.smallestDataInterval * ratio2 : 0;
    const keysExtent = extent(keys) ?? [NaN, NaN];
    if (typeof alignStart === "boolean") {
      keysExtent[alignStart ? 0 : 1] -= (alignStart ? 1 : -1) * scalePadding;
    } else {
      keysExtent[0] -= scalePadding;
      keysExtent[1] += scalePadding;
    }
    return fixNumericExtent(keysExtent);
  }
  getBandScalePadding() {
    return { inner: 0.3, outer: 0.15 };
  }
  shouldFlipXY() {
    return !this.isVertical();
  }
  isVertical() {
    return this.properties.direction === "vertical";
  }
  getBarDirection() {
    return this.shouldFlipXY() ? "x" /* X */ : "y" /* Y */;
  }
  getCategoryDirection() {
    return this.shouldFlipXY() ? "y" /* Y */ : "x" /* X */;
  }
  getValueAxis() {
    const direction = this.getBarDirection();
    return this.axes[direction];
  }
  getCategoryAxis() {
    const direction = this.getCategoryDirection();
    return this.axes[direction];
  }
  getBandwidth(xAxis) {
    return ContinuousScale.is(xAxis.scale) ? xAxis.scale.calcBandwidth(this.smallestDataInterval) : xAxis.scale.bandwidth;
  }
  updateGroupScale(xAxis) {
    const domain = [];
    const { groupScale } = this;
    const xBandWidth = this.getBandwidth(xAxis);
    const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
    for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {
      domain.push(String(groupIdx));
    }
    groupScale.domain = domain;
    groupScale.range = [0, xBandWidth ?? 0];
    if (xAxis instanceof CategoryAxis) {
      groupScale.paddingInner = xAxis.groupPaddingInner;
    } else if (xAxis instanceof GroupedCategoryAxis) {
      groupScale.padding = 0.1;
    } else {
      groupScale.padding = 0;
    }
    groupScale.round = groupScale.padding !== 0;
    const barWidth = groupScale.bandwidth >= 1 ? (
      // Pixel-rounded value for low-volume bar charts.
      groupScale.bandwidth
    ) : (
      // Handle high-volume bar charts gracefully.
      groupScale.rawBandwidth
    );
    return { barWidth, groupIndex };
  }
  resolveKeyDirection(direction) {
    if (this.getBarDirection() === "x" /* X */) {
      if (direction === "x" /* X */) {
        return "y" /* Y */;
      }
      return "x" /* X */;
    }
    return direction;
  }
  initQuadTree(quadtree) {
    addHitTestersToQuadtree(quadtree, this.datumNodesIter());
  }
  pickNodeClosestDatum(point) {
    return findQuadtreeMatch(this, point);
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts
var BarSeriesLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.placement = "inside-center";
    this.padding = 0;
  }
};
__decorateClass([
  Validate(
    UNION(
      [
        "inside-center",
        "inside-start",
        "inside-end",
        "outside-start",
        "outside-end",
        // @todo(AG-5950) Deprecate
        { value: "inside", deprecatedTo: "inside-center" },
        { value: "outside", deprecatedTo: "outside-end" }
      ],
      "a placement"
    )
  )
], BarSeriesLabel.prototype, "placement", 2);
__decorateClass([
  Validate(NUMBER)
], BarSeriesLabel.prototype, "padding", 2);
var BarSeriesProperties = class extends AbstractBarSeriesProperties {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.fillOpacity = 1;
    this.stroke = "#874349";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.crisp = void 0;
    this.shadow = new DropShadow();
    this.label = new BarSeriesLabel();
    this.tooltip = new SeriesTooltip();
    this.sparklineMode = false;
  }
};
__decorateClass([
  Validate(STRING)
], BarSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BarSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate(STRING)
], BarSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BarSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BarSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BarSeriesProperties.prototype, "stackGroup", 2);
__decorateClass([
  Validate(NUMBER, { optional: true })
], BarSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Validate(COLOR_STRING)
], BarSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO)
], BarSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING)
], BarSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], BarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO)
], BarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH)
], BarSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], BarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], BarSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], BarSeriesProperties.prototype, "crisp", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], BarSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate(OBJECT, { optional: true })
], BarSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Validate(OBJECT)
], BarSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], BarSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Validate(BOOLEAN)
], BarSeriesProperties.prototype, "sparklineMode", 2);

// packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts
function updateRect(rect, config) {
  rect.crisp = config.crisp ?? true;
  rect.fill = config.fill;
  rect.stroke = config.stroke;
  rect.strokeWidth = config.strokeWidth;
  rect.fillOpacity = config.fillOpacity;
  rect.strokeOpacity = config.strokeOpacity;
  rect.lineDash = config.lineDash;
  rect.lineDashOffset = config.lineDashOffset;
  rect.fillShadow = config.fillShadow;
  rect.topLeftCornerRadius = config.topLeftCornerRadius !== false ? config.cornerRadius ?? 0 : 0;
  rect.topRightCornerRadius = config.topRightCornerRadius !== false ? config.cornerRadius ?? 0 : 0;
  rect.bottomRightCornerRadius = config.bottomRightCornerRadius !== false ? config.cornerRadius ?? 0 : 0;
  rect.bottomLeftCornerRadius = config.bottomLeftCornerRadius !== false ? config.cornerRadius ?? 0 : 0;
  rect.visible = config.visible ?? true;
}
function getRectConfig({
  datum,
  isHighlighted,
  style,
  highlightStyle,
  itemStyler,
  seriesId,
  ctx: { callbackCache },
  ...opts
}) {
  const {
    fill,
    fillOpacity,
    stroke,
    strokeWidth,
    strokeOpacity,
    lineDash,
    lineDashOffset,
    cornerRadius = 0
  } = mergeDefaults(isHighlighted && highlightStyle, style);
  let format;
  if (itemStyler) {
    format = callbackCache.call(itemStyler, {
      datum: datum.datum,
      xKey: datum.xKey,
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      highlighted: isHighlighted,
      seriesId,
      ...opts
    });
  }
  return {
    fill: format?.fill ?? fill,
    fillOpacity: format?.fillOpacity ?? fillOpacity,
    stroke: format?.stroke ?? stroke,
    strokeWidth: format?.strokeWidth ?? strokeWidth,
    strokeOpacity: format?.strokeOpacity ?? strokeOpacity,
    lineDash: format?.lineDash ?? lineDash,
    lineDashOffset: format?.lineDashOffset ?? lineDashOffset,
    cornerRadius: format?.cornerRadius ?? cornerRadius,
    topLeftCornerRadius: style.topLeftCornerRadius,
    topRightCornerRadius: style.topRightCornerRadius,
    bottomRightCornerRadius: style.bottomRightCornerRadius,
    bottomLeftCornerRadius: style.bottomLeftCornerRadius,
    fillShadow: style.fillShadow
  };
}
function checkCrisp(scale2, visibleRange, smallestDataInterval, largestDataInterval) {
  if (visibleRange != null) {
    const [visibleMin, visibleMax] = visibleRange;
    const isZoomed = visibleMin !== 0 || visibleMax !== 1;
    if (isZoomed)
      return false;
  }
  if (ContinuousScale.is(scale2)) {
    const spacing = scale2.calcBandwidth(largestDataInterval) - scale2.calcBandwidth(smallestDataInterval);
    if (spacing > 0 && spacing < 1)
      return false;
  }
  return true;
}
var isDatumNegative = (datum) => {
  return isNegative(datum.yValue ?? 0);
};
function collapsedStartingBarPosition(isVertical, axes, mode) {
  const { startingX, startingY } = getStartingValues(isVertical, axes);
  const calculate = (datum, prevDatum) => {
    let x = isVertical ? datum.x : startingX;
    let y = isVertical ? startingY : datum.y;
    let width = isVertical ? datum.width : 0;
    let height = isVertical ? 0 : datum.height;
    const { opacity } = datum;
    if (prevDatum && (isNaN(x) || isNaN(y))) {
      ({ x, y } = prevDatum);
      width = isVertical ? prevDatum.width : 0;
      height = isVertical ? 0 : prevDatum.height;
      if (isVertical && !isDatumNegative(prevDatum)) {
        y += prevDatum.height;
      } else if (!isVertical && isDatumNegative(prevDatum)) {
        x += prevDatum.width;
      }
    }
    let clipBBox;
    if (datum.clipBBox == null) {
      clipBBox = void 0;
    } else if (isDatumNegative(datum)) {
      clipBBox = isVertical ? new BBox(x, y - height, width, height) : new BBox(x - width, y, width, height);
    } else {
      clipBBox = new BBox(x, y, width, height);
    }
    return { x, y, width, height, clipBBox, opacity };
  };
  return { isVertical, calculate, mode };
}
function prepareBarAnimationFunctions(initPos) {
  const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);
  const fromFn = (rect, datum, status) => {
    if (status === "updated" && isRemoved(datum)) {
      status = "removed";
    } else if (status === "updated" && isRemoved(rect.previousDatum)) {
      status = "added";
    }
    let source;
    if (status === "added" && rect.previousDatum == null && initPos.mode === "fade") {
      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };
    } else if (status === "unknown" || status === "added") {
      source = initPos.calculate(datum, rect.previousDatum);
    } else {
      source = {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        clipBBox: rect.clipBBox,
        opacity: rect.opacity
      };
    }
    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return { ...source, phase };
  };
  const toFn = (rect, datum, status) => {
    let source;
    if (status === "removed" && rect.datum == null && initPos.mode === "fade") {
      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };
    } else if (status === "removed" || isRemoved(datum)) {
      source = initPos.calculate(datum, rect.previousDatum);
    } else {
      source = {
        x: datum.x,
        y: datum.y,
        width: datum.width,
        height: datum.height,
        clipBBox: datum.clipBBox,
        opacity: datum.opacity
      };
    }
    return source;
  };
  return { toFn, fromFn };
}
function getStartingValues(isVertical, axes) {
  const axis = axes[isVertical ? "y" /* Y */ : "x" /* X */];
  let startingX = Infinity;
  let startingY = 0;
  if (!axis) {
    return { startingX, startingY };
  }
  if (isVertical) {
    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));
  } else {
    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));
  }
  return { startingX, startingY };
}
function resetBarSelectionsFn(_node, { x, y, width, height, clipBBox, opacity }) {
  return { x, y, width, height, clipBBox, opacity };
}
function computeBarFocusBounds(datum, barGroup, seriesRect) {
  if (datum === void 0)
    return void 0;
  const { x, y, width, height } = datum;
  return Transformable.toCanvas(barGroup, new BBox(x, y, width, height)).clip(seriesRect);
}

// packages/ag-charts-community/src/chart/series/cartesian/labelUtil.ts
function updateLabelNode(textNode, label, labelDatum) {
  if (label.enabled && labelDatum) {
    const { x, y, text, textAlign, textBaseline } = labelDatum;
    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;
    textNode.setProperties({
      visible: true,
      x,
      y,
      text,
      fill,
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily,
      textAlign,
      textBaseline
    });
  } else {
    textNode.visible = false;
  }
}
var placements = {
  "inside-start": { inside: true, direction: -1, textAlignment: 1 },
  "inside-end": { inside: true, direction: 1, textAlignment: -1 },
  "outside-start": { inside: false, direction: -1, textAlignment: -1 },
  "outside-end": { inside: false, direction: 1, textAlignment: 1 }
};
function adjustLabelPlacement({
  isUpward,
  isVertical,
  placement,
  padding = 0,
  rect
}) {
  let x = rect.x + rect.width / 2;
  let y = rect.y + rect.height / 2;
  let textAlign = "center";
  let textBaseline = "middle";
  if (placement !== "inside-center") {
    const barDirection = (isUpward ? 1 : -1) * (isVertical ? -1 : 1);
    const { direction, textAlignment } = placements[placement];
    const displacementRatio = (direction + 1) * 0.5;
    if (isVertical) {
      const y0 = isUpward ? rect.y + rect.height : rect.y;
      const height = rect.height * barDirection;
      y = y0 + height * displacementRatio + padding * textAlignment * barDirection;
      textBaseline = textAlignment === barDirection ? "top" : "bottom";
    } else {
      const x0 = isUpward ? rect.x : rect.x + rect.width;
      const width = rect.width * barDirection;
      x = x0 + width * displacementRatio + padding * textAlignment * barDirection;
      textAlign = textAlignment === barDirection ? "left" : "right";
    }
  }
  return { x, y, textAlign, textBaseline };
}

// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts
var labelPlacements2 = {
  "inside-center": "inside-center",
  "inside-start": "inside-start",
  "inside-end": "inside-end",
  "outside-start": "outside-start",
  "outside-end": "outside-end",
  inside: "inside-center",
  outside: "outside-end"
};
var BarSeries = class extends AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      pickModes: [
        2 /* AXIS_ALIGNED */,
        // Only used in sparklineMode
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      pathsPerSeries: [],
      hasHighlightedLabels: true,
      datumSelectionGarbageCollection: false,
      animationAlwaysUpdateSelections: true,
      animationResetFns: {
        datum: resetBarSelectionsFn,
        label: resetLabelFn
      }
    });
    this.properties = new BarSeriesProperties();
  }
  get pickModeAxis() {
    return this.properties.sparklineMode ? "main" : void 0;
  }
  crossFilteringEnabled() {
    return this.properties.yFilterKey != null && (this.seriesGrouping == null || this.seriesGrouping.stackIndex === 0);
  }
  async processData(dataController) {
    if (!this.properties.isValid() || !this.data) {
      return;
    }
    const { seriesGrouping: { groupIndex = this.id } = {}, data = [] } = this;
    const { xKey, yKey, yFilterKey, normalizedTo } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const stackGroupName = `bar-stack-${groupIndex}-yValues`;
    const stackGroupTrailingName = `${stackGroupName}-trailing`;
    const extraProps = [];
    if (isFiniteNumber(normalizedTo)) {
      extraProps.push(
        normaliseGroupTo([stackGroupName, stackGroupTrailingName], Math.abs(normalizedTo), "range")
      );
    }
    if (animationEnabled && this.processedData) {
      extraProps.push(diff(this.processedData));
    }
    if (animationEnabled) {
      extraProps.push(animationValidation());
    }
    const visibleProps = this.visible ? {} : { forceValue: 0 };
    const { processedData } = await this.requestDataModel(dataController, data, {
      props: [
        keyProperty(xKey, xScaleType, { id: "xValue" }),
        valueProperty(yKey, yScaleType, { id: `yValue-raw`, invalidValue: null, ...visibleProps }),
        ...this.crossFilteringEnabled() ? [
          valueProperty(yFilterKey, yScaleType, {
            id: `yFilterValue`,
            invalidValue: null,
            ...visibleProps
          })
        ] : [],
        ...groupAccumulativeValueProperty(
          yKey,
          "normal",
          "current",
          {
            id: `yValue-end`,
            rangeId: `yValue-range`,
            invalidValue: null,
            missingValue: 0,
            groupId: stackGroupName,
            separateNegative: true,
            ...visibleProps
          },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "trailing",
          "current",
          {
            id: `yValue-start`,
            invalidValue: null,
            missingValue: 0,
            groupId: stackGroupTrailingName,
            separateNegative: true,
            ...visibleProps
          },
          yScaleType
        ),
        ...isContinuousX ? [SMALLEST_KEY_INTERVAL, LARGEST_KEY_INTERVAL] : [],
        ...extraProps
      ],
      groupByKeys: true,
      groupByData: false
    });
    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;
    this.largestDataInterval = processedData.reduced?.largestKeyInterval;
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!dataModel || !processedData?.data.length)
      return [];
    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
    const keys = dataModel.getDomain(this, `xValue`, "key", processedData);
    let yExtent = dataModel.getDomain(this, `yValue-end`, "value", processedData);
    const yFilterExtent = this.crossFilteringEnabled() ? dataModel.getDomain(this, `yFilterValue`, "value", processedData) : void 0;
    if (yFilterExtent != null) {
      yExtent = [Math.min(yExtent[0], yFilterExtent[0]), Math.max(yExtent[1], yFilterExtent[1])];
    }
    if (direction === this.getCategoryDirection()) {
      if (keyDef?.def.type === "key" && keyDef.def.valueType === "category") {
        return keys;
      }
      return this.padBandExtent(keys);
    } else if (this.getValueAxis() instanceof LogAxis) {
      return fixNumericExtent(yExtent);
    } else {
      const fixedYExtent = [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])];
      return fixNumericExtent(fixedYExtent);
    }
  }
  async createNodeData() {
    const { dataModel } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!dataModel || !xAxis || !yAxis || !this.properties.isValid())
      return;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius, legendItemName, label } = this.properties;
    const yReversed = yAxis.isReversed();
    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);
    const barOffset = ContinuousScale.is(xScale) ? barWidth * -0.5 : 0;
    const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);
    const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-raw`);
    const yFilterIndex = this.crossFilteringEnabled() ? dataModel.resolveProcessedDataIndexById(this, `yFilterValue`) : void 0;
    const yStartIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-start`);
    const yEndIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-end`);
    const yRangeIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-range`);
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const nodeDatum = ({
      datum,
      valueIndex,
      xValue,
      yValue,
      cumulativeValue,
      phantom,
      currY,
      prevY,
      isPositive,
      yRange,
      labelText,
      crossScale = 1
    }) => {
      const x = xScale.convert(xValue);
      const isUpward = isPositive !== yReversed;
      const barX = x + groupScale.convert(String(groupIndex)) + barOffset;
      const y = yScale.convert(currY);
      const bottomY = yScale.convert(prevY);
      const barAlongX = this.getBarDirection() === "x" /* X */;
      const bboxHeight = yScale.convert(yRange);
      const bboxBottom = yScale.convert(0);
      const xOffset = barWidth * 0.5 * (1 - crossScale);
      const rect = {
        x: barAlongX ? Math.min(y, bottomY) : barX + xOffset,
        y: barAlongX ? barX + xOffset : Math.min(y, bottomY),
        width: barAlongX ? Math.abs(bottomY - y) : barWidth * crossScale,
        height: barAlongX ? barWidth * crossScale : Math.abs(bottomY - y)
      };
      const clipBBox = new BBox(rect.x, rect.y, rect.width, rect.height);
      const barRect = {
        x: barAlongX ? Math.min(bboxBottom, bboxHeight) : barX + xOffset,
        y: barAlongX ? barX + xOffset : Math.min(bboxBottom, bboxHeight),
        width: barAlongX ? Math.abs(bboxBottom - bboxHeight) : barWidth * crossScale,
        height: barAlongX ? barWidth * crossScale : Math.abs(bboxBottom - bboxHeight)
      };
      const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;
      return {
        series: this,
        itemId: phantom ? createDatumId(yKey, phantom) : yKey,
        datum,
        valueIndex,
        cumulativeValue,
        phantom,
        xValue,
        yValue,
        yKey,
        xKey,
        capDefaults: {
          lengthRatioMultiplier,
          lengthMax: lengthRatioMultiplier
        },
        x: barRect.x,
        y: barRect.y,
        width: barRect.width,
        height: barRect.height,
        midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },
        fill,
        stroke,
        opacity: 1,
        strokeWidth,
        cornerRadius,
        topLeftCornerRadius: barAlongX !== isUpward,
        topRightCornerRadius: isUpward,
        bottomRightCornerRadius: barAlongX === isUpward,
        bottomLeftCornerRadius: !isUpward,
        clipBBox,
        label: labelText != null ? {
          text: labelText,
          ...adjustLabelPlacement({
            isUpward,
            isVertical: !barAlongX,
            placement: labelPlacements2[label.placement],
            padding: label.padding,
            rect
          })
        } : void 0,
        missing: yValue == null,
        focusable: !phantom
      };
    };
    const { groupScale, processedData } = this;
    const phantomNodes = [];
    const nodes = [];
    const labels = [];
    processedData?.data.forEach(({ keys, datum: seriesDatum, values, aggValues }) => {
      values.forEach((value, valueIndex) => {
        const xValue = keys[xIndex];
        const yRawValue = value[yRawIndex];
        const yStart = Number(value[yStartIndex]);
        const yFilterValue = yFilterIndex != null ? Number(value[yFilterIndex]) : void 0;
        const yEnd = Number(value[yEndIndex]);
        const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);
        const yRange = aggValues?.[yRangeIndex][isPositive ? 1 : 0] ?? 0;
        if (!Number.isFinite(yEnd))
          return;
        if (yFilterValue != null && !Number.isFinite(yFilterValue))
          return;
        const labelText = yRawValue != null ? this.getLabelText(
          this.properties.label,
          {
            datum: seriesDatum[valueIndex],
            value: yFilterValue ?? yRawValue,
            xKey,
            yKey,
            xName,
            yName,
            legendItemName
          },
          formatValue
        ) : void 0;
        const inset = yFilterValue != null && yFilterValue > yRawValue;
        const nodeData = nodeDatum({
          datum: seriesDatum[valueIndex],
          valueIndex,
          xValue,
          yValue: yFilterValue ?? yRawValue,
          cumulativeValue: yFilterValue ?? yEnd,
          phantom: false,
          currY: yFilterValue != null ? yStart + yFilterValue : yEnd,
          prevY: yStart,
          isPositive,
          yRange: Math.max(yStart + (yFilterValue ?? -Infinity), yRange),
          labelText,
          crossScale: inset ? 0.6 : void 0
        });
        nodes.push(nodeData);
        labels.push(nodeData);
        if (yFilterValue != null) {
          const phantomNodeData = nodeDatum({
            datum: seriesDatum[valueIndex],
            valueIndex,
            xValue,
            yValue: yFilterValue,
            cumulativeValue: yFilterValue,
            phantom: true,
            currY: yEnd,
            prevY: yStart,
            isPositive,
            yRange,
            labelText: void 0,
            crossScale: void 0
          });
          phantomNodes.push(phantomNodeData);
        }
      });
    });
    return {
      itemId: yKey,
      nodeData: phantomNodes.length > 0 ? [...phantomNodes, ...nodes] : nodes,
      labelData: labels,
      scales: this.calculateScaling(),
      visible: this.visible || animationEnabled
    };
  }
  nodeFactory() {
    return new Rect();
  }
  getHighlightData(nodeData, highlightedItem) {
    const highlightItem = nodeData.find(
      (nodeDatum) => nodeDatum.datum === highlightedItem.datum && !nodeDatum.phantom
    );
    return highlightItem != null ? [highlightItem] : void 0;
  }
  async updateDatumSelection(opts) {
    return opts.datumSelection.update(
      opts.nodeData,
      void 0,
      (datum) => createDatumId(datum.xValue, datum.valueIndex, datum.phantom)
    );
  }
  async updateDatumNodes(opts) {
    if (!this.properties.isValid()) {
      return;
    }
    const {
      yKey,
      stackGroup,
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      itemStyler,
      shadow,
      highlightStyle: { item: itemHighlightStyle }
    } = this.properties;
    const xAxis = this.axes["x" /* X */];
    const crisp = this.properties.crisp ?? checkCrisp(xAxis?.scale, xAxis?.visibleRange, this.smallestDataInterval, this.largestDataInterval);
    const categoryAlongX = this.getCategoryDirection() === "x" /* X */;
    const style = {
      fill,
      stroke,
      lineDash,
      lineDashOffset,
      fillShadow: shadow,
      strokeWidth: this.getStrokeWidth(strokeWidth),
      fillOpacity: 0,
      strokeOpacity: 0
    };
    const rectParams = {
      datum: void 0,
      ctx: this.ctx,
      seriesId: this.id,
      isHighlighted: opts.isHighlight,
      highlightStyle: itemHighlightStyle,
      yKey,
      style,
      itemStyler,
      stackGroup
    };
    opts.datumSelection.each((rect, datum) => {
      style.fillOpacity = fillOpacity * (datum.phantom ? 0.2 : 1);
      style.strokeOpacity = strokeOpacity * (datum.phantom ? 0.2 : 1);
      style.cornerRadius = datum.cornerRadius;
      style.topLeftCornerRadius = datum.topLeftCornerRadius;
      style.topRightCornerRadius = datum.topRightCornerRadius;
      style.bottomRightCornerRadius = datum.bottomRightCornerRadius;
      style.bottomLeftCornerRadius = datum.bottomLeftCornerRadius;
      const visible = categoryAlongX ? (datum.clipBBox?.width ?? datum.width) > 0 : (datum.clipBBox?.height ?? datum.height) > 0;
      rectParams.datum = datum;
      const config = getRectConfig(rectParams);
      config.crisp = crisp;
      config.visible = visible;
      updateRect(rect, config);
    });
  }
  async updateLabelSelection(opts) {
    const data = this.isLabelEnabled() ? opts.labelData : [];
    return opts.labelSelection.update(data, (text) => {
      text.pointerEvents = 1 /* None */;
    });
  }
  async updateLabelNodes(opts) {
    opts.labelSelection.each((textNode, datum) => {
      updateLabelNode(textNode, this.properties.label, datum.label);
    });
  }
  getTooltipHtml(nodeDatum) {
    const {
      id: seriesId,
      processedData,
      ctx: { callbackCache }
    } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!processedData || !this.properties.isValid() || !xAxis || !yAxis) {
      return EMPTY_TOOLTIP_CONTENT;
    }
    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, tooltip, itemStyler, stackGroup, legendItemName } = this.properties;
    const { xValue, yValue, datum, itemId } = nodeDatum;
    const xString = xAxis.formatDatum(xValue);
    const yString = yAxis.formatDatum(yValue);
    const title = sanitizeHtml(yName);
    const content = sanitizeHtml(xString + ": " + yString);
    let format;
    if (itemStyler) {
      format = callbackCache.call(itemStyler, {
        seriesId,
        datum,
        xKey,
        yKey,
        stackGroup,
        fill,
        stroke,
        strokeWidth: this.getStrokeWidth(strokeWidth),
        highlighted: false,
        cornerRadius: this.properties.cornerRadius,
        fillOpacity: this.properties.fillOpacity,
        strokeOpacity: this.properties.strokeOpacity,
        lineDash: this.properties.lineDash ?? [],
        lineDashOffset: this.properties.lineDashOffset
      });
    }
    const color = format?.fill ?? fill;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        seriesId,
        itemId,
        datum,
        xKey,
        yKey,
        xName,
        yName,
        stackGroup,
        title,
        color,
        legendItemName,
        ...this.getModuleTooltipParams()
      }
    );
  }
  getLegendData(legendType) {
    const { showInLegend } = this.properties;
    if (legendType !== "category" || !this.data?.length || !this.properties.isValid() || !showInLegend) {
      return [];
    }
    const { yKey, yName, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, legendItemName, visible } = this.properties;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: yKey,
        seriesId: this.id,
        enabled: visible,
        label: { text: legendItemName ?? yName ?? yKey },
        symbols: [{ marker: { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } }],
        legendItemName
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection, annotationSelections }) {
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, "normal"));
    fromToMotion(this.id, "nodes", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
    seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
  }
  animateWaitingUpdateReady(data) {
    const { datumSelection, labelSelection, annotationSelections, previousContextData } = data;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const dataDiff = this.processedData?.reduced?.diff;
    const mode = previousContextData == null ? "fade" : "normal";
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));
    fromToMotion(
      this.id,
      "nodes",
      this.ctx.animationManager,
      [datumSelection],
      fns,
      (_, datum) => createDatumId(datum.xValue, datum.valueIndex, datum.phantom),
      dataDiff
    );
    const hasMotion = dataDiff?.changed ?? true;
    if (hasMotion) {
      seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
      seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
    }
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  computeFocusBounds({ datumIndex, seriesRect }) {
    const datumBox = this.contextNodeData?.nodeData[datumIndex].clipBBox;
    return computeBarFocusBounds(datumBox, this.contentGroup, seriesRect);
  }
};
BarSeries.className = "BarSeries";
BarSeries.type = "bar";

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts
var BarSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "bar",
  moduleFactory: (ctx) => new BarSeries(ctx),
  stackable: true,
  groupable: true,
  tooltipDefaults: { range: "exact" },
  defaultAxes: swapAxisCondition(
    [
      { type: "number" /* NUMBER */, position: "left" /* LEFT */ },
      { type: "category" /* CATEGORY */, position: "bottom" /* BOTTOM */ }
    ],
    (series) => series?.direction === "horizontal"
  ),
  themeTemplate: {
    series: {
      direction: "vertical",
      fillOpacity: 1,
      strokeWidth: 0,
      lineDash: [0],
      lineDashOffset: 0,
      label: {
        enabled: false,
        fontWeight: "normal" /* NORMAL */,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
        placement: "inside-center"
      },
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      },
      errorBar: {
        cap: {
          lengthRatio: 0.3
        }
      }
    }
  },
  paletteFactory: singleSeriesPaletteFactory
};

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts
var BubbleSeriesMarker = class extends SeriesMarker {
  constructor() {
    super(...arguments);
    this.maxSize = 30;
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], BubbleSeriesMarker.prototype, "maxSize", 2);
__decorateClass([
  Validate(NUMBER_ARRAY, { optional: true }),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], BubbleSeriesMarker.prototype, "domain", 2);
var BubbleSeriesLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.placement = "top";
  }
};
__decorateClass([
  Validate(LABEL_PLACEMENT)
], BubbleSeriesLabel.prototype, "placement", 2);
var BubbleSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.colorRange = ["#ffff00", "#00ff00", "#0000ff"];
    this.label = new BubbleSeriesLabel();
    this.tooltip = new SeriesTooltip();
    // No validation. Not a part of the options contract.
    this.marker = new BubbleSeriesMarker();
  }
};
__decorateClass([
  Validate(STRING)
], BubbleSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate(STRING)
], BubbleSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate(STRING)
], BubbleSeriesProperties.prototype, "sizeKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "colorKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "xFilterKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "sizeFilterKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "sizeName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "labelName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "colorName", 2);
__decorateClass([
  Validate(NUMBER_ARRAY, { optional: true })
], BubbleSeriesProperties.prototype, "colorDomain", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], BubbleSeriesProperties.prototype, "colorRange", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "title", 2);
__decorateClass([
  ProxyProperty("marker.shape")
], BubbleSeriesProperties.prototype, "shape", 2);
__decorateClass([
  ProxyProperty("marker.size")
], BubbleSeriesProperties.prototype, "size", 2);
__decorateClass([
  ProxyProperty("marker.maxSize")
], BubbleSeriesProperties.prototype, "maxSize", 2);
__decorateClass([
  ProxyProperty("marker.domain", { optional: true })
], BubbleSeriesProperties.prototype, "domain", 2);
__decorateClass([
  ProxyProperty("marker.fill", { optional: true })
], BubbleSeriesProperties.prototype, "fill", 2);
__decorateClass([
  ProxyProperty("marker.fillOpacity")
], BubbleSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  ProxyProperty("marker.stroke", { optional: true })
], BubbleSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  ProxyProperty("marker.strokeWidth")
], BubbleSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  ProxyProperty("marker.strokeOpacity")
], BubbleSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  ProxyProperty("marker.itemStyler", { optional: true })
], BubbleSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate(OBJECT)
], BubbleSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], BubbleSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts
var BubbleSeriesNodeEvent = class extends CartesianSeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.sizeKey = series.properties.sizeKey;
  }
};
var BubbleSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      pickModes: [
        2 /* AXIS_ALIGNED */,
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      pathsPerSeries: [],
      hasMarkers: true,
      markerSelectionGarbageCollection: false,
      animationResetFns: {
        label: resetLabelFn,
        marker: resetMarkerFn
      }
    });
    this.NodeEvent = BubbleSeriesNodeEvent;
    this.properties = new BubbleSeriesProperties();
    this.sizeScale = new LinearScale();
    this.colorScale = new ColorScale();
  }
  get pickModeAxis() {
    return "main-category";
  }
  async processData(dataController) {
    if (!this.properties.isValid() || this.data == null || !this.visible)
      return;
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const colorScaleType = this.colorScale.type;
    const sizeScaleType = this.sizeScale.type;
    const {
      xKey,
      yKey,
      sizeKey,
      xFilterKey,
      yFilterKey,
      sizeFilterKey,
      labelKey,
      colorDomain,
      colorRange,
      colorKey,
      marker
    } = this.properties;
    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        valueProperty(xKey, xScaleType, { id: `xValue` }),
        valueProperty(yKey, yScaleType, { id: `yValue` }),
        ...xFilterKey != null ? [valueProperty(xFilterKey, xScaleType, { id: `xFilterValue` })] : [],
        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: `yFilterValue` })] : [],
        ...sizeFilterKey != null ? [valueProperty(sizeFilterKey, sizeScaleType, { id: `sizeFilterValue` })] : [],
        valueProperty(sizeKey, sizeScaleType, { id: `sizeValue` }),
        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],
        ...labelKey ? [valueProperty(labelKey, "band", { id: `labelValue` })] : []
      ]
    });
    const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);
    const processedSize = processedData.domain.values[sizeKeyIdx] ?? [];
    this.sizeScale.domain = marker.domain ? marker.domain : processedSize;
    if (colorKey) {
      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);
      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];
      this.colorScale.range = colorRange;
      this.colorScale.update();
    }
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    const id = direction === "x" /* X */ ? `xValue` : `yValue`;
    const dataDef = dataModel.resolveProcessedDataDefById(this, id);
    const domain = dataModel.getDomain(this, id, "value", processedData);
    if (dataDef?.def.type === "value" && dataDef?.def.valueType === "category") {
      return domain;
    }
    return fixNumericExtent(extent(domain));
  }
  async createNodeData() {
    const { axes, dataModel, processedData, colorScale, sizeScale } = this;
    const {
      xKey,
      yKey,
      sizeKey,
      xFilterKey,
      yFilterKey,
      sizeFilterKey,
      labelKey,
      xName,
      yName,
      sizeName,
      labelName,
      label,
      colorKey,
      marker,
      visible
    } = this.properties;
    const markerShape = getMarker(marker.shape);
    const { placement } = label;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!(dataModel && processedData && visible && xAxis && yAxis)) {
      return;
    }
    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);
    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);
    const sizeDataIdx = sizeKey != null ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : void 0;
    const colorDataIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;
    const labelDataIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;
    const xFilterDataIdx = xFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `xFilterValue`) : void 0;
    const yFilterDataIdx = yFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `yFilterValue`) : void 0;
    const sizeFilterDataIdx = sizeFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `sizeFilterValue`) : void 0;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const yOffset = (yScale.bandwidth ?? 0) / 2;
    const nodeData = [];
    sizeScale.range = [marker.size, marker.maxSize];
    const font = label.getFont();
    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });
    for (const { values, datum } of processedData.data ?? []) {
      const xDatum = values[xDataIdx];
      const yDatum = values[yDataIdx];
      const sizeValue = sizeDataIdx != null ? values[sizeDataIdx] : void 0;
      const x = xScale.convert(xDatum) + xOffset;
      const y = yScale.convert(yDatum) + yOffset;
      let selected;
      if (xFilterDataIdx != null && yFilterDataIdx != null) {
        selected = values[xFilterDataIdx] === xDatum && values[yFilterDataIdx] === yDatum;
        if (sizeFilterDataIdx != null) {
          selected && (selected = values[sizeFilterDataIdx] === sizeValue);
        }
      }
      const labelText = this.getLabelText(label, {
        value: labelKey ? values[labelDataIdx] : yDatum,
        datum,
        xKey,
        yKey,
        sizeKey,
        labelKey,
        xName,
        yName,
        sizeName,
        labelName
      });
      const size = textMeasurer.measureText(String(labelText));
      const markerSize = sizeValue ? sizeScale.convert(sizeValue) : marker.size;
      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;
      nodeData.push({
        series: this,
        itemId: yKey,
        yKey,
        xKey,
        datum,
        xValue: xDatum,
        yValue: yDatum,
        sizeValue,
        point: { x, y, size: markerSize },
        midPoint: { x, y },
        fill,
        label: { text: labelText, ...size },
        marker: markerShape,
        placement,
        selected
      });
    }
    return {
      itemId: yKey,
      nodeData,
      labelData: nodeData,
      scales: this.calculateScaling(),
      visible: this.visible
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  getLabelData() {
    return this.contextNodeData?.labelData ?? [];
  }
  markerFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker(shape);
    return new MarkerShape();
  }
  async updateMarkerSelection(opts) {
    const { nodeData, markerSelection } = opts;
    if (this.properties.marker.isDirty()) {
      markerSelection.clear();
      markerSelection.cleanup();
    }
    const data = this.properties.marker.enabled ? nodeData : [];
    return markerSelection.update(
      data,
      void 0,
      (datum) => createDatumId([datum.xValue, datum.yValue, datum.label.text])
    );
  }
  async updateMarkerNodes(opts) {
    const { markerSelection, isHighlight: highlighted } = opts;
    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;
    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = mergeDefaults(
      highlighted && this.properties.highlightStyle.item,
      marker.getStyle()
    );
    const baseStyle = { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };
    this.sizeScale.range = [marker.size, marker.maxSize];
    markerSelection.each((node, datum) => {
      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, sizeKey, labelKey }, baseStyle, {
        selected: datum.selected
      });
    });
    if (!highlighted) {
      this.properties.marker.markClean();
    }
  }
  async updateLabelSelection(opts) {
    const placedLabels = this.properties.label.enabled ? this.chart?.placeLabels().get(this) ?? [] : [];
    return opts.labelSelection.update(
      placedLabels.map((v) => ({
        ...v.datum,
        point: {
          x: v.x,
          y: v.y,
          size: v.datum.point.size
        }
      }))
    );
  }
  async updateLabelNodes(opts) {
    const { label } = this.properties;
    opts.labelSelection.each((text, datum) => {
      text.text = datum.label.text;
      text.fill = label.color;
      text.x = datum.point?.x ?? 0;
      text.y = datum.point?.y ?? 0;
      text.fontStyle = label.fontStyle;
      text.fontWeight = label.fontWeight;
      text.fontSize = label.fontSize;
      text.fontFamily = label.fontFamily;
      text.textAlign = "left";
      text.textBaseline = "top";
    });
  }
  getTooltipHtml(nodeDatum) {
    const xAxis = this.axes["x" /* X */];
    const yAxis = this.axes["y" /* Y */];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return EMPTY_TOOLTIP_CONTENT;
    }
    const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, marker, tooltip } = this.properties;
    const title = this.properties.title ?? yName;
    const baseStyle = mergeDefaults(
      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },
      marker.getStyle()
    );
    const { fill: color = "gray" } = this.getMarkerStyle(
      marker,
      { datum: nodeDatum, highlighted: false, xKey, yKey, sizeKey, labelKey },
      baseStyle
    );
    const {
      datum,
      xValue,
      yValue,
      sizeValue,
      label: { text: labelText },
      itemId
    } = nodeDatum;
    const xString = sanitizeHtml(xAxis.formatDatum(xValue));
    const yString = sanitizeHtml(yAxis.formatDatum(yValue));
    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;
    if (sizeKey) {
      content += `<br><b>${sanitizeHtml(sizeName ?? sizeKey)}</b>: ${sanitizeHtml(String(sizeValue))}`;
    }
    if (labelKey) {
      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(labelText)}<br>` + content;
    }
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        datum,
        itemId,
        xKey,
        xName,
        yKey,
        yName,
        sizeKey,
        sizeName,
        labelKey,
        labelName,
        title,
        color,
        seriesId: this.id
      }
    );
  }
  getLegendData() {
    if (!this.data?.length || !this.properties.isValid()) {
      return [];
    }
    const { yKey, yName, title, marker, visible } = this.properties;
    const { shape, fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: yKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: title ?? yName ?? yKey
        },
        symbols: [
          {
            marker: {
              shape,
              fill: fill ?? "rgba(0, 0, 0, 0)",
              stroke: stroke ?? "rgba(0, 0, 0, 0)",
              fillOpacity: fillOpacity ?? 1,
              strokeOpacity: strokeOpacity ?? 1,
              strokeWidth: strokeWidth ?? 0
            }
          }
        ]
      }
    ];
  }
  animateEmptyUpdateReady({ markerSelection, labelSelection }) {
    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  nodeFactory() {
    return new Group();
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yKey, sizeKey, labelKey } = this.properties;
    return this.getMarkerStyle(this.properties.marker, {
      datum,
      xKey,
      yKey,
      sizeKey,
      labelKey,
      highlighted: false
    });
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
};
BubbleSeries.className = "BubbleSeries";
BubbleSeries.type = "bubble";

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts
var BubbleSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "bubble",
  moduleFactory: (ctx) => new BubbleSeries(ctx),
  tooltipDefaults: { range: "nearest" },
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "bottom" /* BOTTOM */
    },
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    }
  ],
  themeTemplate: {
    series: {
      shape: "circle",
      size: 7,
      maxSize: 30,
      fillOpacity: 0.8,
      tooltip: { position: { type: "node" } },
      label: {
        enabled: false,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_LABEL_COLOUR
      }
    }
  },
  paletteFactory: singleSeriesPaletteFactory
};

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts
var HistogramSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.areaPlot = false;
    this.aggregation = "sum";
    this.shadow = new DropShadow();
    this.label = new Label();
    this.tooltip = new SeriesTooltip();
  }
};
__decorateClass([
  Validate(STRING)
], HistogramSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], HistogramSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], HistogramSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], HistogramSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], HistogramSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO)
], HistogramSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], HistogramSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], HistogramSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO)
], HistogramSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH)
], HistogramSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], HistogramSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], HistogramSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Validate(BOOLEAN)
], HistogramSeriesProperties.prototype, "areaPlot", 2);
__decorateClass([
  Validate(ARRAY, { optional: true })
], HistogramSeriesProperties.prototype, "bins", 2);
__decorateClass([
  Validate(UNION(["count", "sum", "mean"], "a histogram aggregation"))
], HistogramSeriesProperties.prototype, "aggregation", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], HistogramSeriesProperties.prototype, "binCount", 2);
__decorateClass([
  Validate(OBJECT)
], HistogramSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Validate(OBJECT)
], HistogramSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], HistogramSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts
var defaultBinCount = 10;
var HistogramSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
      datumSelectionGarbageCollection: false,
      animationResetFns: {
        datum: resetBarSelectionsFn,
        label: resetLabelFn
      }
    });
    this.properties = new HistogramSeriesProperties();
    this.calculatedBins = [];
  }
  // During processData phase, used to unify different ways of the user specifying
  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].
  deriveBins(xDomain) {
    const binStarts = createTicks(xDomain[0], xDomain[1], defaultBinCount);
    const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);
    const [firstBinEnd] = binStarts;
    const expandStartToBin = (n) => [n, n + binSize];
    return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];
  }
  calculateNiceBins(domain, binCount) {
    const startGuess = Math.floor(domain[0]);
    const stop = domain[1];
    const segments = binCount || 1;
    const { start, binSize } = this.calculateNiceStart(startGuess, stop, segments);
    return this.getBins(start, stop, binSize, segments);
  }
  getBins(start, stop, step, count) {
    const bins = [];
    const precision = this.calculatePrecision(step);
    for (let i = 0; i < count; i++) {
      const a = Math.round((start + i * step) * precision) / precision;
      let b = Math.round((start + (i + 1) * step) * precision) / precision;
      if (i === count - 1) {
        b = Math.max(b, stop);
      }
      bins[i] = [a, b];
    }
    return bins;
  }
  calculatePrecision(step) {
    let precision = 10;
    if (isFinite(step) && step > 0) {
      while (step < 1) {
        precision *= 10;
        step *= 10;
      }
    }
    return precision;
  }
  calculateNiceStart(a, b, segments) {
    const binSize = Math.abs(b - a) / segments;
    const order = Math.floor(Math.log10(binSize));
    const magnitude = Math.pow(10, order);
    const start = Math.floor(a / magnitude) * magnitude;
    return {
      start,
      binSize
    };
  }
  async processData(dataController) {
    if (!this.visible) {
      this.processedData = void 0;
      this.animationState.transition("updateData");
    }
    const { xKey, yKey, areaPlot, aggregation } = this.properties;
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ yScale, xScale });
    const props = [keyProperty(xKey, xScaleType), SORT_DOMAIN_GROUPS];
    if (yKey) {
      let aggProp = groupCount("groupAgg");
      if (aggregation === "count") {
      } else if (aggregation === "sum") {
        aggProp = groupSum("groupAgg");
      } else if (aggregation === "mean") {
        aggProp = groupAverage("groupAgg");
      }
      if (areaPlot) {
        aggProp = area("groupAgg", aggProp);
      }
      props.push(valueProperty(yKey, yScaleType, { invalidValue: void 0 }), aggProp);
    } else {
      let aggProp = groupCount("groupAgg");
      if (areaPlot) {
        aggProp = area("groupAgg", aggProp);
      }
      props.push(aggProp);
    }
    const groupByFn = (dataSet) => {
      const xExtent = fixNumericExtent(dataSet.domain.keys[0]);
      if (xExtent.length === 0) {
        dataSet.domain.groups = [];
        return () => [];
      }
      const bins = isNumber(this.properties.binCount) ? this.calculateNiceBins(xExtent, this.properties.binCount) : this.properties.bins ?? this.deriveBins(xExtent);
      const binCount = bins.length;
      this.calculatedBins = [...bins];
      return (item) => {
        const xValue = item.keys[0];
        for (let i = 0; i < binCount; i++) {
          const nextBin = bins[i];
          if (xValue >= nextBin[0] && xValue < nextBin[1]) {
            return nextBin;
          }
          if (i === binCount - 1 && xValue <= nextBin[1]) {
            return nextBin;
          }
        }
        return [];
      };
    };
    if (!this.ctx.animationManager.isSkipped() && this.processedData) {
      props.push(diff(this.processedData, false));
    }
    await this.requestDataModel(dataController, this.data, { props, groupByFn });
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!processedData || !dataModel || !this.calculatedBins.length)
      return [];
    const yDomain = dataModel.getDomain(this, `groupAgg`, "aggregate", processedData);
    const xDomainMin = this.calculatedBins?.[0][0];
    const xDomainMax = this.calculatedBins?.[(this.calculatedBins?.length ?? 0) - 1][1];
    if (direction === "x" /* X */) {
      return fixNumericExtent([xDomainMin, xDomainMax]);
    }
    return fixNumericExtent(yDomain);
  }
  async createNodeData() {
    const {
      id: seriesId,
      axes,
      processedData,
      ctx: { callbackCache }
    } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!xAxis || !yAxis) {
      return;
    }
    const { scale: xScale } = xAxis;
    const { scale: yScale } = yAxis;
    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius } = this.properties;
    const labelFormatter = this.properties.label.formatter ?? ((params) => String(params.value));
    const nodeData = [];
    const context = {
      itemId: this.properties.yKey ?? this.id,
      nodeData,
      labelData: nodeData,
      scales: this.calculateScaling(),
      animationValid: true,
      visible: this.visible
    };
    if (!this.visible || !processedData || processedData.type !== "grouped")
      return context;
    processedData.data.forEach((group) => {
      const {
        aggValues: [[negativeAgg, positiveAgg]] = [[0, 0]],
        datum,
        datum: { length: frequency },
        keys: domain,
        keys: [xDomainMin, xDomainMax]
      } = group;
      const xMinPx = xScale.convert(xDomainMin);
      const xMaxPx = xScale.convert(xDomainMax);
      const total = negativeAgg + positiveAgg;
      const yZeroPx = yScale.convert(0);
      const yMaxPx = yScale.convert(total);
      const w = Math.abs(xMaxPx - xMinPx);
      const h = Math.abs(yMaxPx - yZeroPx);
      const x = Math.min(xMinPx, xMaxPx);
      const y = Math.min(yZeroPx, yMaxPx);
      let selectionDatumLabel = void 0;
      if (total !== 0) {
        selectionDatumLabel = {
          x: x + w / 2,
          y: y + h / 2,
          text: callbackCache.call(labelFormatter, {
            value: total,
            datum,
            seriesId,
            xKey,
            yKey,
            xName,
            yName
          }) ?? String(total)
        };
      }
      const nodeMidPoint = {
        x: x + w / 2,
        y: y + h / 2
      };
      const yAxisReversed = yAxis.isReversed();
      nodeData.push({
        series: this,
        datum,
        // required by SeriesNodeDatum, but might not make sense here
        // since each selection is an aggregation of multiple data.
        aggregatedValue: total,
        frequency,
        domain,
        yKey,
        xKey,
        x,
        y,
        xValue: xMinPx,
        yValue: yMaxPx,
        width: w,
        height: h,
        midPoint: nodeMidPoint,
        fill,
        stroke,
        cornerRadius,
        topLeftCornerRadius: !yAxisReversed,
        topRightCornerRadius: !yAxisReversed,
        bottomRightCornerRadius: yAxisReversed,
        bottomLeftCornerRadius: yAxisReversed,
        opacity: 1,
        strokeWidth,
        label: selectionDatumLabel
      });
    });
    nodeData.sort((a, b) => a.x - b.x);
    return context;
  }
  nodeFactory() {
    return new Rect();
  }
  async updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    return datumSelection.update(
      nodeData,
      (rect) => {
        rect.crisp = true;
      },
      (datum) => datum.domain.join("_")
    );
  }
  async updateDatumNodes(opts) {
    const { isHighlight: isDatumHighlighted } = opts;
    const {
      fillOpacity: seriesFillOpacity,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      shadow,
      highlightStyle: {
        item: {
          fill: highlightedFill,
          fillOpacity: highlightFillOpacity = seriesFillOpacity,
          stroke: highlightedStroke,
          strokeWidth: highlightedDatumStrokeWidth
        }
      }
    } = this.properties;
    opts.datumSelection.each((rect, datum, index) => {
      const {
        cornerRadius,
        topLeftCornerRadius,
        topRightCornerRadius,
        bottomRightCornerRadius,
        bottomLeftCornerRadius
      } = datum;
      const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== void 0 ? highlightedDatumStrokeWidth : datum.strokeWidth;
      const fillOpacity = isDatumHighlighted ? highlightFillOpacity : seriesFillOpacity;
      rect.fill = (isDatumHighlighted ? highlightedFill : void 0) ?? datum.fill;
      rect.stroke = (isDatumHighlighted ? highlightedStroke : void 0) ?? datum.stroke;
      rect.fillOpacity = fillOpacity;
      rect.strokeOpacity = strokeOpacity;
      rect.strokeWidth = strokeWidth;
      rect.lineDash = lineDash;
      rect.lineDashOffset = lineDashOffset;
      rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;
      rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;
      rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;
      rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;
      rect.fillShadow = shadow;
      rect.zIndex = isDatumHighlighted ? Series.highlightedZIndex : index;
      rect.visible = datum.height > 0;
    });
  }
  async updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData, (text) => {
      text.pointerEvents = 1 /* None */;
      text.textAlign = "center";
      text.textBaseline = "middle";
    });
  }
  async updateLabelNodes(opts) {
    const { fontStyle, fontWeight, fontFamily, fontSize, color } = this.properties.label;
    const labelEnabled = this.isLabelEnabled();
    opts.labelSelection.each((text, datum) => {
      if (labelEnabled && datum?.label) {
        text.text = datum.label.text;
        text.x = datum.label.x;
        text.y = datum.label.y;
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontFamily = fontFamily;
        text.fontSize = fontSize;
        text.fill = color;
        text.visible = true;
      } else {
        text.visible = false;
      }
    });
  }
  initQuadTree(quadtree) {
    const { value: childNode } = this.contentGroup.children().next();
    if (childNode) {
      addHitTestersToQuadtree(quadtree, childNode.children());
    }
  }
  pickNodeClosestDatum(point) {
    return findQuadtreeMatch(this, point);
  }
  getTooltipHtml(nodeDatum) {
    const xAxis = this.axes["x" /* X */];
    const yAxis = this.axes["y" /* Y */];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return EMPTY_TOOLTIP_CONTENT;
    }
    const { xKey, yKey, xName, yName, fill: color, aggregation, tooltip } = this.properties;
    const {
      aggregatedValue,
      frequency,
      domain: [rangeMin, rangeMax],
      itemId
    } = nodeDatum;
    const title = `${sanitizeHtml(xName ?? xKey)}: ${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`;
    let content = yKey ? `<b>${sanitizeHtml(yName ?? yKey)} (${aggregation})</b>: ${yAxis.formatDatum(aggregatedValue)}<br>` : "";
    content += `<b>Frequency</b>: ${frequency}`;
    const defaults = {
      title,
      backgroundColor: color,
      content
    };
    return tooltip.toTooltipHtml(defaults, {
      datum: {
        data: nodeDatum.datum,
        aggregatedValue: nodeDatum.aggregatedValue,
        domain: nodeDatum.domain,
        frequency: nodeDatum.frequency
      },
      itemId,
      xKey,
      xName,
      yKey,
      yName,
      color,
      title,
      seriesId: this.id
    });
  }
  getLegendData(legendType) {
    if (!this.data?.length || legendType !== "category") {
      return [];
    }
    const { xKey, yName, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, visible } = this.properties;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: xKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: yName ?? xKey ?? "Frequency"
        },
        symbols: [
          {
            marker: {
              fill: fill ?? "rgba(0, 0, 0, 0)",
              stroke: stroke ?? "rgba(0, 0, 0, 0)",
              fillOpacity,
              strokeOpacity,
              strokeWidth
            }
          }
        ]
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection }) {
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, "normal"));
    fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateWaitingUpdateReady(data) {
    const dataDiff = this.processedData?.reduced?.diff;
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, "normal"));
    fromToMotion(
      this.id,
      "datums",
      this.ctx.animationManager,
      [data.datumSelection],
      fns,
      (_, datum) => createDatumId(datum.domain),
      dataDiff
    );
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, data.labelSelection);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  computeFocusBounds({ datumIndex, seriesRect }) {
    return computeBarFocusBounds(this.contextNodeData?.nodeData[datumIndex], this.contentGroup, seriesRect);
  }
};
HistogramSeries.className = "HistogramSeries";
HistogramSeries.type = "histogram";

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts
var HistogramSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "histogram",
  moduleFactory: (ctx) => new HistogramSeries(ctx),
  tooltipDefaults: { range: "exact" },
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "bottom" /* BOTTOM */
    },
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    }
  ],
  themeTemplate: {
    series: {
      strokeWidth: 1,
      fillOpacity: 1,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      label: {
        enabled: false,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR
      },
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      }
    }
  },
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return { fill, stroke };
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts
var LineSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.stroke = "#874349";
    this.strokeWidth = 2;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.interpolation = new InterpolationProperties();
    this.marker = new SeriesMarker();
    this.label = new Label();
    this.tooltip = new SeriesTooltip();
    this.connectMissingData = false;
  }
};
__decorateClass([
  Validate(STRING)
], LineSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate(STRING)
], LineSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], LineSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], LineSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], LineSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], LineSeriesProperties.prototype, "stackGroup", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], LineSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], LineSeriesProperties.prototype, "title", 2);
__decorateClass([
  Validate(COLOR_STRING)
], LineSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LineSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO)
], LineSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH)
], LineSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LineSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate(OBJECT)
], LineSeriesProperties.prototype, "interpolation", 2);
__decorateClass([
  Validate(OBJECT)
], LineSeriesProperties.prototype, "marker", 2);
__decorateClass([
  Validate(OBJECT)
], LineSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], LineSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Validate(BOOLEAN)
], LineSeriesProperties.prototype, "connectMissingData", 2);

// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts
var CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR = 0.25;
var LineSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      hasMarkers: true,
      pickModes: [
        2 /* AXIS_ALIGNED */,
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      markerSelectionGarbageCollection: false,
      animationResetFns: {
        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),
        label: resetLabelFn,
        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })
      }
    });
    this.properties = new LineSeriesProperties();
  }
  get pickModeAxis() {
    return "main-category";
  }
  async processData(dataController) {
    if (this.data == null || !this.properties.isValid()) {
      return;
    }
    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;
    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const common = { invalidValue: null };
    if (connectMissingData && stackCount > 1) {
      common.invalidValue = 0;
    }
    if (!visible) {
      common.forceValue = 0;
    }
    const props = [];
    if (!isContinuousX) {
      props.push(keyProperty(xKey, xScaleType, { id: "xKey" }));
    }
    props.push(
      valueProperty(xKey, xScaleType, { id: "xValue" }),
      valueProperty(yKey, yScaleType, {
        id: `yValueRaw`,
        ...common,
        invalidValue: void 0
      })
    );
    if (yFilterKey != null) {
      props.push(valueProperty(yFilterKey, yScaleType, { id: "yFilterRaw" }));
    }
    if (stackCount > 1) {
      const ids = [
        `line-stack-${groupIndex}-yValues`,
        `line-stack-${groupIndex}-yValues-trailing`,
        `line-stack-${groupIndex}-yValues-marker`
      ];
      props.push(
        ...groupAccumulativeValueProperty(
          yKey,
          "window",
          "current",
          { id: `yValueEnd`, ...common, groupId: ids[0] },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "window-trailing",
          "current",
          { id: `yValueStart`, ...common, groupId: ids[1] },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "normal",
          "current",
          { id: `yValueCumulative`, ...common, groupId: ids[2] },
          yScaleType
        )
      );
      if (isDefined(normalizedTo)) {
        props.push(normaliseGroupTo([ids[0], ids[1], ids[2]], normalizedTo, "range"));
      }
    }
    if (animationEnabled) {
      props.push(animationValidation(isContinuousX ? ["xValue"] : void 0));
      if (this.processedData) {
        props.push(diff(this.processedData));
      }
    }
    await this.requestDataModel(dataController, data, { props });
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData?.data.length)
      return [];
    const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
    if (direction === "x" /* X */) {
      const domain = dataModel.getDomain(this, `xValue`, "value", processedData);
      if (xDef?.def.type === "value" && xDef.def.valueType === "category") {
        return domain;
      }
      return fixNumericExtent(extent(domain));
    } else {
      const stackCount = this.seriesGrouping?.stackCount ?? 1;
      const domain = stackCount > 1 ? dataModel.getDomain(this, `yValueEnd`, "value", processedData) : dataModel.getDomain(this, `yValueRaw`, "value", processedData);
      return fixNumericExtent(domain);
    }
  }
  async createNodeData() {
    const { processedData, dataModel, axes } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!processedData || !dataModel || !xAxis || !yAxis) {
      return;
    }
    const { xKey, yKey, yFilterKey, xName, yName, marker, label, connectMissingData, legendItemName } = this.properties;
    const stacked = (this.seriesGrouping?.stackCount ?? 1) > 1;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const yOffset = (yScale.bandwidth ?? 0) / 2;
    const nodeData = [];
    const size = marker.enabled ? marker.size : 0;
    const xIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);
    const yIdx = dataModel.resolveProcessedDataIndexById(this, `yValueRaw`);
    const ySelectionIdx = yFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `yFilterRaw`) : void 0;
    const yCumulativeIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueCumulative`) : yIdx;
    const yEndIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueEnd`) : void 0;
    let moveTo = true;
    let crossFiltering = false;
    processedData.data?.forEach(({ datum, values }) => {
      const xDatum = values[xIdx];
      const yDatum = values[yIdx];
      const yCumulativeDatum = values[yCumulativeIdx];
      const yEndDatum = yEndIdx != null ? values[yEndIdx] : void 0;
      if (yDatum == null) {
        moveTo || (moveTo = !connectMissingData);
        return;
      }
      const x = xScale.convert(xDatum) + xOffset;
      if (isNaN(x)) {
        moveTo || (moveTo = !connectMissingData);
        return;
      }
      const y = yScale.convert(yCumulativeDatum) + yOffset;
      const selected = ySelectionIdx != null ? values[ySelectionIdx] === yDatum : void 0;
      if (selected === false) {
        crossFiltering = true;
      }
      const labelText = this.getLabelText(
        label,
        { value: yDatum, datum, xKey, yKey, xName, yName, legendItemName },
        formatValue
      );
      nodeData.push({
        series: this,
        datum,
        yKey,
        xKey,
        point: { x, y, moveTo, size },
        midPoint: { x, y },
        cumulativeValue: yEndDatum,
        yValue: yDatum,
        xValue: xDatum,
        capDefaults: {
          lengthRatioMultiplier: this.properties.marker.getDiameter(),
          lengthMax: Infinity
        },
        labelText,
        selected
      });
      moveTo = false;
    });
    return {
      itemId: yKey,
      nodeData,
      labelData: nodeData,
      scales: this.calculateScaling(),
      visible: this.visible,
      crossFiltering
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  markerFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker(shape);
    return new MarkerShape();
  }
  async updatePathNodes(opts) {
    const {
      paths: [lineNode],
      opacity,
      visible,
      animationEnabled
    } = opts;
    const crossFiltering = this.contextNodeData?.crossFiltering === true;
    lineNode.setProperties({
      fill: void 0,
      lineJoin: "round",
      pointerEvents: 1 /* None */,
      opacity,
      stroke: this.properties.stroke,
      strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),
      strokeOpacity: this.properties.strokeOpacity * (crossFiltering ? CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR : 1),
      lineDash: this.properties.lineDash,
      lineDashOffset: this.properties.lineDashOffset
    });
    if (!animationEnabled) {
      lineNode.visible = visible;
    }
    updateClipPath(this, lineNode);
  }
  async updateMarkerSelection(opts) {
    let { nodeData } = opts;
    const { markerSelection } = opts;
    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;
    nodeData = markersEnabled ? nodeData : [];
    if (this.properties.marker.isDirty()) {
      markerSelection.clear();
      markerSelection.cleanup();
    }
    return markerSelection.update(nodeData, void 0, (datum) => createDatumId(datum.xValue));
  }
  async updateMarkerNodes(opts) {
    const { markerSelection, isHighlight: highlighted } = opts;
    const { xKey, yKey, stroke, strokeWidth, strokeOpacity, marker, highlightStyle } = this.properties;
    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {
      stroke,
      strokeWidth,
      strokeOpacity
    });
    const applyTranslation = this.ctx.animationManager.isSkipped();
    markerSelection.each((node, datum) => {
      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, {
        applyTranslation,
        selected: datum.selected
      });
    });
    if (!highlighted) {
      marker.markClean();
    }
  }
  async updateLabelSelection(opts) {
    return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);
  }
  async updateLabelNodes(opts) {
    const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;
    opts.labelSelection.each((text, datum) => {
      if (enabled && datum?.labelText) {
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontSize = fontSize;
        text.fontFamily = fontFamily;
        text.textAlign = "center";
        text.textBaseline = "bottom";
        text.text = datum.labelText;
        text.x = datum.point.x;
        text.y = datum.point.y - 10;
        text.fill = color;
        text.visible = true;
      } else {
        text.visible = false;
      }
    });
  }
  getTooltipHtml(nodeDatum) {
    const xAxis = this.axes["x" /* X */];
    const yAxis = this.axes["y" /* Y */];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return EMPTY_TOOLTIP_CONTENT;
    }
    const { xKey, yKey, xName, yName, strokeWidth, marker, tooltip } = this.properties;
    const { datum, xValue, yValue, itemId } = nodeDatum;
    const xString = xAxis.formatDatum(xValue);
    const yString = yAxis.formatDatum(yValue);
    const title = sanitizeHtml(this.properties.title ?? yName);
    const content = sanitizeHtml(xString + ": " + yString);
    const baseStyle = mergeDefaults({ fill: marker.stroke }, marker.getStyle(), { strokeWidth });
    const { fill: color } = this.getMarkerStyle(
      marker,
      { datum: nodeDatum, xKey, yKey, highlighted: false },
      baseStyle
    );
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        datum,
        itemId,
        xKey,
        xName,
        yKey,
        yName,
        title,
        color,
        seriesId: this.id,
        ...this.getModuleTooltipParams()
      }
    );
  }
  getLegendData(legendType) {
    if (!(this.data?.length && this.properties.isValid() && legendType === "category")) {
      return [];
    }
    const { yKey, yName, stroke, strokeOpacity, strokeWidth, lineDash, title, marker, visible, legendItemName } = this.properties;
    const color0 = "rgba(0, 0, 0, 0)";
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: yKey,
        legendItemName,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: legendItemName ?? title ?? yName ?? yKey
        },
        symbols: [
          {
            marker: {
              shape: marker.shape,
              fill: marker.fill ?? color0,
              stroke: marker.stroke ?? stroke ?? color0,
              fillOpacity: marker.fillOpacity ?? 1,
              strokeOpacity: marker.strokeOpacity ?? strokeOpacity ?? 1,
              strokeWidth: marker.strokeWidth ?? 0,
              enabled: marker.enabled
            },
            line: {
              stroke: stroke ?? color0,
              strokeOpacity,
              strokeWidth,
              lineDash
            }
          }
        ]
      }
    ];
  }
  async updatePaths(opts) {
    this.updateLinePaths(opts.paths, opts.contextData);
  }
  updateLinePaths(paths, contextData) {
    const { interpolation } = this.properties;
    const { nodeData } = contextData;
    const [lineNode] = paths;
    lineNode.path.clear(true);
    for (const range3 of pathRanges(nodeData)) {
      plotPath(pathRangePoints(nodeData, range3), lineNode, interpolation);
    }
    lineNode.checkPathDirty();
  }
  animateEmptyUpdateReady(animationData) {
    const { markerSelection, labelSelection, annotationSelections, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateLinePaths(paths, contextData);
    pathSwipeInAnimation(this, animationManager, ...paths);
    resetMotion([markerSelection], resetMarkerPositionFn);
    markerSwipeScaleInAnimation(this, animationManager, markerSelection);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
    seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateLinePaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    const { animationManager } = this.ctx;
    const {
      markerSelection: markerSelections,
      labelSelection: labelSelections,
      annotationSelections,
      contextData,
      paths,
      previousContextData
    } = animationData;
    const [path] = paths;
    this.resetMarkerAnimation(animationData);
    this.resetLabelAnimation(animationData);
    const update = () => {
      this.resetPathAnimation(animationData);
      this.updateLinePaths(paths, contextData);
    };
    const skip = () => {
      animationManager.skipCurrentBatch();
      update();
    };
    if (contextData == null || previousContextData == null) {
      update();
      markerFadeInAnimation(this, animationManager, "added", markerSelections);
      pathFadeInAnimation(this, "path_properties", animationManager, "add", path);
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
      seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
      return;
    }
    if (contextData.crossFiltering !== previousContextData.crossFiltering) {
      skip();
      return;
    }
    let fns;
    try {
      fns = prepareLinePathAnimation(
        contextData,
        previousContextData,
        this.processedData?.reduced?.diff,
        this.properties.interpolation
      );
    } catch {
      fns = void 0;
    }
    if (fns === void 0) {
      skip();
      return;
    } else if (fns.status === "no-op") {
      return;
    }
    markerFadeInAnimation(this, animationManager, void 0, markerSelections);
    fromToMotion(this.id, "path_properties", animationManager, [path], fns.pathProperties);
    if (fns.status === "added") {
      this.updateLinePaths(paths, contextData);
    } else if (fns.status === "removed") {
      this.updateLinePaths(paths, previousContextData);
    } else {
      pathMotion(this.id, "path_update", animationManager, [path], fns.path);
    }
    if (fns.hasMotion) {
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
      seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
    }
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  getBandScalePadding() {
    return { inner: 1, outer: 0.1 };
  }
  nodeFactory() {
    return new Group();
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yKey } = this.properties;
    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
};
LineSeries.className = "LineSeries";
LineSeries.type = "line";

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts
var LineSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "line",
  moduleFactory: (ctx) => new LineSeries(ctx),
  stackable: true,
  tooltipDefaults: { range: "nearest" },
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    },
    {
      type: "category" /* CATEGORY */,
      position: "bottom" /* BOTTOM */
    }
  ],
  themeTemplate: {
    series: {
      tooltip: { position: { type: "node" } },
      strokeWidth: 2,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      interpolation: {
        type: "linear",
        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work
        tension: 1,
        position: "end"
      },
      marker: {
        shape: "circle",
        size: 7,
        strokeWidth: 0
      },
      label: {
        enabled: false,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_LABEL_COLOUR
      },
      errorBar: {
        cap: {
          lengthRatio: 1
        }
      }
    }
  },
  paletteFactory: (params) => {
    const { marker } = markerPaletteFactory(params);
    return { stroke: marker.fill, marker };
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesProperties.ts
var ScatterSeriesLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.placement = "top";
  }
};
__decorateClass([
  Validate(LABEL_PLACEMENT)
], ScatterSeriesLabel.prototype, "placement", 2);
var ScatterSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.colorRange = ["#ffff00", "#00ff00", "#0000ff"];
    this.label = new ScatterSeriesLabel();
    this.tooltip = new SeriesTooltip();
    // No validation. Not a part of the options contract.
    this.marker = new SeriesMarker();
  }
};
__decorateClass([
  Validate(STRING)
], ScatterSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate(STRING)
], ScatterSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "colorKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "xFilterKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "labelName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "colorName", 2);
__decorateClass([
  Validate(NUMBER_ARRAY, { optional: true })
], ScatterSeriesProperties.prototype, "colorDomain", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], ScatterSeriesProperties.prototype, "colorRange", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "title", 2);
__decorateClass([
  ProxyProperty("marker.shape")
], ScatterSeriesProperties.prototype, "shape", 2);
__decorateClass([
  ProxyProperty("marker.size")
], ScatterSeriesProperties.prototype, "size", 2);
__decorateClass([
  ProxyProperty("marker.fill")
], ScatterSeriesProperties.prototype, "fill", 2);
__decorateClass([
  ProxyProperty("marker.fillOpacity")
], ScatterSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  ProxyProperty("marker.stroke")
], ScatterSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  ProxyProperty("marker.strokeWidth")
], ScatterSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  ProxyProperty("marker.strokeOpacity")
], ScatterSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  ProxyProperty("marker.itemStyler", { optional: true })
], ScatterSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate(OBJECT)
], ScatterSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], ScatterSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts
var ScatterSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      pickModes: [
        2 /* AXIS_ALIGNED */,
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      pathsPerSeries: [],
      hasMarkers: true,
      markerSelectionGarbageCollection: false,
      animationResetFns: {
        marker: resetMarkerFn,
        label: resetLabelFn
      }
    });
    this.properties = new ScatterSeriesProperties();
    this.colorScale = new ColorScale();
  }
  get pickModeAxis() {
    return "main-category";
  }
  async processData(dataController) {
    if (!this.properties.isValid() || this.data == null || !this.visible)
      return;
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const colorScaleType = this.colorScale.type;
    const { xKey, yKey, xFilterKey, yFilterKey, labelKey, colorKey, colorDomain, colorRange } = this.properties;
    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        valueProperty(xKey, xScaleType, { id: `xValue` }),
        valueProperty(yKey, yScaleType, { id: `yValue` }),
        ...xFilterKey != null ? [valueProperty(xFilterKey, xScaleType, { id: "xFilterValue" })] : [],
        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: "yFilterValue" })] : [],
        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],
        ...labelKey ? [valueProperty(labelKey, "band", { id: `labelValue` })] : []
      ]
    });
    if (colorKey) {
      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);
      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];
      this.colorScale.range = colorRange;
      this.colorScale.update();
    }
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    const id = direction === "x" /* X */ ? `xValue` : `yValue`;
    const dataDef = dataModel.resolveProcessedDataDefById(this, id);
    const domain = dataModel.getDomain(this, id, "value", processedData);
    if (dataDef?.def.type === "value" && dataDef?.def.valueType === "category") {
      return domain;
    }
    return fixNumericExtent(extent(domain));
  }
  async createNodeData() {
    const { axes, dataModel, processedData, colorScale } = this;
    const {
      xKey,
      yKey,
      xFilterKey,
      yFilterKey,
      labelKey,
      colorKey,
      xName,
      yName,
      labelName,
      marker,
      label,
      visible
    } = this.properties;
    const { placement } = label;
    const markerShape = getMarker(marker.shape);
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!(dataModel && processedData && visible && xAxis && yAxis)) {
      return;
    }
    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);
    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);
    const colorDataIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;
    const labelDataIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;
    const xFilterDataIdx = xFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `xFilterValue`) : void 0;
    const yFilterDataIdx = yFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `yFilterValue`) : void 0;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const yOffset = (yScale.bandwidth ?? 0) / 2;
    const nodeData = [];
    const font = label.getFont();
    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });
    for (const { values, datum } of processedData.data ?? []) {
      const xDatum = values[xDataIdx];
      const yDatum = values[yDataIdx];
      const x = xScale.convert(xDatum) + xOffset;
      const y = yScale.convert(yDatum) + yOffset;
      const selected = xFilterDataIdx != null && yFilterDataIdx != null ? values[xFilterDataIdx] === xDatum && values[yFilterDataIdx] === yDatum : void 0;
      const labelText = this.getLabelText(label, {
        value: labelKey ? values[labelDataIdx] : yDatum,
        datum,
        xKey,
        yKey,
        labelKey,
        xName,
        yName,
        labelName
      });
      const size = textMeasurer.measureText(labelText);
      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;
      nodeData.push({
        series: this,
        itemId: yKey,
        yKey,
        xKey,
        datum,
        xValue: xDatum,
        yValue: yDatum,
        capDefaults: { lengthRatioMultiplier: marker.getDiameter(), lengthMax: Infinity },
        point: { x, y, size: marker.size },
        midPoint: { x, y },
        fill,
        label: { text: labelText, ...size },
        marker: markerShape,
        placement,
        selected
      });
    }
    return {
      itemId: yKey,
      nodeData,
      labelData: nodeData,
      scales: this.calculateScaling(),
      visible: this.visible
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  getLabelData() {
    return this.contextNodeData?.labelData ?? [];
  }
  markerFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker(shape);
    return new MarkerShape();
  }
  async updateMarkerSelection(opts) {
    const { nodeData, markerSelection } = opts;
    if (this.properties.marker.isDirty()) {
      markerSelection.clear();
      markerSelection.cleanup();
    }
    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);
  }
  async updateMarkerNodes(opts) {
    const { markerSelection, isHighlight: highlighted } = opts;
    const { xKey, yKey, labelKey, marker, highlightStyle } = this.properties;
    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle());
    markerSelection.each((node, datum) => {
      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, labelKey }, baseStyle, {
        selected: datum.selected
      });
    });
    if (!highlighted) {
      marker.markClean();
    }
  }
  async updateLabelSelection(opts) {
    const placedLabels = this.isLabelEnabled() ? this.chart?.placeLabels().get(this) ?? [] : [];
    return opts.labelSelection.update(
      placedLabels.map(({ datum, x, y }) => ({
        ...datum,
        point: { x, y, size: datum.point.size },
        placement: "top"
      })),
      (text) => {
        text.pointerEvents = 1 /* None */;
      }
    );
  }
  async updateLabelNodes(opts) {
    const { label } = this.properties;
    opts.labelSelection.each((text, datum) => {
      text.text = datum.label.text;
      text.fill = label.color;
      text.x = datum.point?.x ?? 0;
      text.y = datum.point?.y ?? 0;
      text.fontStyle = label.fontStyle;
      text.fontWeight = label.fontWeight;
      text.fontSize = label.fontSize;
      text.fontFamily = label.fontFamily;
      text.textAlign = "left";
      text.textBaseline = "top";
    });
  }
  getTooltipHtml(nodeDatum) {
    const xAxis = this.axes["x" /* X */];
    const yAxis = this.axes["y" /* Y */];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return EMPTY_TOOLTIP_CONTENT;
    }
    const { xKey, yKey, labelKey, xName, yName, labelName, title = yName, marker, tooltip } = this.properties;
    const { datum, xValue, yValue, label, itemId } = nodeDatum;
    const baseStyle = mergeDefaults(
      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },
      marker.getStyle()
    );
    const { fill: color = "gray" } = this.getMarkerStyle(
      marker,
      { datum: nodeDatum, highlighted: false, xKey, yKey, labelKey },
      baseStyle
    );
    const xString = sanitizeHtml(xAxis.formatDatum(xValue));
    const yString = sanitizeHtml(yAxis.formatDatum(yValue));
    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;
    if (labelKey) {
      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(label.text)}<br>` + content;
    }
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        datum,
        itemId,
        xKey,
        xName,
        yKey,
        yName,
        labelKey,
        labelName,
        title,
        color,
        seriesId: this.id,
        ...this.getModuleTooltipParams()
      }
    );
  }
  getLegendData(legendType) {
    const { yKey, yName, title, marker, visible } = this.properties;
    const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;
    if (!this.data?.length || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: yKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: title ?? yName ?? yKey
        },
        symbols: [
          {
            marker: {
              shape: marker.shape,
              fill: marker.fill ?? fill ?? "rgba(0, 0, 0, 0)",
              stroke: marker.stroke ?? stroke ?? "rgba(0, 0, 0, 0)",
              fillOpacity: fillOpacity ?? 1,
              strokeOpacity: strokeOpacity ?? 1,
              strokeWidth: strokeWidth ?? 0
            }
          }
        ]
      }
    ];
  }
  animateEmptyUpdateReady(data) {
    const { markerSelection, labelSelection, annotationSelections } = data;
    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
    seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  nodeFactory() {
    return new Group();
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yKey, labelKey } = this.properties;
    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, labelKey, highlighted: true });
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
};
ScatterSeries.className = "ScatterSeries";
ScatterSeries.type = "scatter";

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts
var ScatterSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "scatter",
  moduleFactory: (ctx) => new ScatterSeries(ctx),
  tooltipDefaults: { range: "nearest" },
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "bottom" /* BOTTOM */
    },
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    }
  ],
  themeTemplate: {
    series: {
      shape: "circle",
      size: 7,
      fillOpacity: 0.8,
      tooltip: { position: { type: "node" } },
      label: {
        enabled: false,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_LABEL_COLOUR
      },
      errorBar: {
        cap: {
          lengthRatio: 1
        }
      }
    }
  },
  paletteFactory: singleSeriesPaletteFactory
};

// packages/ag-charts-community/src/scene/sectorBox.ts
var SectorBox = class _SectorBox {
  constructor(startAngle, endAngle, innerRadius, outerRadius) {
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.innerRadius = innerRadius;
    this.outerRadius = outerRadius;
  }
  clone() {
    const { startAngle, endAngle, innerRadius, outerRadius } = this;
    return new _SectorBox(startAngle, endAngle, innerRadius, outerRadius);
  }
  equals(other) {
    return this.startAngle === other.startAngle && this.endAngle === other.endAngle && this.innerRadius === other.innerRadius && this.outerRadius === other.outerRadius;
  }
  [interpolate](other, d) {
    return new _SectorBox(
      this.startAngle * (1 - d) + other.startAngle * d,
      this.endAngle * (1 - d) + other.endAngle * d,
      this.innerRadius * (1 - d) + other.innerRadius * d,
      this.outerRadius * (1 - d) + other.outerRadius * d
    );
  }
};

// packages/ag-charts-community/src/scene/util/sector.ts
function sectorBox({ startAngle, endAngle, innerRadius, outerRadius }) {
  let x0 = Infinity;
  let y0 = Infinity;
  let x1 = -Infinity;
  let y1 = -Infinity;
  const addPoint = (x, y) => {
    x0 = Math.min(x, x0);
    y0 = Math.min(y, y0);
    x1 = Math.max(x, x1);
    y1 = Math.max(y, y1);
  };
  addPoint(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));
  addPoint(innerRadius * Math.cos(endAngle), innerRadius * Math.sin(endAngle));
  addPoint(outerRadius * Math.cos(startAngle), outerRadius * Math.sin(startAngle));
  addPoint(outerRadius * Math.cos(endAngle), outerRadius * Math.sin(endAngle));
  if (isBetweenAngles(0, startAngle, endAngle)) {
    addPoint(outerRadius, 0);
  }
  if (isBetweenAngles(Math.PI * 0.5, startAngle, endAngle)) {
    addPoint(0, outerRadius);
  }
  if (isBetweenAngles(Math.PI, startAngle, endAngle)) {
    addPoint(-outerRadius, 0);
  }
  if (isBetweenAngles(Math.PI * 1.5, startAngle, endAngle)) {
    addPoint(0, -outerRadius);
  }
  return new BBox(x0, y0, x1 - x0, y1 - y0);
}
function isPointInSector(x, y, sector) {
  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  const { innerRadius, outerRadius } = sector;
  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {
    return false;
  }
  const startAngle = normalizeAngle180(sector.startAngle);
  const endAngle = normalizeAngle180(sector.endAngle);
  const angle2 = Math.atan2(y, x);
  return startAngle < endAngle ? angle2 <= endAngle && angle2 >= startAngle : angle2 <= endAngle && angle2 >= -Math.PI || angle2 >= startAngle && angle2 <= Math.PI;
}
function lineCollidesSector(line, sector) {
  const { startAngle, endAngle, innerRadius, outerRadius } = sector;
  const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };
  const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };
  const innerStart = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };
  const innerEnd = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };
  return segmentIntersection(
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y,
    outerStart.x,
    outerStart.y,
    innerStart.x,
    innerStart.y
  ) || segmentIntersection(
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y,
    outerEnd.x,
    outerEnd.y,
    innerEnd.x,
    innerEnd.y
  ) || arcIntersections(
    0,
    0,
    outerRadius,
    startAngle,
    endAngle,
    true,
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y
  );
}
function boxCollidesSector(box, sector) {
  const topLeft = { x: box.x, y: box.y };
  const topRight = { x: box.x + box.width, y: box.y };
  const bottomLeft = { x: box.x, y: box.y + box.height };
  const bottomRight = { x: box.x + box.width, y: box.y + box.height };
  return lineCollidesSector({ start: topLeft, end: topRight }, sector) || lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector);
}
function radiiScalingFactor(r, sweep, a, b) {
  if (a === 0 && b === 0)
    return 0;
  const fs1 = Math.asin(Math.abs(1 * a) / (r + 1 * a)) + Math.asin(Math.abs(1 * b) / (r + 1 * b)) - sweep;
  if (fs1 < 0)
    return 1;
  let start = 0;
  let end = 1;
  for (let i = 0; i < 8; i += 1) {
    const s = (start + end) / 2;
    const fs = Math.asin(Math.abs(s * a) / (r + s * a)) + Math.asin(Math.abs(s * b) / (r + s * b)) - sweep;
    if (fs < 0) {
      start = s;
    } else {
      end = s;
    }
  }
  return start;
}
var delta2 = 1e-6;
function clockwiseAngle(angle2, relativeToStartAngle) {
  if (angleBetween(angle2, relativeToStartAngle) < delta2) {
    return relativeToStartAngle;
  } else {
    return normalizeAngle360(angle2 - relativeToStartAngle) + relativeToStartAngle;
  }
}
function clockwiseAngles(startAngle, endAngle, relativeToStartAngle = 0) {
  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;
  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);
  startAngle = clockwiseAngle(startAngle, relativeToStartAngle);
  endAngle = startAngle + sweepAngle;
  return { startAngle, endAngle };
}
function arcRadialLineIntersectionAngle(cx, cy, r, startAngle, endAngle, clipAngle) {
  const sinA = Math.sin(clipAngle);
  const cosA = Math.cos(clipAngle);
  const c = cx ** 2 + cy ** 2 - r ** 2;
  let p0x = NaN;
  let p0y = NaN;
  let p1x = NaN;
  let p1y = NaN;
  if (cosA > 0.5) {
    const tanA = sinA / cosA;
    const a = 1 + tanA ** 2;
    const b = -2 * (cx + cy * tanA);
    const d = b ** 2 - 4 * a * c;
    if (d < 0)
      return;
    const x0 = (-b + Math.sqrt(d)) / (2 * a);
    const x1 = (-b - Math.sqrt(d)) / (2 * a);
    p0x = x0;
    p0y = x0 * tanA;
    p1x = x1;
    p1y = x1 * tanA;
  } else {
    const cotA = cosA / sinA;
    const a = 1 + cotA ** 2;
    const b = -2 * (cy + cx * cotA);
    const d = b ** 2 - 4 * a * c;
    if (d < 0)
      return;
    const y0 = (-b + Math.sqrt(d)) / (2 * a);
    const y1 = (-b - Math.sqrt(d)) / (2 * a);
    p0x = y0 * cotA;
    p0y = y0;
    p1x = y1 * cotA;
    p1y = y1;
  }
  const normalisedX = cosA;
  const normalisedY = sinA;
  const p0DotNormalized = p0x * normalisedX + p0y * normalisedY;
  const p1DotNormalized = p1x * normalisedX + p1y * normalisedY;
  const a0 = p0DotNormalized > 0 ? clockwiseAngle(Math.atan2(p0y - cy, p0x - cx), startAngle) : NaN;
  const a1 = p1DotNormalized > 0 ? clockwiseAngle(Math.atan2(p1y - cy, p1x - cx), startAngle) : NaN;
  if (a0 >= startAngle && a0 <= endAngle) {
    return a0;
  } else if (a1 >= startAngle && a1 <= endAngle) {
    return a1;
  }
}
function arcCircleIntersectionAngle(cx, cy, r, startAngle, endAngle, circleR) {
  const d = Math.hypot(cx, cy);
  const d1 = (d ** 2 - r ** 2 + circleR ** 2) / (2 * d);
  const d2 = d - d1;
  const theta = Math.atan2(cy, cx);
  const deltaTheta = Math.acos(-d2 / r);
  const a0 = clockwiseAngle(theta + deltaTheta, startAngle);
  const a1 = clockwiseAngle(theta - deltaTheta, startAngle);
  if (a0 >= startAngle && a0 <= endAngle) {
    return a0;
  } else if (a1 >= startAngle && a1 <= endAngle) {
    return a1;
  }
}

// packages/ag-charts-community/src/scene/shape/sector.ts
var Arc = class {
  constructor(cx, cy, r, a0, a1) {
    this.cx = cx;
    this.cy = cy;
    this.r = r;
    this.a0 = a0;
    this.a1 = a1;
    if (this.a0 >= this.a1) {
      this.a0 = NaN;
      this.a1 = NaN;
    }
  }
  isValid() {
    return Number.isFinite(this.a0) && Number.isFinite(this.a1);
  }
  pointAt(a) {
    return {
      x: this.cx + this.r * Math.cos(a),
      y: this.cy + this.r * Math.sin(a)
    };
  }
  clipStart(a) {
    if (a == null || !this.isValid() || a < this.a0)
      return;
    this.a0 = a;
    if (Number.isNaN(a) || this.a0 >= this.a1) {
      this.a0 = NaN;
      this.a1 = NaN;
    }
  }
  clipEnd(a) {
    if (a == null || !this.isValid() || a > this.a1)
      return;
    this.a1 = a;
    if (Number.isNaN(a) || this.a0 >= this.a1) {
      this.a0 = NaN;
      this.a1 = NaN;
    }
  }
};
var Sector = class extends Path {
  constructor() {
    super(...arguments);
    this.centerX = 0;
    this.centerY = 0;
    this.innerRadius = 10;
    this.outerRadius = 20;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clipSector = void 0;
    this.concentricEdgeInset = 0;
    this.radialEdgeInset = 0;
    this.startOuterCornerRadius = 0;
    this.endOuterCornerRadius = 0;
    this.startInnerCornerRadius = 0;
    this.endInnerCornerRadius = 0;
  }
  set inset(value) {
    this.concentricEdgeInset = value;
    this.radialEdgeInset = value;
  }
  set cornerRadius(value) {
    this.startOuterCornerRadius = value;
    this.endOuterCornerRadius = value;
    this.startInnerCornerRadius = value;
    this.endInnerCornerRadius = value;
  }
  computeBBox() {
    return sectorBox(this).translate(this.centerX, this.centerY);
  }
  normalizedRadii() {
    const { concentricEdgeInset } = this;
    let { innerRadius, outerRadius } = this;
    innerRadius = innerRadius > 0 ? innerRadius + concentricEdgeInset : 0;
    outerRadius = Math.max(outerRadius - concentricEdgeInset, 0);
    return { innerRadius, outerRadius };
  }
  normalizedClipSector() {
    const { clipSector } = this;
    if (clipSector == null)
      return;
    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
    const { innerRadius, outerRadius } = this.normalizedRadii();
    const clipAngles = clockwiseAngles(clipSector.startAngle, clipSector.endAngle, startAngle);
    return new SectorBox(
      Math.max(startAngle, clipAngles.startAngle),
      Math.min(endAngle, clipAngles.endAngle),
      Math.max(innerRadius, clipSector.innerRadius),
      Math.min(outerRadius, clipSector.outerRadius)
    );
  }
  getAngleOffset(radius) {
    return radius > 0 ? this.radialEdgeInset / radius : 0;
  }
  arc(r, angleSweep, a0, a1, outerArc, innerArc, start, inner) {
    if (r <= 0)
      return;
    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
    const { innerRadius, outerRadius } = this.normalizedRadii();
    const clipSector = this.normalizedClipSector();
    if (inner && innerRadius <= 0)
      return;
    const angleOffset = inner ? this.getAngleOffset(innerRadius + r) : this.getAngleOffset(outerRadius - r);
    const angle2 = start ? startAngle + angleOffset + angleSweep : endAngle - angleOffset - angleSweep;
    const radius = inner ? innerRadius + r : outerRadius - r;
    const cx = radius * Math.cos(angle2);
    const cy = radius * Math.sin(angle2);
    if (clipSector != null) {
      const delta3 = 1e-6;
      if (!start && !(angle2 >= startAngle - delta3 && angle2 <= clipSector.endAngle - delta3))
        return;
      if (start && !(angle2 >= clipSector.startAngle + delta3 && angle2 <= endAngle - delta3))
        return;
      if (inner && radius < clipSector.innerRadius - delta3)
        return;
      if (!inner && radius > clipSector.outerRadius + delta3)
        return;
    }
    const arc = new Arc(cx, cy, r, a0, a1);
    if (clipSector != null) {
      if (inner) {
        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));
        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));
      } else {
        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));
        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));
      }
      let circleClipStart;
      let circleClipEnd;
      if (start) {
        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);
        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);
      } else {
        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);
        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);
      }
      arc.clipStart(circleClipStart);
      arc.clipEnd(circleClipEnd);
      if (circleClipStart != null) {
        const { x: x2, y: y2 } = arc.pointAt(circleClipStart);
        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);
        if (start) {
          innerArc?.clipStart(theta2);
        } else {
          outerArc.clipEnd(theta2);
        }
      }
      if (circleClipEnd != null) {
        const { x: x2, y: y2 } = arc.pointAt(circleClipEnd);
        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);
        if (start) {
          outerArc.clipStart(theta2);
        } else {
          innerArc?.clipEnd(theta2);
        }
      }
    }
    if (clipSector != null) {
      const { x: x2, y: y2 } = arc.pointAt((arc.a0 + arc.a1) / 2);
      if (!isPointInSector(x2, y2, clipSector))
        return;
    }
    const { x, y } = arc.pointAt(start === inner ? arc.a0 : arc.a1);
    const theta = clockwiseAngle(Math.atan2(y, x), startAngle);
    const radialArc = inner ? innerArc : outerArc;
    if (start) {
      radialArc?.clipStart(theta);
    } else {
      radialArc?.clipEnd(theta);
    }
    return arc;
  }
  updatePath() {
    const delta3 = 1e-6;
    const { path, centerX, centerY, concentricEdgeInset, radialEdgeInset } = this;
    let { startOuterCornerRadius, endOuterCornerRadius, startInnerCornerRadius, endInnerCornerRadius } = this;
    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
    const { innerRadius, outerRadius } = this.normalizedRadii();
    const clipSector = this.normalizedClipSector();
    const sweepAngle = endAngle - startAngle;
    const fullPie = sweepAngle >= 2 * Math.PI - delta3;
    path.clear();
    if (innerRadius === 0 && outerRadius === 0 || innerRadius > outerRadius) {
      return;
    } else if ((clipSector?.startAngle ?? startAngle) === (clipSector?.endAngle ?? endAngle)) {
      return;
    } else if (fullPie && this.clipSector == null && startOuterCornerRadius === 0 && endOuterCornerRadius === 0 && startInnerCornerRadius === 0 && endInnerCornerRadius === 0) {
      path.moveTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));
      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);
      if (innerRadius > concentricEdgeInset) {
        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));
        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
      }
      path.closePath();
      return;
    } else if (this.clipSector == null && Math.abs(innerRadius - outerRadius) < 1e-6) {
      path.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);
      path.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);
      path.closePath();
      return;
    }
    const innerAngleOffset = this.getAngleOffset(innerRadius);
    const outerAngleOffset = this.getAngleOffset(outerRadius);
    const outerAngleExceeded = sweepAngle < 2 * outerAngleOffset;
    if (outerAngleExceeded)
      return;
    const hasInnerSweep = (clipSector?.innerRadius ?? innerRadius) > concentricEdgeInset;
    const innerAngleExceeded = innerRadius < concentricEdgeInset || sweepAngle < 2 * innerAngleOffset;
    const radialLength = outerRadius - innerRadius;
    const maxRadialLength = Math.max(
      startOuterCornerRadius,
      startInnerCornerRadius,
      endOuterCornerRadius,
      endInnerCornerRadius
    );
    const initialScalingFactor = maxRadialLength > 0 ? Math.min(radialLength / maxRadialLength, 1) : 1;
    startOuterCornerRadius *= initialScalingFactor;
    endOuterCornerRadius *= initialScalingFactor;
    startInnerCornerRadius *= initialScalingFactor;
    endInnerCornerRadius *= initialScalingFactor;
    const outerScalingFactor = radiiScalingFactor(
      outerRadius,
      sweepAngle - 2 * outerAngleOffset,
      -startOuterCornerRadius,
      -endOuterCornerRadius
    );
    startOuterCornerRadius *= outerScalingFactor;
    endOuterCornerRadius *= outerScalingFactor;
    if (!innerAngleExceeded && hasInnerSweep) {
      const innerScalingFactor = radiiScalingFactor(
        innerRadius,
        sweepAngle - 2 * innerAngleOffset,
        startInnerCornerRadius,
        endInnerCornerRadius
      );
      startInnerCornerRadius *= innerScalingFactor;
      endInnerCornerRadius *= innerScalingFactor;
    } else {
      startInnerCornerRadius = 0;
      endInnerCornerRadius = 0;
    }
    const maxCombinedRadialLength = Math.max(
      startOuterCornerRadius + startInnerCornerRadius,
      endOuterCornerRadius + endInnerCornerRadius
    );
    const edgesScalingFactor = maxCombinedRadialLength > 0 ? Math.min(radialLength / maxCombinedRadialLength, 1) : 1;
    startOuterCornerRadius *= edgesScalingFactor;
    endOuterCornerRadius *= edgesScalingFactor;
    startInnerCornerRadius *= edgesScalingFactor;
    endInnerCornerRadius *= edgesScalingFactor;
    let startOuterCornerRadiusAngleSweep = 0;
    let endOuterCornerRadiusAngleSweep = 0;
    const startOuterCornerRadiusSweep = startOuterCornerRadius / (outerRadius - startOuterCornerRadius);
    const endOuterCornerRadiusSweep = endOuterCornerRadius / (outerRadius - endOuterCornerRadius);
    if (startOuterCornerRadiusSweep >= 0 && startOuterCornerRadiusSweep < 1 - delta3) {
      startOuterCornerRadiusAngleSweep = Math.asin(startOuterCornerRadiusSweep);
    } else {
      startOuterCornerRadiusAngleSweep = sweepAngle / 2;
      const maxStartOuterCornerRadius = outerRadius / (1 / Math.sin(startOuterCornerRadiusAngleSweep) + 1);
      startOuterCornerRadius = Math.min(maxStartOuterCornerRadius, startOuterCornerRadius);
    }
    if (endOuterCornerRadiusSweep >= 0 && endOuterCornerRadiusSweep < 1 - delta3) {
      endOuterCornerRadiusAngleSweep = Math.asin(endOuterCornerRadiusSweep);
    } else {
      endOuterCornerRadiusAngleSweep = sweepAngle / 2;
      const maxEndOuterCornerRadius = outerRadius / (1 / Math.sin(endOuterCornerRadiusAngleSweep) + 1);
      endOuterCornerRadius = Math.min(maxEndOuterCornerRadius, endOuterCornerRadius);
    }
    const startInnerCornerRadiusAngleSweep = Math.asin(
      startInnerCornerRadius / (innerRadius + startInnerCornerRadius)
    );
    const endInnerCornerRadiusAngleSweep = Math.asin(endInnerCornerRadius / (innerRadius + endInnerCornerRadius));
    const outerArcRadius = clipSector?.outerRadius ?? outerRadius;
    const outerArcRadiusOffset = this.getAngleOffset(outerArcRadius);
    const outerArc = new Arc(
      0,
      0,
      outerArcRadius,
      startAngle + outerArcRadiusOffset,
      endAngle - outerArcRadiusOffset
    );
    const innerArcRadius = clipSector?.innerRadius ?? innerRadius;
    const innerArcRadiusOffset = this.getAngleOffset(innerArcRadius);
    const innerArc = hasInnerSweep ? new Arc(0, 0, innerArcRadius, startAngle + innerArcRadiusOffset, endAngle - innerArcRadiusOffset) : void 0;
    if (clipSector != null) {
      outerArc.clipStart(clipSector.startAngle);
      outerArc.clipEnd(clipSector.endAngle);
      innerArc?.clipStart(clipSector.startAngle);
      innerArc?.clipEnd(clipSector.endAngle);
    }
    const startOuterArc = this.arc(
      startOuterCornerRadius,
      startOuterCornerRadiusAngleSweep,
      startAngle - Math.PI * 0.5,
      startAngle + startOuterCornerRadiusAngleSweep,
      outerArc,
      innerArc,
      true,
      false
    );
    const endOuterArc = this.arc(
      endOuterCornerRadius,
      endOuterCornerRadiusAngleSweep,
      endAngle - endOuterCornerRadiusAngleSweep,
      endAngle + Math.PI * 0.5,
      outerArc,
      innerArc,
      false,
      false
    );
    const endInnerArc = this.arc(
      endInnerCornerRadius,
      endInnerCornerRadiusAngleSweep,
      endAngle + Math.PI * 0.5,
      endAngle + Math.PI - endInnerCornerRadiusAngleSweep,
      outerArc,
      innerArc,
      false,
      true
    );
    const startInnerArc = this.arc(
      startInnerCornerRadius,
      startInnerCornerRadiusAngleSweep,
      startAngle + Math.PI + startInnerCornerRadiusAngleSweep,
      startAngle + Math.PI * 1.5,
      outerArc,
      innerArc,
      true,
      true
    );
    if (innerAngleExceeded) {
      const x = sweepAngle < Math.PI * 0.5 ? radialEdgeInset * (1 + Math.cos(sweepAngle)) / Math.sin(sweepAngle) : NaN;
      let r;
      if (x > 0 && x < outerRadius) {
        r = Math.max(Math.hypot(radialEdgeInset, x), innerRadius);
      } else {
        r = radialEdgeInset;
      }
      r = Math.max(r, innerRadius);
      const midAngle = startAngle + sweepAngle * 0.5;
      path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));
    } else if (startInnerArc?.isValid() === true || innerArc?.isValid() === true) {
    } else {
      const midAngle = startAngle + sweepAngle / 2;
      const cx = innerRadius * Math.cos(midAngle);
      const cy = innerRadius * Math.sin(midAngle);
      path.moveTo(centerX + cx, centerY + cy);
    }
    if (startOuterArc?.isValid() === true) {
      const { cx, cy, r, a0, a1 } = startOuterArc;
      path.arc(centerX + cx, centerY + cy, r, a0, a1);
    }
    if (outerArc.isValid()) {
      const { r, a0, a1 } = outerArc;
      path.arc(centerX, centerY, r, a0, a1);
    }
    if (endOuterArc?.isValid() === true) {
      const { cx, cy, r, a0, a1 } = endOuterArc;
      path.arc(centerX + cx, centerY + cy, r, a0, a1);
    }
    if (!innerAngleExceeded) {
      if (endInnerArc?.isValid() === true) {
        const { cx, cy, r, a0, a1 } = endInnerArc;
        path.arc(centerX + cx, centerY + cy, r, a0, a1);
      }
      if (innerArc?.isValid() === true) {
        const { r, a0, a1 } = innerArc;
        path.arc(centerX, centerY, r, a1, a0, true);
      }
      if (startInnerArc?.isValid() === true) {
        const { cx, cy, r, a0, a1 } = startInnerArc;
        path.arc(centerX + cx, centerY + cy, r, a0, a1);
      }
    }
    path.closePath();
  }
  isPointInPath(x, y) {
    const { startAngle, endAngle, innerRadius, outerRadius } = this.clipSector ?? this;
    return isPointInSector(x - this.centerX, y - this.centerY, {
      startAngle,
      endAngle,
      innerRadius: Math.min(innerRadius, outerRadius),
      outerRadius: Math.max(innerRadius, outerRadius)
    });
  }
};
Sector.className = "Sector";
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "centerX", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "centerY", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "innerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "outerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "startAngle", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "endAngle", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "clipSector", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "concentricEdgeInset", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "radialEdgeInset", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "startOuterCornerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "endOuterCornerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "startInnerCornerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "endInnerCornerRadius", 2);

// packages/ag-charts-community/src/chart/themes/defaultColors.ts
var DEFAULT_FILLS = {
  BLUE: "#5090dc",
  ORANGE: "#ffa03a",
  GREEN: "#459d55",
  CYAN: "#34bfe1",
  YELLOW: "#e1cc00",
  VIOLET: "#9669cb",
  GRAY: "#b5b5b5",
  MAGENTA: "#bd5aa7",
  BROWN: "#8a6224",
  RED: "#ef5452"
};
var DEFAULT_STROKES = {
  BLUE: "#2b5c95",
  ORANGE: "#cc6f10",
  GREEN: "#1e652e",
  CYAN: "#18859e",
  YELLOW: "#a69400",
  VIOLET: "#603c88",
  GRAY: "#575757",
  MAGENTA: "#7d2f6d",
  BROWN: "#4f3508",
  RED: "#a82529"
};

// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts
var DonutTitle = class extends Caption {
  constructor() {
    super(...arguments);
    this.showInLegend = false;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], DonutTitle.prototype, "showInLegend", 2);
var DonutInnerLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.spacing = 2;
  }
  set(properties, _reset) {
    return super.set(properties);
  }
};
__decorateClass([
  Validate(STRING)
], DonutInnerLabel.prototype, "text", 2);
__decorateClass([
  Validate(NUMBER)
], DonutInnerLabel.prototype, "spacing", 2);
var DonutInnerCircle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.fill = "transparent";
    this.fillOpacity = 1;
  }
};
__decorateClass([
  Validate(COLOR_STRING)
], DonutInnerCircle.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO)
], DonutInnerCircle.prototype, "fillOpacity", 2);
var DonutSeriesCalloutLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.offset = 3;
    this.minAngle = 0;
    this.minSpacing = 4;
    this.maxCollisionOffset = 50;
    this.avoidCollisions = true;
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesCalloutLabel.prototype, "offset", 2);
__decorateClass([
  Validate(DEGREE)
], DonutSeriesCalloutLabel.prototype, "minAngle", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesCalloutLabel.prototype, "minSpacing", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesCalloutLabel.prototype, "maxCollisionOffset", 2);
__decorateClass([
  Validate(BOOLEAN)
], DonutSeriesCalloutLabel.prototype, "avoidCollisions", 2);
var DonutSeriesSectorLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.positionOffset = 0;
    this.positionRatio = 0.5;
  }
};
__decorateClass([
  Validate(NUMBER)
], DonutSeriesSectorLabel.prototype, "positionOffset", 2);
__decorateClass([
  Validate(RATIO)
], DonutSeriesSectorLabel.prototype, "positionRatio", 2);
var DonutSeriesCalloutLine = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.length = 10;
    this.strokeWidth = 1;
  }
};
__decorateClass([
  Validate(COLOR_STRING_ARRAY, { optional: true })
], DonutSeriesCalloutLine.prototype, "colors", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesCalloutLine.prototype, "length", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesCalloutLine.prototype, "strokeWidth", 2);
var DonutSeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.fills = Object.values(DEFAULT_FILLS);
    this.strokes = Object.values(DEFAULT_STROKES);
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.rotation = 0;
    this.outerRadiusOffset = 0;
    this.outerRadiusRatio = 1;
    this.strokeWidth = 1;
    this.sectorSpacing = 0;
    this.innerLabels = new PropertiesArray(DonutInnerLabel);
    this.title = new DonutTitle();
    this.innerCircle = new DonutInnerCircle();
    this.shadow = new DropShadow();
    this.calloutLabel = new DonutSeriesCalloutLabel();
    this.sectorLabel = new DonutSeriesSectorLabel();
    this.calloutLine = new DonutSeriesCalloutLine();
    this.tooltip = new SeriesTooltip();
  }
  isValid() {
    const superIsValid = super.isValid();
    if (this.innerRadiusRatio == null && this.innerRadiusOffset == null) {
      Logger.warnOnce(
        "Either an [innerRadiusRatio] or an [innerRadiusOffset] must be set to render a donut series."
      );
      return false;
    }
    return superIsValid;
  }
};
__decorateClass([
  Validate(STRING)
], DonutSeriesProperties.prototype, "angleKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "angleName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "angleFilterKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "radiusKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "radiusName", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], DonutSeriesProperties.prototype, "radiusMin", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], DonutSeriesProperties.prototype, "radiusMax", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "calloutLabelKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "calloutLabelName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "sectorLabelKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "sectorLabelName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "legendItemKey", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], DonutSeriesProperties.prototype, "fills", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], DonutSeriesProperties.prototype, "strokes", 2);
__decorateClass([
  Validate(RATIO)
], DonutSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(RATIO)
], DonutSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH)
], DonutSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], DonutSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate(DEGREE)
], DonutSeriesProperties.prototype, "rotation", 2);
__decorateClass([
  Validate(NUMBER)
], DonutSeriesProperties.prototype, "outerRadiusOffset", 2);
__decorateClass([
  Validate(RATIO)
], DonutSeriesProperties.prototype, "outerRadiusRatio", 2);
__decorateClass([
  Validate(NUMBER, { optional: true })
], DonutSeriesProperties.prototype, "innerRadiusOffset", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], DonutSeriesProperties.prototype, "innerRadiusRatio", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(NUMBER)
], DonutSeriesProperties.prototype, "sectorSpacing", 2);
__decorateClass([
  Validate(OBJECT_ARRAY)
], DonutSeriesProperties.prototype, "innerLabels", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "title", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "innerCircle", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "calloutLabel", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "sectorLabel", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "calloutLine", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts
function preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {
  const scale2 = [scaleFn.convert(0), scaleFn.convert(1)];
  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];
  const rotation = Math.PI / -2 + toRadians(rotationDegrees);
  const phase = initialLoad ? "initial" : "update";
  const scaleToNewRadius = ({ radius }) => {
    return { innerRadius: scale2[0], outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius };
  };
  const scaleToOldRadius = ({ radius }) => {
    return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };
  };
  const fromFn = (sect, datum, status, { prevFromProps }) => {
    let { startAngle, endAngle, innerRadius, outerRadius } = sect;
    let { fill, stroke } = datum.sectorFormat;
    if (status === "unknown" || status === "added" && !prevFromProps) {
      startAngle = rotation;
      endAngle = rotation;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
    } else if (status === "added" && prevFromProps) {
      startAngle = prevFromProps.endAngle ?? rotation;
      endAngle = prevFromProps.endAngle ?? rotation;
      innerRadius = prevFromProps.innerRadius ?? datum.innerRadius;
      outerRadius = prevFromProps.outerRadius ?? datum.outerRadius;
    }
    if (status === "added" && !initialLoad) {
      const radii = scaleToOldRadius(datum);
      innerRadius = radii.innerRadius;
      outerRadius = radii.outerRadius;
    }
    if (status === "updated") {
      fill = sect.fill ?? fill;
      stroke = sect.stroke ?? stroke;
    }
    return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke, phase };
  };
  const toFn = (_sect, datum, status, { prevLive }) => {
    let { startAngle, endAngle, innerRadius, outerRadius } = datum;
    const { stroke, fill } = datum.sectorFormat;
    if (status === "removed" && prevLive) {
      startAngle = prevLive.datum?.endAngle;
      endAngle = prevLive.datum?.endAngle;
    } else if (status === "removed" && !prevLive) {
      startAngle = rotation;
      endAngle = rotation;
    }
    if (status === "removed") {
      const radii = scaleToNewRadius(datum);
      innerRadius = radii.innerRadius;
      outerRadius = radii.outerRadius;
    }
    return { startAngle, endAngle, outerRadius, innerRadius, stroke, fill };
  };
  const innerCircleFromFn = (node, _) => {
    return { size: node.previousDatum?.radius ?? node.size ?? 0, phase };
  };
  const innerCircleToFn = (_, datum) => {
    return { size: datum.radius ?? 0 };
  };
  return { nodes: { toFn, fromFn }, innerCircle: { fromFn: innerCircleFromFn, toFn: innerCircleToFn } };
}
function resetPieSelectionsFn(_node, datum) {
  return {
    startAngle: datum.startAngle,
    endAngle: datum.endAngle,
    innerRadius: datum.innerRadius,
    outerRadius: datum.outerRadius,
    fill: datum.sectorFormat.fill,
    stroke: datum.sectorFormat.stroke
  };
}
function pickByMatchingAngle(series, point) {
  const dy = point.y - series.centerY;
  const dx = point.x - series.centerX;
  const angle2 = Math.atan2(dy, dx);
  const sectors = series.getItemNodes();
  for (const sector of sectors) {
    if (sector.datum.missing === true)
      continue;
    if (isBetweenAngles(angle2, sector.startAngle, sector.endAngle)) {
      const radius = Math.sqrt(dx * dx + dy * dy);
      let distance3 = 0;
      if (radius < sector.innerRadius) {
        distance3 = sector.innerRadius - radius;
      } else if (radius > sector.outerRadius) {
        distance3 = radius - sector.outerRadius;
      }
      return { datum: sector.datum, distance: distance3 };
    }
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts
var PolarSeries = class extends DataModelSeries {
  constructor({
    useLabelLayer = false,
    pickModes = [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
    canHaveAxes = false,
    animationResetFns,
    ...opts
  }) {
    super({
      ...opts,
      useLabelLayer,
      pickModes,
      contentGroupVirtual: false,
      directionKeys: {
        ["x" /* X */]: ["angleKey"],
        ["y" /* Y */]: ["radiusKey"]
      },
      directionNames: {
        ["x" /* X */]: ["angleName"],
        ["y" /* Y */]: ["radiusName"]
      },
      canHaveAxes
    });
    this.itemGroup = this.contentGroup.appendChild(new Group());
    this.nodeData = [];
    this.itemSelection = Selection.select(
      this.itemGroup,
      () => this.nodeFactory(),
      false
    );
    this.labelSelection = Selection.select(
      this.labelGroup,
      () => this.labelFactory(),
      false
    );
    this.highlightSelection = Selection.select(
      this.highlightGroup,
      () => this.nodeFactory()
    );
    this.highlightLabelSelection = Selection.select(
      this.highlightLabel,
      () => this.labelFactory()
    );
    /**
     * The center of the polar series (for example, the center of a pie).
     * If the polar chart has multiple series, all of them will have their
     * center set to the same value as a result of the polar chart layout.
     * The center coordinates are not supposed to be set by the user.
     */
    this.centerX = 0;
    this.centerY = 0;
    /**
     * The maximum radius the series can use.
     * This value is set automatically as a result of the polar chart layout
     * and is not supposed to be set by the user.
     */
    this.radius = 0;
    this.itemGroup.zIndexSubOrder = [() => this._declarationOrder, 1];
    this.animationResetFns = animationResetFns;
    this.animationState = new StateMachine(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: (data) => this.animateEmptyUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          highlight: (data) => this.animateReadyHighlight(data),
          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),
          resize: (data) => this.animateReadyResize(data),
          reset: "empty",
          skip: "ready"
        },
        waiting: {
          update: {
            target: "ready",
            action: (data) => this.animateWaitingUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        clearing: {
          update: {
            target: "empty",
            action: (data) => this.animateClearingUpdateEmpty(data)
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  getItemNodes() {
    return [...this.itemGroup.children()];
  }
  getNodeData() {
    return this.nodeData;
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  labelFactory() {
    const text = new Text();
    text.pointerEvents = 1 /* None */;
    return text;
  }
  getInnerRadius() {
    return 0;
  }
  getLabelData() {
    return [];
  }
  computeLabelsBBox(_options, _seriesRect) {
    return null;
  }
  resetAllAnimation() {
    const { item, label } = this.animationResetFns ?? {};
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    if (item) {
      resetMotion([this.itemSelection, this.highlightSelection], item);
    }
    if (label) {
      resetMotion([this.labelSelection, this.highlightLabelSelection], label);
    }
    this.itemSelection.cleanup();
    this.labelSelection.cleanup();
    this.highlightSelection.cleanup();
    this.highlightLabelSelection.cleanup();
  }
  animateEmptyUpdateReady(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  animateWaitingUpdateReady(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  animateReadyHighlight(_data) {
    const { item, label } = this.animationResetFns ?? {};
    if (item) {
      resetMotion([this.highlightSelection], item);
    }
    if (label) {
      resetMotion([this.highlightLabelSelection], label);
    }
  }
  animateReadyHighlightMarkers(_data) {
  }
  animateReadyResize(_data) {
    this.resetAllAnimation();
  }
  animateClearingUpdateEmpty(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  animationTransitionClear() {
    this.animationState.transition("clear", this.getAnimationData());
  }
  getAnimationData(seriesRect) {
    return { seriesRect };
  }
  computeFocusBounds(opts) {
    const datum = this.getNodeData()?.[opts.datumIndex];
    if (datum !== void 0) {
      return this.itemSelection.select((node) => node instanceof Path && node.datum === datum)[0];
    }
    return void 0;
  }
};

// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts
var DonutSeriesNodeEvent = class extends SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
    this.calloutLabelKey = series.properties.calloutLabelKey;
    this.sectorLabelKey = series.properties.sectorLabelKey;
  }
};
var DonutSeries = class extends PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
      useLabelLayer: true,
      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }
    });
    this.properties = new DonutSeriesProperties();
    this.phantomNodeData = void 0;
    this.previousRadiusScale = new LinearScale();
    this.radiusScale = new LinearScale();
    this.phantomGroup = this.contentGroup.appendChild(new Group());
    this.phantomSelection = Selection.select(
      this.phantomGroup,
      () => this.nodeFactory(),
      false
    );
    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: "pieCalloutLabels" }));
    this.calloutLabelSelection = new Selection(
      this.calloutLabelGroup,
      Group
    );
    // The group node that contains the background graphics.
    this.backgroundGroup = this.rootGroup.appendChild(
      new TranslatableLayer({
        name: `${this.id}-background`,
        zIndex: 0 /* SERIES_BACKGROUND */
      })
    );
    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.
    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));
    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());
    this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Circle());
    this.innerLabelsGroup = this.contentGroup.appendChild(new Group({ name: "innerLabels" }));
    this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));
    this.innerLabelsSelection = Selection.select(this.innerLabelsGroup, Text);
    this.innerCircleSelection = Selection.select(
      this.innerCircleGroup,
      Circle
    );
    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.
    this.seriesItemEnabled = [];
    this.legendItemEnabled = [];
    this.surroundingRadius = void 0;
    this.NodeEvent = DonutSeriesNodeEvent;
    this.angleScale = new LinearScale();
    this.angleScale.domain = [0, 1];
    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);
    this.phantomGroup.opacity = 0.2;
    this.phantomGroup.zIndexSubOrder = [() => this._declarationOrder, 0];
  }
  get calloutNodeData() {
    return this.phantomNodeData ?? this.nodeData;
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager?.addListener("legend-item-click", (event) => this.onLegendItemClick(event))
    );
  }
  get visible() {
    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.includes(true));
  }
  nodeFactory() {
    return new Sector();
  }
  getSeriesDomain(direction) {
    if (direction === "x" /* X */) {
      return this.angleScale.domain;
    } else {
      return this.radiusScale.domain;
    }
  }
  async processData(dataController) {
    if (this.data == null || !this.properties.isValid()) {
      return;
    }
    let { data } = this;
    const { visible, seriesItemEnabled } = this;
    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const extraKeyProps = [];
    const extraProps = [];
    if (legendItemKey) {
      extraKeyProps.push(keyProperty(legendItemKey, "band", { id: `legendItemKey` }));
    } else if (calloutLabelKey) {
      extraKeyProps.push(keyProperty(calloutLabelKey, "band", { id: `calloutLabelKey` }));
    } else if (sectorLabelKey) {
      extraKeyProps.push(keyProperty(sectorLabelKey, "band", { id: `sectorLabelKey` }));
    }
    const radiusScaleType = this.radiusScale.type;
    const angleScaleType = this.radiusScale.type;
    if (radiusKey) {
      extraProps.push(
        rangedValueProperty(radiusKey, {
          id: "radiusValue",
          min: this.properties.radiusMin ?? 0,
          max: this.properties.radiusMax
        }),
        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),
        // Raw value pass-through.
        normalisePropertyTo("radiusValue", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)
      );
    }
    if (calloutLabelKey) {
      extraProps.push(valueProperty(calloutLabelKey, "band", { id: `calloutLabelValue` }));
    }
    if (sectorLabelKey) {
      extraProps.push(valueProperty(sectorLabelKey, "band", { id: `sectorLabelValue` }));
    }
    if (legendItemKey) {
      extraProps.push(valueProperty(legendItemKey, "band", { id: `legendItemValue` }));
    }
    if (angleFilterKey) {
      extraProps.push(
        accumulativeValueProperty(angleFilterKey, angleScaleType, {
          id: `angleFilterValue`,
          onlyPositive: true
        }),
        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),
        normalisePropertyTo("angleFilterValue", [0, 1], 0, 0)
      );
    }
    if (animationEnabled && this.processedData && extraKeyProps.length > 0) {
      extraProps.push(diff(this.processedData));
    }
    extraProps.push(animationValidation());
    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });
    await this.requestDataModel(dataController, data, {
      props: [
        ...extraKeyProps,
        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),
        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),
        // Raw value pass-through.
        normalisePropertyTo("angleValue", [0, 1], 0, 0),
        ...extraProps
      ]
    });
    for (const valueDef of this.processedData?.defs?.values ?? []) {
      const { id, missing, property } = valueDef;
      const missCount = getMissCount(this, missing);
      if (id !== "angleRaw" && missCount > 0) {
        Logger.warnOnce(
          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? "s" : ""}`
        );
      }
    }
    this.animationState.transition("updateData");
  }
  async maybeRefreshNodeData() {
    if (!this.nodeDataRefresh)
      return;
    const { nodeData = [], phantomNodeData } = await this.createNodeData() ?? {};
    this.nodeData = nodeData;
    this.phantomNodeData = phantomNodeData;
    this.nodeDataRefresh = false;
  }
  getProcessedDataIndexes(dataModel) {
    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);
    const angleRawIdx = dataModel.resolveProcessedDataIndexById(this, `angleRaw`);
    const angleFilterIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterValue`) : void 0;
    const angleFilterRawIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterRaw`) : void 0;
    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : void 0;
    const radiusRawIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusRaw`) : void 0;
    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : void 0;
    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : void 0;
    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : void 0;
    return {
      angleIdx,
      angleRawIdx,
      angleFilterIdx,
      angleFilterRawIdx,
      radiusIdx,
      radiusRawIdx,
      calloutLabelIdx,
      sectorLabelIdx,
      legendItemIdx
    };
  }
  async createNodeData() {
    const { id: seriesId, processedData, dataModel, angleScale } = this;
    const { rotation, innerRadiusRatio } = this.properties;
    if (!this.properties.isValid()) {
      this.zerosumOuterRing.visible = true;
      this.zerosumInnerRing.visible = true;
      return { itemId: seriesId, nodeData: [], labelData: [] };
    }
    if (!processedData || !dataModel || processedData.type !== "ungrouped")
      return;
    const {
      angleIdx,
      angleRawIdx,
      angleFilterIdx,
      angleFilterRawIdx,
      radiusIdx,
      radiusRawIdx,
      calloutLabelIdx,
      sectorLabelIdx,
      legendItemIdx
    } = this.getProcessedDataIndexes(dataModel);
    const useFilterAngles = angleFilterRawIdx != null && processedData.data.some(({ values }) => {
      return values[angleFilterRawIdx] > values[angleRawIdx];
    });
    let currentStart = 0;
    let sum = 0;
    const nodes = [];
    const phantomNodes = angleFilterRawIdx != null ? [] : void 0;
    processedData.data.forEach((group, index) => {
      const { datum, values } = group;
      const currentValue = useFilterAngles ? values[angleFilterIdx] : values[angleIdx];
      const crossFilterScale = angleFilterRawIdx != null && !useFilterAngles ? Math.sqrt(values[angleFilterRawIdx] / values[angleRawIdx]) : 1;
      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);
      currentStart = currentValue;
      sum += currentValue;
      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);
      const span = Math.abs(endAngle - startAngle);
      const midAngle = startAngle + span / 2;
      const angleValue = values[angleRawIdx];
      const radiusRaw = radiusIdx != null ? values[radiusIdx] ?? 1 : 1;
      const radius = radiusRaw * crossFilterScale;
      const radiusValue = radiusRawIdx != null ? values[radiusRawIdx] : void 0;
      const legendItemValue = legendItemIdx != null ? values[legendItemIdx] : void 0;
      const nodeLabels = this.getLabels(
        datum,
        midAngle,
        span,
        true,
        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,
        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,
        legendItemValue
      );
      const sectorFormat = this.getSectorFormat(datum, index, false);
      const node = {
        itemId: index,
        series: this,
        datum,
        index,
        angleValue,
        midAngle,
        midCos: Math.cos(midAngle),
        midSin: Math.sin(midAngle),
        startAngle,
        endAngle,
        radius,
        innerRadius: Math.max(this.radiusScale.convert(0), 0),
        outerRadius: Math.max(this.radiusScale.convert(radius), 0),
        sectorFormat,
        radiusValue,
        legendItemValue,
        enabled: this.seriesItemEnabled[index],
        focusable: true,
        ...nodeLabels
      };
      nodes.push(node);
      if (phantomNodes != null) {
        phantomNodes.push({
          ...node,
          radius: 1,
          innerRadius: Math.max(this.radiusScale.convert(0), 0),
          outerRadius: Math.max(this.radiusScale.convert(1), 0),
          focusable: false
        });
      }
    });
    this.zerosumOuterRing.visible = sum === 0;
    this.zerosumInnerRing.visible = sum === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;
    return {
      itemId: seriesId,
      nodeData: nodes,
      labelData: nodes,
      phantomNodeData: phantomNodes
    };
  }
  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {
    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;
    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;
    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;
    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {
      return {};
    }
    const labelFormatterParams = {
      datum,
      angleKey: this.properties.angleKey,
      angleName: this.properties.angleName,
      radiusKey: this.properties.radiusKey,
      radiusName: this.properties.radiusName,
      calloutLabelKey: this.properties.calloutLabelKey,
      calloutLabelName: this.properties.calloutLabelName,
      sectorLabelKey: this.properties.sectorLabelKey,
      sectorLabelName: this.properties.sectorLabelName,
      legendItemKey: this.properties.legendItemKey
    };
    const result = {};
    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {
      result.calloutLabel = {
        ...this.getTextAlignment(midAngle),
        text: this.getLabelText(calloutLabel, {
          ...labelFormatterParams,
          value: calloutLabelValue
        }),
        hidden: false,
        collisionTextAlign: void 0,
        collisionOffsetY: 0,
        box: void 0
      };
    }
    if (sectorLabelKey) {
      result.sectorLabel = {
        text: this.getLabelText(sectorLabel, {
          ...labelFormatterParams,
          value: sectorLabelValue
        })
      };
    }
    if (legendItemKey != null && legendItemValue != null) {
      result.legendItem = { key: legendItemKey, text: legendItemValue };
    }
    return result;
  }
  getTextAlignment(midAngle) {
    const quadrantTextOpts = [
      { textAlign: "center", textBaseline: "bottom" },
      { textAlign: "left", textBaseline: "middle" },
      { textAlign: "center", textBaseline: "hanging" },
      { textAlign: "right", textBaseline: "middle" }
    ];
    const midAngle180 = normalizeAngle180(midAngle);
    const quadrantStart = -0.75 * Math.PI;
    const quadrantOffset = midAngle180 - quadrantStart;
    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));
    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);
    return quadrantTextOpts[quadrantIndex];
  }
  getSectorFormat(datum, formatIndex, highlighted) {
    const { callbackCache } = this.ctx;
    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;
    const defaultStroke = strokes[formatIndex % strokes.length];
    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(
      highlighted && this.properties.highlightStyle.item,
      {
        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,
        stroke: defaultStroke,
        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),
        strokeOpacity: this.getOpacity()
      },
      this.properties
    );
    let format;
    if (itemStyler) {
      format = callbackCache.call(itemStyler, {
        datum,
        angleKey,
        radiusKey,
        calloutLabelKey,
        sectorLabelKey,
        legendItemKey,
        fill,
        fillOpacity,
        stroke,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        cornerRadius,
        highlighted,
        seriesId: this.id
      });
    }
    return {
      fill: format?.fill ?? fill,
      fillOpacity: format?.fillOpacity ?? fillOpacity,
      stroke: format?.stroke ?? stroke,
      strokeWidth: format?.strokeWidth ?? strokeWidth,
      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,
      lineDash: format?.lineDash ?? lineDash,
      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,
      cornerRadius: format?.cornerRadius ?? cornerRadius
    };
  }
  getInnerRadius() {
    const { radius } = this;
    const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;
    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;
    if (innerRadius === radius || innerRadius < 0) {
      return 0;
    }
    return innerRadius;
  }
  getOuterRadius() {
    const { outerRadiusRatio, outerRadiusOffset } = this.properties;
    return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);
  }
  updateRadiusScale(resize) {
    const newRange = [this.getInnerRadius(), this.getOuterRadius()];
    this.radiusScale.range = newRange;
    if (resize) {
      this.previousRadiusScale.range = newRange;
    }
    const setRadii = (d) => ({
      ...d,
      innerRadius: Math.max(this.radiusScale.convert(0), 0),
      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)
    });
    this.nodeData = this.nodeData.map(setRadii);
    this.phantomNodeData = this.phantomNodeData?.map(setRadii);
  }
  getTitleTranslationY() {
    const outerRadius = Math.max(0, this.radiusScale.range[1]);
    if (outerRadius === 0) {
      return NaN;
    }
    const spacing = this.properties.title?.spacing ?? 0;
    const titleOffset = 2 + spacing;
    const dy = Math.max(0, -outerRadius);
    return -outerRadius - titleOffset - dy;
  }
  async update({ seriesRect }) {
    const { title } = this.properties;
    const newNodeDataDependencies = {
      seriesRectWidth: seriesRect?.width,
      seriesRectHeight: seriesRect?.height
    };
    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
    if (resize) {
      this._nodeDataDependencies = newNodeDataDependencies;
    }
    await this.maybeRefreshNodeData();
    this.updateTitleNodes();
    this.updateRadiusScale(resize);
    this.contentGroup.translationX = this.centerX;
    this.contentGroup.translationY = this.centerY;
    this.highlightGroup.translationX = this.centerX;
    this.highlightGroup.translationY = this.centerY;
    this.backgroundGroup.translationX = this.centerX;
    this.backgroundGroup.translationY = this.centerY;
    if (this.labelGroup) {
      this.labelGroup.translationX = this.centerX;
      this.labelGroup.translationY = this.centerY;
    }
    if (title) {
      const dy = this.getTitleTranslationY();
      title.node.y = isFinite(dy) ? dy : 0;
      const titleBox = title.node.getBBox();
      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox);
    }
    for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {
      circle.fillOpacity = 0;
      circle.stroke = this.properties.calloutLabel.color;
      circle.strokeWidth = 1;
      circle.strokeOpacity = 1;
    }
    this.updateNodeMidPoint();
    await this.updateSelections();
    await this.updateNodes(seriesRect);
  }
  updateTitleNodes() {
    const { oldTitle } = this;
    const { title } = this.properties;
    if (oldTitle !== title) {
      if (oldTitle) {
        this.labelGroup?.removeChild(oldTitle.node);
      }
      if (title) {
        title.node.textBaseline = "bottom";
        this.labelGroup?.appendChild(title.node);
      }
      this.oldTitle = title;
    }
  }
  updateNodeMidPoint() {
    const setMidPoint = (d) => {
      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;
      d.midPoint = {
        x: d.midCos * Math.max(0, radius),
        y: d.midSin * Math.max(0, radius)
      };
    };
    this.nodeData.forEach(setMidPoint);
    this.phantomNodeData?.forEach(setMidPoint);
  }
  async updateSelections() {
    await this.updateGroupSelection();
    this.updateInnerCircleSelection();
  }
  async updateGroupSelection() {
    const {
      itemSelection,
      highlightSelection,
      phantomSelection,
      highlightLabelSelection,
      calloutLabelSelection,
      labelSelection,
      innerLabelsSelection
    } = this;
    const highlightedNodeData = this.nodeData.map((datum) => ({
      ...datum,
      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied
      // between normal and highlighted cases.
      sectorFormat: { ...datum.sectorFormat }
    }));
    const update = (selection, nodeData) => {
      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));
      if (this.ctx.animationManager.isSkipped()) {
        selection.cleanup();
      }
    };
    update(itemSelection, this.nodeData);
    update(highlightSelection, highlightedNodeData);
    update(phantomSelection, this.phantomNodeData ?? []);
    calloutLabelSelection.update(this.calloutNodeData, (group) => {
      const line = new Line();
      line.tag = 0 /* Callout */;
      line.pointerEvents = 1 /* None */;
      group.appendChild(line);
      const text = new Text();
      text.tag = 1 /* Label */;
      text.pointerEvents = 1 /* None */;
      group.appendChild(text);
    });
    labelSelection.update(this.nodeData);
    highlightLabelSelection.update(highlightedNodeData);
    innerLabelsSelection.update(this.properties.innerLabels, (node) => {
      node.pointerEvents = 1 /* None */;
    });
  }
  updateInnerCircleSelection() {
    const { innerCircle } = this.properties;
    let radius = 0;
    const innerRadius = this.getInnerRadius();
    if (innerRadius > 0) {
      const circleRadius = Math.min(innerRadius, this.getOuterRadius());
      const antiAliasingPadding = 1;
      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);
    }
    const datums = innerCircle ? [{ radius }] : [];
    this.innerCircleSelection.update(datums);
  }
  async updateNodes(seriesRect) {
    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();
    const isVisible = this.visible && this.seriesItemEnabled.includes(true);
    this.rootGroup.visible = isVisible;
    this.backgroundGroup.visible = isVisible;
    this.contentGroup.visible = isVisible;
    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;
    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;
    this.labelGroup.visible = isVisible;
    this.contentGroup.opacity = this.getOpacity();
    this.innerCircleSelection.each((node, { radius }) => {
      node.setProperties({
        fill: this.properties.innerCircle?.fill,
        opacity: this.properties.innerCircle?.fillOpacity,
        size: radius
      });
    });
    const animationDisabled = this.ctx.animationManager.isSkipped();
    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {
      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);
      datum.sectorFormat.fill = format.fill;
      datum.sectorFormat.stroke = format.stroke;
      if (animationDisabled) {
        sector.startAngle = datum.startAngle;
        sector.endAngle = datum.endAngle;
        sector.innerRadius = datum.innerRadius;
        sector.outerRadius = datum.outerRadius;
      }
      if (isDatumHighlighted || animationDisabled) {
        sector.fill = format.fill;
        sector.stroke = format.stroke;
      }
      sector.strokeWidth = format.strokeWidth;
      sector.fillOpacity = format.fillOpacity;
      sector.strokeOpacity = format.strokeOpacity;
      sector.lineDash = format.lineDash;
      sector.lineDashOffset = format.lineDashOffset;
      sector.cornerRadius = format.cornerRadius;
      sector.fillShadow = this.properties.shadow;
      const inset = Math.max(
        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,
        0
      );
      sector.inset = inset;
      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? "miter" : "round";
    };
    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
    this.highlightSelection.each((node, datum, index) => {
      updateSectorFn(node, datum, index, true);
      node.visible = datum.itemId === highlightedDatum?.itemId;
    });
    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
    this.updateCalloutLineNodes();
    this.updateCalloutLabelNodes(seriesRect);
    this.updateSectorLabelNodes();
    this.updateInnerLabelNodes();
    this.updateZerosumRings();
    this.animationState.transition("update");
  }
  updateCalloutLineNodes() {
    const { calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const calloutStrokeWidth = calloutLine.strokeWidth;
    const calloutColors = calloutLine.colors ?? this.properties.strokes;
    const { offset: offset4 } = this.properties.calloutLabel;
    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {
      const datum = line.datum;
      const { calloutLabel: label, outerRadius } = datum;
      if (label?.text && !label.hidden && outerRadius !== 0) {
        line.visible = true;
        line.strokeWidth = calloutStrokeWidth;
        line.stroke = calloutColors[index % calloutColors.length];
        line.fill = void 0;
        const x1 = datum.midCos * outerRadius;
        const y1 = datum.midSin * outerRadius;
        let x2 = datum.midCos * (outerRadius + calloutLength);
        let y2 = datum.midSin * (outerRadius + calloutLength);
        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;
        if (isMoved && label.box != null) {
          const box = label.box;
          let cx = x2;
          let cy = y2;
          if (x2 < box.x) {
            cx = box.x;
          } else if (x2 > box.x + box.width) {
            cx = box.x + box.width;
          }
          if (y2 < box.y) {
            cy = box.y;
          } else if (y2 > box.y + box.height) {
            cy = box.y + box.height;
          }
          const dx = cx - x2;
          const dy = cy - y2;
          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          const paddedLength = length2 - offset4;
          if (paddedLength > 0) {
            x2 = x2 + dx * paddedLength / length2;
            y2 = y2 + dy * paddedLength / length2;
          }
        }
        line.x1 = x1;
        line.y1 = y1;
        line.x2 = x2;
        line.y2 = y2;
      } else {
        line.visible = false;
      }
    });
  }
  getLabelOverflow(text, box, seriesRect) {
    const seriesLeft = seriesRect.x - this.centerX;
    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;
    const seriesTop = seriesRect.y - this.centerY;
    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;
    const errPx = 1;
    let visibleTextPart = 1;
    if (box.x + errPx < seriesLeft) {
      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;
    } else if (box.x + box.width - errPx > seriesRight) {
      visibleTextPart = (seriesRight - box.x) / box.width;
    }
    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;
    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;
    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);
    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };
  }
  bboxIntersectsSurroundingSeries(box) {
    const { surroundingRadius } = this;
    if (surroundingRadius == null) {
      return false;
    }
    const corners = [
      { x: box.x, y: box.y },
      { x: box.x + box.width, y: box.y },
      { x: box.x + box.width, y: box.y + box.height },
      { x: box.x, y: box.y + box.height }
    ];
    const sur2 = surroundingRadius ** 2;
    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);
  }
  computeCalloutLabelCollisionOffsets() {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const { offset: offset4, minSpacing } = calloutLabel;
    const innerRadius = radiusScale.convert(0);
    const shouldSkip = (datum) => {
      const label = datum.calloutLabel;
      return !label || datum.outerRadius === 0;
    };
    const fullData = this.calloutNodeData;
    const data = fullData.filter((t) => !shouldSkip(t));
    data.forEach((datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return;
      label.hidden = false;
      label.collisionTextAlign = void 0;
      label.collisionOffsetY = 0;
    });
    if (data.length <= 1) {
      return;
    }
    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);
    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);
    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === "center").sort((a, b) => a.midCos - b.midCos);
    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === "center").sort((a, b) => a.midCos - b.midCos);
    const getTextBBox = (datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return BBox.zero.clone();
      const labelRadius = datum.outerRadius + calloutLine.length + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const textAlign = label.collisionTextAlign ?? label.textAlign;
      const textBaseline = label.textBaseline;
      return Text.computeBBox(label.text, x, y, {
        font: this.properties.calloutLabel,
        textAlign,
        textBaseline
      });
    };
    const avoidNeighbourYCollision = (label, next, direction) => {
      const box = getTextBBox(label).grow(minSpacing / 2);
      const other = getTextBBox(next).grow(minSpacing / 2);
      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === "to-top" ? box.y < other.y + other.height : box.y + box.height > other.y);
      if (collidesOrBehind) {
        const dy = direction === "to-top" ? box.y - other.y - other.height : box.y + box.height - other.y;
        next.calloutLabel.collisionOffsetY = dy;
      }
    };
    const avoidYCollisions = (labels) => {
      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];
      const midIndex = labels.indexOf(midLabel);
      for (let i = midIndex - 1; i >= 0; i--) {
        const prev = labels[i + 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-top");
      }
      for (let i = midIndex + 1; i < labels.length; i++) {
        const prev = labels[i - 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-bottom");
      }
    };
    const avoidXCollisions = (labels) => {
      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);
      const boxes = labels.map((label) => getTextBBox(label));
      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));
      let labelsCollideLabelsByX = false;
      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {
        const box = paddedBoxes[i];
        for (let j = i + 1; j < labels.length; j++) {
          const other = paddedBoxes[j];
          if (box.collidesBBox(other)) {
            labelsCollideLabelsByX = true;
            break;
          }
        }
      }
      const sectors = fullData.map((datum) => {
        const { startAngle, endAngle, outerRadius } = datum;
        return { startAngle, endAngle, innerRadius, outerRadius };
      });
      const labelsCollideSectors = boxes.some((box) => {
        return sectors.some((sector) => boxCollidesSector(box, sector));
      });
      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {
        return;
      }
      labels.filter((d) => d.calloutLabel.textAlign === "center").forEach((d) => {
        const label = d.calloutLabel;
        if (d.midCos < 0) {
          label.collisionTextAlign = "right";
        } else if (d.midCos > 0) {
          label.collisionTextAlign = "left";
        } else {
          label.collisionTextAlign = "center";
        }
      });
    };
    avoidYCollisions(leftLabels);
    avoidYCollisions(rightLabels);
    avoidXCollisions(topLabels);
    avoidXCollisions(bottomLabels);
  }
  updateCalloutLabelNodes(seriesRect) {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const { offset: offset4, color } = calloutLabel;
    const tempTextNode = new Text();
    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {
      const { datum } = text;
      const label = datum.calloutLabel;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      if (!label?.text || outerRadius === 0 || label.hidden) {
        text.visible = false;
        return;
      }
      const labelRadius = outerRadius + calloutLength + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const align = {
        textAlign: label.collisionTextAlign ?? label.textAlign,
        textBaseline: label.textBaseline
      };
      tempTextNode.text = label.text;
      tempTextNode.x = x;
      tempTextNode.y = y;
      tempTextNode.setFont(this.properties.calloutLabel);
      tempTextNode.setAlign(align);
      const box = tempTextNode.getBBox();
      let displayText = label.text;
      let visible = true;
      if (calloutLabel.avoidCollisions) {
        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);
        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\u2026`;
        visible = !hasVerticalOverflow;
      }
      text.text = displayText;
      text.x = x;
      text.y = y;
      text.setFont(this.properties.calloutLabel);
      text.setAlign(align);
      text.fill = color;
      text.visible = visible;
    });
  }
  async computeLabelsBBox(options, seriesRect) {
    const { calloutLabel, calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;
    if (!calloutLabel.avoidCollisions) {
      return null;
    }
    await this.maybeRefreshNodeData();
    this.updateRadiusScale(false);
    this.computeCalloutLabelCollisionOffsets();
    const textBoxes = [];
    const text = new Text();
    let titleBox;
    const { title } = this.properties;
    if (title?.text && title.enabled) {
      const dy = this.getTitleTranslationY();
      if (isFinite(dy)) {
        text.text = title.text;
        text.x = 0;
        text.y = dy;
        text.setFont(title);
        text.setAlign({
          textBaseline: "bottom",
          textAlign: "center"
        });
        titleBox = text.getBBox();
        textBoxes.push(titleBox);
      }
    }
    this.calloutNodeData.forEach((datum) => {
      const label = datum.calloutLabel;
      if (!label || datum.outerRadius === 0) {
        return null;
      }
      const labelRadius = datum.outerRadius + calloutLength + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      text.text = label.text;
      text.x = x;
      text.y = y;
      text.setFont(this.properties.calloutLabel);
      text.setAlign({
        textAlign: label.collisionTextAlign ?? label.textAlign,
        textBaseline: label.textBaseline
      });
      const box = text.getBBox();
      label.box = box;
      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {
        label.hidden = true;
        return;
      }
      if (titleBox) {
        const seriesTop = seriesRect.y - this.centerY;
        const titleCleanArea = new BBox(
          titleBox.x - minSpacing,
          seriesTop,
          titleBox.width + 2 * minSpacing,
          titleBox.y + titleBox.height + minSpacing - seriesTop
        );
        if (box.collidesBBox(titleCleanArea)) {
          label.hidden = true;
          return;
        }
      }
      if (options.hideWhenNecessary) {
        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(
          label.text,
          box,
          seriesRect
        );
        const isTooShort = label.text.length > 2 && textLength < 2;
        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {
          label.hidden = true;
          return;
        }
      }
      label.hidden = false;
      textBoxes.push(box);
    });
    if (textBoxes.length === 0) {
      return null;
    }
    return BBox.merge(textBoxes);
  }
  updateSectorLabelNodes() {
    const { radiusScale } = this;
    const innerRadius = radiusScale.convert(0);
    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;
    const updateSectorLabel = (text, datum) => {
      const { sectorLabel, outerRadius } = datum;
      let isTextVisible = false;
      if (sectorLabel && outerRadius !== 0) {
        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;
        text.fill = color;
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontSize = fontSize;
        text.fontFamily = fontFamily;
        text.text = sectorLabel.text;
        text.x = datum.midCos * labelRadius;
        text.y = datum.midSin * labelRadius;
        text.textAlign = "center";
        text.textBaseline = "middle";
        const bbox = text.getBBox();
        const corners = [
          [bbox.x, bbox.y],
          [bbox.x + bbox.width, bbox.y],
          [bbox.x + bbox.width, bbox.y + bbox.height],
          [bbox.x, bbox.y + bbox.height]
        ];
        const { startAngle, endAngle } = datum;
        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };
        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {
          isTextVisible = true;
        }
      }
      text.visible = isTextVisible;
    };
    this.labelSelection.each(updateSectorLabel);
    this.highlightLabelSelection.each(updateSectorLabel);
  }
  updateInnerLabelNodes() {
    const textBBoxes = [];
    const margins = [];
    this.innerLabelsSelection.each((text, datum) => {
      const { fontStyle, fontWeight, fontSize, fontFamily, color } = datum;
      text.fontStyle = fontStyle;
      text.fontWeight = fontWeight;
      text.fontSize = fontSize;
      text.fontFamily = fontFamily;
      text.text = datum.text;
      text.x = 0;
      text.y = 0;
      text.fill = color;
      text.textAlign = "center";
      text.textBaseline = "alphabetic";
      textBBoxes.push(text.getBBox());
      margins.push(datum.spacing);
    });
    const getMarginTop = (index) => index === 0 ? 0 : margins[index];
    const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];
    const totalHeight = textBBoxes.reduce((sum, bbox, i) => {
      return sum + bbox.height + getMarginTop(i) + getMarginBottom(i);
    }, 0);
    const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));
    const innerRadius = this.getInnerRadius();
    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));
    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());
    const textBottoms = [];
    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {
      const bbox = textBBoxes[i];
      const bottom = bbox.height + prev + getMarginTop(i);
      textBottoms.push(bottom);
      prev = bottom + getMarginBottom(i);
    }
    this.innerLabelsSelection.each((text, _datum, index) => {
      text.y = textBottoms[index];
      text.visible = labelsVisible;
    });
  }
  updateZerosumRings() {
    this.zerosumOuterRing.size = this.getOuterRadius() * 2;
    this.zerosumInnerRing.size = this.getInnerRadius() * 2;
  }
  getDatumLegendName(nodeDatum) {
    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;
    if (legendItemKey && legendItem !== void 0) {
      return legendItem.text;
    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {
      return calloutLabel.text;
    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {
      return sectorLabel.text;
    }
  }
  pickNodeClosestDatum(point) {
    return pickByMatchingAngle(this, point);
  }
  getTooltipHtml(nodeDatum) {
    if (!this.properties.isValid()) {
      return EMPTY_TOOLTIP_CONTENT;
    }
    const {
      datum,
      angleValue,
      sectorFormat: { fill: color },
      itemId
    } = nodeDatum;
    const title = sanitizeHtml(this.properties.title?.text);
    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);
    const labelText = this.getDatumLegendName(nodeDatum);
    return this.properties.tooltip.toTooltipHtml(
      {
        title: title ?? labelText,
        content: title && labelText ? `${labelText}: ${content}` : content,
        backgroundColor: color
      },
      {
        datum,
        itemId,
        title,
        color,
        seriesId: this.id,
        angleKey: this.properties.angleKey,
        angleName: this.properties.angleName,
        radiusKey: this.properties.radiusKey,
        radiusName: this.properties.radiusName,
        calloutLabelKey: this.properties.calloutLabelKey,
        calloutLabelName: this.properties.calloutLabelName,
        sectorLabelKey: this.properties.sectorLabelKey,
        sectorLabelName: this.properties.sectorLabelName,
        legendItemKey: this.properties.legendItemKey
      }
    );
  }
  getLegendData(legendType) {
    const { visible, processedData, dataModel } = this;
    if (!dataModel || !processedData?.data.length || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey))
      return [];
    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);
    const titleText = this.properties.title?.showInLegend && this.properties.title.text;
    const legendData = [];
    for (let index = 0; index < processedData.data.length; index++) {
      const { datum, values } = processedData.data[index];
      const labelParts = [];
      if (titleText) {
        labelParts.push(titleText);
      }
      const labels = this.getLabels(
        datum,
        2 * Math.PI,
        2 * Math.PI,
        false,
        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,
        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,
        legendItemIdx != null ? values[legendItemIdx] : void 0
      );
      if (legendItemKey && labels.legendItem !== void 0) {
        labelParts.push(labels.legendItem.text);
      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {
        labelParts.push(labels.calloutLabel?.text);
      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {
        labelParts.push(labels.sectorLabel?.text);
      }
      if (labelParts.length === 0)
        continue;
      const sectorFormat = this.getSectorFormat(datum, index, false);
      legendData.push({
        legendType: "category",
        id: this.id,
        itemId: index,
        seriesId: this.id,
        enabled: visible && this.legendItemEnabled[index],
        label: {
          text: labelParts.join(" - ")
        },
        symbols: [
          {
            marker: {
              fill: sectorFormat.fill,
              stroke: sectorFormat.stroke,
              fillOpacity: this.properties.fillOpacity,
              strokeOpacity: this.properties.strokeOpacity,
              strokeWidth: this.properties.strokeWidth
            }
          }
        ],
        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0
      });
    }
    return legendData;
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series, legendItemName } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    } else if (legendItemName != null) {
      this.toggleOtherSeriesItems(legendItemName, enabled);
    }
  }
  toggleSeriesItem(itemId, enabled) {
    this.seriesItemEnabled[itemId] = enabled;
    this.legendItemEnabled[itemId] = enabled;
    if (this.nodeData[itemId]) {
      this.nodeData[itemId].enabled = enabled;
    }
    this.nodeDataRefresh = true;
  }
  // Used for grid
  setLegendState(enabledItems) {
    this.legendItemEnabled = enabledItems;
    this.ctx.updateService.update(4 /* SERIES_UPDATE */);
  }
  toggleOtherSeriesItems(legendItemName, enabled) {
    if (!this.properties.legendItemKey || !this.dataModel) {
      return;
    }
    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);
    this.processedData?.data.forEach(({ values }, datumItemId) => {
      if (values[legendItemIdx] === legendItemName) {
        this.toggleSeriesItem(datumItemId, enabled);
      }
    });
  }
  animateEmptyUpdateReady(_data) {
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      true,
      this.properties.rotation,
      this.radiusScale,
      this.previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [this.itemSelection, this.highlightSelection, this.phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum)
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeInAnimation(this, "callout", animationManager, this.calloutLabelSelection);
    seriesLabelFadeInAnimation(this, "sector", animationManager, this.labelSelection);
    seriesLabelFadeInAnimation(this, "highlight", animationManager, this.highlightLabelSelection);
    seriesLabelFadeInAnimation(this, "inner", animationManager, this.innerLabelsSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateWaitingUpdateReady() {
    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const dataDiff = processedData?.reduced?.diff;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;
    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;
    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;
    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {
      this.ctx.animationManager.skipCurrentBatch();
    }
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection, phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum),
      dataDiff
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeInAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
    seriesLabelFadeInAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
    seriesLabelFadeInAnimation(this, "highlight", this.ctx.animationManager, this.highlightLabelSelection);
    seriesLabelFadeInAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateClearingUpdateEmpty() {
    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection, phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum)
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeOutAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
    seriesLabelFadeOutAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
    seriesLabelFadeOutAnimation(this, "highlight", this.ctx.animationManager, this.highlightLabelSelection);
    seriesLabelFadeOutAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  getDatumIdFromData(datum) {
    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {
      return;
    }
    if (legendItemKey) {
      return datum[legendItemKey];
    } else if (calloutLabelKey) {
      return datum[calloutLabelKey];
    } else if (sectorLabelKey) {
      return datum[sectorLabelKey];
    }
  }
  getDatumId(datum) {
    const { index } = datum;
    const datumId = this.getDatumIdFromData(datum.datum);
    return datumId != null ? String(datumId) : `${index}`;
  }
  onDataChange() {
    const { data, seriesItemEnabled, legendItemEnabled } = this;
    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];
    this.legendItemEnabled = data?.map((_, index) => legendItemEnabled[index] ?? true) ?? [];
  }
};
DonutSeries.className = "DonutSeries";
DonutSeries.type = "donut";

// packages/ag-charts-community/src/chart/series/polar/donutTheme.ts
var donutTheme = {
  series: {
    title: {
      enabled: true,
      fontWeight: "normal" /* NORMAL */,
      fontSize: 14,
      fontFamily: DEFAULT_FONT_FAMILY,
      color: DEFAULT_MUTED_LABEL_COLOUR,
      spacing: 5
    },
    calloutLabel: {
      enabled: true,
      fontSize: 12 /* SMALL */,
      fontFamily: DEFAULT_FONT_FAMILY,
      color: DEFAULT_LABEL_COLOUR,
      offset: 3,
      minAngle: 0
    },
    sectorLabel: {
      enabled: true,
      fontWeight: "normal" /* NORMAL */,
      fontSize: 12 /* SMALL */,
      fontFamily: DEFAULT_FONT_FAMILY,
      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
      positionOffset: 0,
      positionRatio: 0.5
    },
    calloutLine: {
      length: 10,
      strokeWidth: 2
    },
    fillOpacity: 1,
    strokeOpacity: 1,
    strokeWidth: 0,
    lineDash: [0],
    lineDashOffset: 0,
    rotation: 0,
    sectorSpacing: 1,
    shadow: {
      enabled: false,
      color: DEFAULT_SHADOW_COLOUR,
      xOffset: 3,
      yOffset: 3,
      blur: 5
    },
    innerLabels: {
      fontSize: 12 /* SMALL */,
      fontFamily: DEFAULT_FONT_FAMILY,
      color: DEFAULT_LABEL_COLOUR,
      spacing: 2
    }
  }
};

// packages/ag-charts-community/src/chart/series/polar/pieTheme.ts
var pieTheme = {
  series: {
    title: {
      enabled: true,
      fontWeight: "normal" /* NORMAL */,
      fontSize: 14,
      fontFamily: DEFAULT_FONT_FAMILY,
      color: DEFAULT_MUTED_LABEL_COLOUR,
      spacing: 5
    },
    calloutLabel: {
      enabled: true,
      fontSize: 12 /* SMALL */,
      fontFamily: DEFAULT_FONT_FAMILY,
      color: DEFAULT_LABEL_COLOUR,
      offset: 3,
      minAngle: 0
    },
    sectorLabel: {
      enabled: true,
      fontWeight: "normal" /* NORMAL */,
      fontSize: 12 /* SMALL */,
      fontFamily: DEFAULT_FONT_FAMILY,
      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
      positionOffset: 0,
      positionRatio: 0.5
    },
    calloutLine: {
      length: 10,
      strokeWidth: 2
    },
    fillOpacity: 1,
    strokeOpacity: 1,
    strokeWidth: 0,
    lineDash: [0],
    lineDashOffset: 0,
    rotation: 0,
    sectorSpacing: 1,
    shadow: {
      enabled: false,
      color: DEFAULT_SHADOW_COLOUR,
      xOffset: 3,
      yOffset: 3,
      blur: 5
    }
  }
};
var piePaletteFactory = ({ takeColors, colorsCount }) => {
  const { fills, strokes } = takeColors(colorsCount);
  return { fills, strokes, calloutLine: { colors: strokes } };
};

// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts
var DonutSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["polar"],
  identifier: "donut",
  moduleFactory: (ctx) => new DonutSeries(ctx),
  tooltipDefaults: { range: "exact" },
  themeTemplate: donutTheme,
  paletteFactory: piePaletteFactory
};

// packages/ag-charts-community/src/chart/series/polar/pieSeriesProperties.ts
var PieTitle = class extends Caption {
  constructor() {
    super(...arguments);
    this.showInLegend = false;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], PieTitle.prototype, "showInLegend", 2);
var PieSeriesCalloutLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.offset = 3;
    this.minAngle = 0;
    this.minSpacing = 4;
    this.maxCollisionOffset = 50;
    this.avoidCollisions = true;
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesCalloutLabel.prototype, "offset", 2);
__decorateClass([
  Validate(DEGREE)
], PieSeriesCalloutLabel.prototype, "minAngle", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesCalloutLabel.prototype, "minSpacing", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesCalloutLabel.prototype, "maxCollisionOffset", 2);
__decorateClass([
  Validate(BOOLEAN)
], PieSeriesCalloutLabel.prototype, "avoidCollisions", 2);
var PieSeriesSectorLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.positionOffset = 0;
    this.positionRatio = 0.5;
  }
};
__decorateClass([
  Validate(NUMBER)
], PieSeriesSectorLabel.prototype, "positionOffset", 2);
__decorateClass([
  Validate(RATIO)
], PieSeriesSectorLabel.prototype, "positionRatio", 2);
var PieSeriesCalloutLine = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.length = 10;
    this.strokeWidth = 1;
  }
};
__decorateClass([
  Validate(COLOR_STRING_ARRAY, { optional: true })
], PieSeriesCalloutLine.prototype, "colors", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesCalloutLine.prototype, "length", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesCalloutLine.prototype, "strokeWidth", 2);
var PieSeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.fills = Object.values(DEFAULT_FILLS);
    this.strokes = Object.values(DEFAULT_STROKES);
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.rotation = 0;
    this.outerRadiusOffset = 0;
    this.outerRadiusRatio = 1;
    this.strokeWidth = 1;
    this.sectorSpacing = 0;
    this.title = new PieTitle();
    this.shadow = new DropShadow();
    this.calloutLabel = new PieSeriesCalloutLabel();
    this.sectorLabel = new PieSeriesSectorLabel();
    this.calloutLine = new PieSeriesCalloutLine();
    this.tooltip = new SeriesTooltip();
  }
};
__decorateClass([
  Validate(STRING)
], PieSeriesProperties.prototype, "angleKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "angleName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "angleFilterKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "radiusKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "radiusName", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], PieSeriesProperties.prototype, "radiusMin", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], PieSeriesProperties.prototype, "radiusMax", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "calloutLabelKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "calloutLabelName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "sectorLabelKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "sectorLabelName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "legendItemKey", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], PieSeriesProperties.prototype, "fills", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], PieSeriesProperties.prototype, "strokes", 2);
__decorateClass([
  Validate(RATIO)
], PieSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(RATIO)
], PieSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH)
], PieSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], PieSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Validate(DEGREE)
], PieSeriesProperties.prototype, "rotation", 2);
__decorateClass([
  Validate(NUMBER)
], PieSeriesProperties.prototype, "outerRadiusOffset", 2);
__decorateClass([
  Validate(RATIO)
], PieSeriesProperties.prototype, "outerRadiusRatio", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(NUMBER)
], PieSeriesProperties.prototype, "sectorSpacing", 2);
__decorateClass([
  Validate(OBJECT)
], PieSeriesProperties.prototype, "title", 2);
__decorateClass([
  Validate(OBJECT)
], PieSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Validate(OBJECT)
], PieSeriesProperties.prototype, "calloutLabel", 2);
__decorateClass([
  Validate(OBJECT)
], PieSeriesProperties.prototype, "sectorLabel", 2);
__decorateClass([
  Validate(OBJECT)
], PieSeriesProperties.prototype, "calloutLine", 2);
__decorateClass([
  Validate(OBJECT)
], PieSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts
var PieSeriesNodeEvent = class extends SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
    this.calloutLabelKey = series.properties.calloutLabelKey;
    this.sectorLabelKey = series.properties.sectorLabelKey;
  }
};
var PieSeries = class extends PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
      useLabelLayer: true,
      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }
    });
    this.properties = new PieSeriesProperties();
    this.phantomNodeData = void 0;
    this.previousRadiusScale = new LinearScale();
    this.radiusScale = new LinearScale();
    this.phantomGroup = this.contentGroup.appendChild(new Group());
    this.phantomSelection = Selection.select(
      this.phantomGroup,
      () => this.nodeFactory(),
      false
    );
    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: "pieCalloutLabels" }));
    this.calloutLabelSelection = new Selection(
      this.calloutLabelGroup,
      Group
    );
    // The group node that contains the background graphics.
    this.backgroundGroup = this.rootGroup.appendChild(
      new TranslatableLayer({
        name: `${this.id}-background`,
        zIndex: 0 /* SERIES_BACKGROUND */
      })
    );
    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.
    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));
    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());
    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.
    this.seriesItemEnabled = [];
    this.legendItemEnabled = [];
    this.surroundingRadius = void 0;
    this.NodeEvent = PieSeriesNodeEvent;
    this.angleScale = new LinearScale();
    this.angleScale.domain = [0, 1];
    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);
    this.phantomGroup.opacity = 0.2;
    this.phantomGroup.zIndexSubOrder = [() => this._declarationOrder, 0];
  }
  get calloutNodeData() {
    return this.phantomNodeData ?? this.nodeData;
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager?.addListener("legend-item-click", (event) => this.onLegendItemClick(event))
    );
  }
  get visible() {
    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.includes(true));
  }
  nodeFactory() {
    const sector = new Sector();
    sector.miterLimit = 1e9;
    return sector;
  }
  getSeriesDomain(direction) {
    if (direction === "x" /* X */) {
      return this.angleScale.domain;
    } else {
      return this.radiusScale.domain;
    }
  }
  async processData(dataController) {
    if (this.data == null || !this.properties.isValid()) {
      return;
    }
    let { data } = this;
    const { visible, seriesItemEnabled } = this;
    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const extraKeyProps = [];
    const extraProps = [];
    if (legendItemKey) {
      extraKeyProps.push(keyProperty(legendItemKey, "band", { id: `legendItemKey` }));
    } else if (calloutLabelKey) {
      extraKeyProps.push(keyProperty(calloutLabelKey, "band", { id: `calloutLabelKey` }));
    } else if (sectorLabelKey) {
      extraKeyProps.push(keyProperty(sectorLabelKey, "band", { id: `sectorLabelKey` }));
    }
    const radiusScaleType = this.radiusScale.type;
    const angleScaleType = this.radiusScale.type;
    if (radiusKey) {
      extraProps.push(
        rangedValueProperty(radiusKey, {
          id: "radiusValue",
          min: this.properties.radiusMin ?? 0,
          max: this.properties.radiusMax
        }),
        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),
        // Raw value pass-through.
        normalisePropertyTo("radiusValue", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)
      );
    }
    if (calloutLabelKey) {
      extraProps.push(valueProperty(calloutLabelKey, "band", { id: `calloutLabelValue` }));
    }
    if (sectorLabelKey) {
      extraProps.push(valueProperty(sectorLabelKey, "band", { id: `sectorLabelValue` }));
    }
    if (legendItemKey) {
      extraProps.push(valueProperty(legendItemKey, "band", { id: `legendItemValue` }));
    }
    if (angleFilterKey) {
      extraProps.push(
        accumulativeValueProperty(angleFilterKey, angleScaleType, {
          id: `angleFilterValue`,
          onlyPositive: true
        }),
        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),
        normalisePropertyTo("angleFilterValue", [0, 1], 0, 0)
      );
    }
    if (animationEnabled && this.processedData?.reduced?.animationValidation?.uniqueKeys && extraKeyProps.length > 0) {
      extraProps.push(diff(this.processedData));
    }
    extraProps.push(animationValidation());
    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });
    await this.requestDataModel(dataController, data, {
      props: [
        ...extraKeyProps,
        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),
        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),
        // Raw value pass-through.
        normalisePropertyTo("angleValue", [0, 1], 0, 0),
        ...extraProps
      ]
    });
    for (const valueDef of this.processedData?.defs?.values ?? []) {
      const { id, missing, property } = valueDef;
      const missCount = getMissCount(this, missing);
      if (id !== "angleRaw" && missCount > 0) {
        Logger.warnOnce(
          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? "s" : ""}`
        );
      }
    }
    this.animationState.transition("updateData");
  }
  async maybeRefreshNodeData() {
    if (!this.nodeDataRefresh)
      return;
    const { nodeData = [], phantomNodeData } = await this.createNodeData() ?? {};
    this.nodeData = nodeData;
    this.phantomNodeData = phantomNodeData;
    this.nodeDataRefresh = false;
  }
  getProcessedDataIndexes(dataModel) {
    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);
    const angleRawIdx = dataModel.resolveProcessedDataIndexById(this, `angleRaw`);
    const angleFilterIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterValue`) : void 0;
    const angleFilterRawIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterRaw`) : void 0;
    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : void 0;
    const radiusRawIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusRaw`) : void 0;
    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : void 0;
    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : void 0;
    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : void 0;
    return {
      angleIdx,
      angleRawIdx,
      angleFilterIdx,
      angleFilterRawIdx,
      radiusIdx,
      radiusRawIdx,
      calloutLabelIdx,
      sectorLabelIdx,
      legendItemIdx
    };
  }
  async createNodeData() {
    const { id: seriesId, processedData, dataModel, angleScale } = this;
    const { rotation } = this.properties;
    if (!processedData || !dataModel || processedData.type !== "ungrouped")
      return;
    const {
      angleIdx,
      angleRawIdx,
      angleFilterIdx,
      angleFilterRawIdx,
      radiusIdx,
      radiusRawIdx,
      calloutLabelIdx,
      sectorLabelIdx,
      legendItemIdx
    } = this.getProcessedDataIndexes(dataModel);
    const useFilterAngles = angleFilterRawIdx != null && processedData.data.some(({ values }) => {
      return values[angleFilterRawIdx] > values[angleRawIdx];
    });
    let currentStart = 0;
    let sum = 0;
    const nodes = [];
    const phantomNodes = angleFilterRawIdx != null ? [] : void 0;
    processedData.data.forEach((group, index) => {
      const { datum, values } = group;
      const currentValue = useFilterAngles ? values[angleFilterIdx] : values[angleIdx];
      const crossFilterScale = angleFilterRawIdx != null && !useFilterAngles ? Math.sqrt(values[angleFilterRawIdx] / values[angleRawIdx]) : 1;
      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);
      currentStart = currentValue;
      sum += currentValue;
      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);
      const span = Math.abs(endAngle - startAngle);
      const midAngle = startAngle + span / 2;
      const angleValue = values[angleRawIdx];
      const radiusRaw = radiusIdx != null ? values[radiusIdx] ?? 1 : 1;
      const radius = radiusRaw * crossFilterScale;
      const radiusValue = radiusRawIdx != null ? values[radiusRawIdx] : void 0;
      const legendItemValue = legendItemIdx != null ? values[legendItemIdx] : void 0;
      const nodeLabels = this.getLabels(
        datum,
        midAngle,
        span,
        true,
        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,
        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,
        legendItemValue
      );
      const sectorFormat = this.getSectorFormat(datum, index, false);
      const node = {
        itemId: index,
        series: this,
        datum,
        index,
        angleValue,
        midAngle,
        midCos: Math.cos(midAngle),
        midSin: Math.sin(midAngle),
        startAngle,
        endAngle,
        radius,
        innerRadius: Math.max(this.radiusScale.convert(0), 0),
        outerRadius: Math.max(this.radiusScale.convert(radius), 0),
        sectorFormat,
        radiusValue,
        legendItemValue,
        enabled: this.seriesItemEnabled[index],
        ...nodeLabels
      };
      nodes.push(node);
      if (phantomNodes != null) {
        phantomNodes.push({
          ...node,
          radius: 1,
          innerRadius: Math.max(this.radiusScale.convert(0), 0),
          outerRadius: Math.max(this.radiusScale.convert(1), 0)
        });
      }
    });
    this.zerosumOuterRing.visible = sum === 0;
    return {
      itemId: seriesId,
      nodeData: nodes,
      labelData: nodes,
      phantomNodeData: phantomNodes
    };
  }
  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {
    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;
    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;
    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;
    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {
      return {};
    }
    const labelFormatterParams = {
      datum,
      angleKey: this.properties.angleKey,
      angleName: this.properties.angleName,
      radiusKey: this.properties.radiusKey,
      radiusName: this.properties.radiusName,
      calloutLabelKey: this.properties.calloutLabelKey,
      calloutLabelName: this.properties.calloutLabelName,
      sectorLabelKey: this.properties.sectorLabelKey,
      sectorLabelName: this.properties.sectorLabelName,
      legendItemKey: this.properties.legendItemKey
    };
    const result = {};
    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {
      result.calloutLabel = {
        ...this.getTextAlignment(midAngle),
        text: this.getLabelText(calloutLabel, {
          ...labelFormatterParams,
          value: calloutLabelValue
        }),
        hidden: false,
        collisionTextAlign: void 0,
        collisionOffsetY: 0,
        box: void 0
      };
    }
    if (sectorLabelKey) {
      result.sectorLabel = {
        text: this.getLabelText(sectorLabel, {
          ...labelFormatterParams,
          value: sectorLabelValue
        })
      };
    }
    if (legendItemKey != null && legendItemValue != null) {
      result.legendItem = { key: legendItemKey, text: legendItemValue };
    }
    return result;
  }
  getTextAlignment(midAngle) {
    const quadrantTextOpts = [
      { textAlign: "center", textBaseline: "bottom" },
      { textAlign: "left", textBaseline: "middle" },
      { textAlign: "center", textBaseline: "hanging" },
      { textAlign: "right", textBaseline: "middle" }
    ];
    const midAngle180 = normalizeAngle180(midAngle);
    const quadrantStart = -0.75 * Math.PI;
    const quadrantOffset = midAngle180 - quadrantStart;
    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));
    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);
    return quadrantTextOpts[quadrantIndex];
  }
  getSectorFormat(datum, formatIndex, highlighted) {
    const { callbackCache } = this.ctx;
    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;
    const defaultStroke = strokes[formatIndex % strokes.length];
    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(
      highlighted && this.properties.highlightStyle.item,
      {
        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,
        stroke: defaultStroke,
        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),
        strokeOpacity: this.getOpacity()
      },
      this.properties
    );
    let format;
    if (itemStyler) {
      format = callbackCache.call(itemStyler, {
        datum,
        angleKey,
        radiusKey,
        calloutLabelKey,
        sectorLabelKey,
        legendItemKey,
        fill,
        strokeOpacity,
        stroke,
        strokeWidth,
        fillOpacity,
        lineDash,
        lineDashOffset,
        cornerRadius,
        highlighted,
        seriesId: this.id
      });
    }
    return {
      fill: format?.fill ?? fill,
      fillOpacity: format?.fillOpacity ?? fillOpacity,
      stroke: format?.stroke ?? stroke,
      strokeWidth: format?.strokeWidth ?? strokeWidth,
      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,
      lineDash: format?.lineDash ?? lineDash,
      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,
      cornerRadius: format?.cornerRadius ?? cornerRadius
    };
  }
  getOuterRadius() {
    return Math.max(this.radius * this.properties.outerRadiusRatio + this.properties.outerRadiusOffset, 0);
  }
  updateRadiusScale(resize) {
    const newRange = [0, this.getOuterRadius()];
    this.radiusScale.range = newRange;
    if (resize) {
      this.previousRadiusScale.range = newRange;
    }
    const setRadii = (d) => ({
      ...d,
      innerRadius: Math.max(this.radiusScale.convert(0), 0),
      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)
    });
    this.nodeData = this.nodeData.map(setRadii);
    this.phantomNodeData = this.phantomNodeData?.map(setRadii);
  }
  getTitleTranslationY() {
    const outerRadius = Math.max(0, this.radiusScale.range[1]);
    if (outerRadius === 0) {
      return NaN;
    }
    const spacing = this.properties.title?.spacing ?? 0;
    const titleOffset = 2 + spacing;
    const dy = Math.max(0, -outerRadius);
    return -outerRadius - titleOffset - dy;
  }
  async update({ seriesRect }) {
    const { title } = this.properties;
    const newNodeDataDependencies = {
      seriesRectWidth: seriesRect?.width,
      seriesRectHeight: seriesRect?.height
    };
    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
    if (resize) {
      this._nodeDataDependencies = newNodeDataDependencies;
    }
    await this.maybeRefreshNodeData();
    this.updateTitleNodes();
    this.updateRadiusScale(resize);
    this.contentGroup.translationX = this.centerX;
    this.contentGroup.translationY = this.centerY;
    this.highlightGroup.translationX = this.centerX;
    this.highlightGroup.translationY = this.centerY;
    this.backgroundGroup.translationX = this.centerX;
    this.backgroundGroup.translationY = this.centerY;
    if (this.labelGroup) {
      this.labelGroup.translationX = this.centerX;
      this.labelGroup.translationY = this.centerY;
    }
    if (title) {
      const dy = this.getTitleTranslationY();
      title.node.y = isFinite(dy) ? dy : 0;
      const titleBox = title.node.getBBox();
      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox);
    }
    this.zerosumOuterRing.fillOpacity = 0;
    this.zerosumOuterRing.stroke = this.properties.calloutLabel.color;
    this.zerosumOuterRing.strokeWidth = 1;
    this.zerosumOuterRing.strokeOpacity = 1;
    this.updateNodeMidPoint();
    await this.updateSelections();
    await this.updateNodes(seriesRect);
  }
  updateTitleNodes() {
    const { oldTitle } = this;
    const { title } = this.properties;
    if (oldTitle !== title) {
      if (oldTitle) {
        this.labelGroup?.removeChild(oldTitle.node);
      }
      if (title) {
        title.node.textBaseline = "bottom";
        this.labelGroup?.appendChild(title.node);
      }
      this.oldTitle = title;
    }
  }
  updateNodeMidPoint() {
    const setMidPoint = (d) => {
      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;
      d.midPoint = {
        x: d.midCos * Math.max(0, radius),
        y: d.midSin * Math.max(0, radius)
      };
    };
    this.nodeData.forEach(setMidPoint);
    this.phantomNodeData?.forEach(setMidPoint);
  }
  async updateSelections() {
    await this.updateGroupSelection();
  }
  async updateGroupSelection() {
    const {
      itemSelection,
      highlightSelection,
      phantomSelection,
      highlightLabelSelection,
      calloutLabelSelection,
      labelSelection
    } = this;
    const highlightedNodeData = this.nodeData.map((datum) => ({
      ...datum,
      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied
      // between normal and highlighted cases.
      sectorFormat: { ...datum.sectorFormat }
    }));
    const update = (selection, nodeData) => {
      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));
      if (this.ctx.animationManager.isSkipped()) {
        selection.cleanup();
      }
    };
    update(itemSelection, this.nodeData);
    update(highlightSelection, highlightedNodeData);
    update(phantomSelection, this.phantomNodeData ?? []);
    calloutLabelSelection.update(this.calloutNodeData, (group) => {
      const line = new Line();
      line.tag = 0 /* Callout */;
      line.pointerEvents = 1 /* None */;
      group.appendChild(line);
      const text = new Text();
      text.tag = 1 /* Label */;
      text.pointerEvents = 1 /* None */;
      group.appendChild(text);
    });
    labelSelection.update(this.nodeData);
    highlightLabelSelection.update(highlightedNodeData);
  }
  async updateNodes(seriesRect) {
    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();
    const isVisible = this.visible && this.seriesItemEnabled.includes(true);
    this.rootGroup.visible = isVisible;
    this.backgroundGroup.visible = isVisible;
    this.contentGroup.visible = isVisible;
    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;
    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;
    if (this.labelGroup) {
      this.labelGroup.visible = isVisible;
    }
    this.contentGroup.opacity = this.getOpacity();
    const animationDisabled = this.ctx.animationManager.isSkipped();
    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {
      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);
      datum.sectorFormat.fill = format.fill;
      datum.sectorFormat.stroke = format.stroke;
      if (animationDisabled) {
        sector.startAngle = datum.startAngle;
        sector.endAngle = datum.endAngle;
        sector.innerRadius = datum.innerRadius;
        sector.outerRadius = datum.outerRadius;
      }
      if (isDatumHighlighted || animationDisabled) {
        sector.fill = format.fill;
        sector.stroke = format.stroke;
      }
      sector.strokeWidth = format.strokeWidth;
      sector.fillOpacity = format.fillOpacity;
      sector.strokeOpacity = format.strokeOpacity;
      sector.lineDash = format.lineDash;
      sector.lineDashOffset = format.lineDashOffset;
      sector.cornerRadius = format.cornerRadius;
      sector.fillShadow = this.properties.shadow;
      const inset = Math.max(
        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,
        0
      );
      sector.inset = inset;
      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? "miter" : "round";
    };
    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
    this.highlightSelection.each((node, datum, index) => {
      updateSectorFn(node, datum, index, true);
      node.visible = datum.itemId === highlightedDatum?.itemId;
    });
    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
    this.updateCalloutLineNodes();
    this.updateCalloutLabelNodes(seriesRect);
    this.updateSectorLabelNodes();
    this.updateZerosumRings();
    this.animationState.transition("update");
  }
  updateCalloutLineNodes() {
    const { calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const calloutStrokeWidth = calloutLine.strokeWidth;
    const calloutColors = calloutLine.colors ?? this.properties.strokes;
    const { offset: offset4 } = this.properties.calloutLabel;
    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {
      const datum = line.datum;
      const { calloutLabel: label, outerRadius } = datum;
      if (label?.text && !label.hidden && outerRadius !== 0) {
        line.visible = true;
        line.strokeWidth = calloutStrokeWidth;
        line.stroke = calloutColors[index % calloutColors.length];
        line.fill = void 0;
        const x1 = datum.midCos * outerRadius;
        const y1 = datum.midSin * outerRadius;
        let x2 = datum.midCos * (outerRadius + calloutLength);
        let y2 = datum.midSin * (outerRadius + calloutLength);
        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;
        if (isMoved && label.box != null) {
          const box = label.box;
          let cx = x2;
          let cy = y2;
          if (x2 < box.x) {
            cx = box.x;
          } else if (x2 > box.x + box.width) {
            cx = box.x + box.width;
          }
          if (y2 < box.y) {
            cy = box.y;
          } else if (y2 > box.y + box.height) {
            cy = box.y + box.height;
          }
          const dx = cx - x2;
          const dy = cy - y2;
          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          const paddedLength = length2 - offset4;
          if (paddedLength > 0) {
            x2 = x2 + dx * paddedLength / length2;
            y2 = y2 + dy * paddedLength / length2;
          }
        }
        line.x1 = x1;
        line.y1 = y1;
        line.x2 = x2;
        line.y2 = y2;
      } else {
        line.visible = false;
      }
    });
  }
  getLabelOverflow(text, box, seriesRect) {
    const seriesLeft = seriesRect.x - this.centerX;
    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;
    const seriesTop = seriesRect.y - this.centerY;
    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;
    const errPx = 1;
    let visibleTextPart = 1;
    if (box.x + errPx < seriesLeft) {
      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;
    } else if (box.x + box.width - errPx > seriesRight) {
      visibleTextPart = (seriesRight - box.x) / box.width;
    }
    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;
    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;
    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);
    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };
  }
  bboxIntersectsSurroundingSeries(box) {
    const { surroundingRadius } = this;
    if (surroundingRadius == null) {
      return false;
    }
    const corners = [
      { x: box.x, y: box.y },
      { x: box.x + box.width, y: box.y },
      { x: box.x + box.width, y: box.y + box.height },
      { x: box.x, y: box.y + box.height }
    ];
    const sur2 = surroundingRadius ** 2;
    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);
  }
  computeCalloutLabelCollisionOffsets() {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const { offset: offset4, minSpacing } = calloutLabel;
    const innerRadius = radiusScale.convert(0);
    const shouldSkip = (datum) => {
      const label = datum.calloutLabel;
      return !label || datum.outerRadius === 0;
    };
    const fullData = this.calloutNodeData;
    const data = fullData.filter((t) => !shouldSkip(t));
    data.forEach((datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return;
      label.hidden = false;
      label.collisionTextAlign = void 0;
      label.collisionOffsetY = 0;
    });
    if (data.length <= 1) {
      return;
    }
    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);
    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);
    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === "center").sort((a, b) => a.midCos - b.midCos);
    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === "center").sort((a, b) => a.midCos - b.midCos);
    const getTextBBox = (datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return BBox.zero.clone();
      const labelRadius = datum.outerRadius + calloutLine.length + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const textAlign = label.collisionTextAlign ?? label.textAlign;
      const textBaseline = label.textBaseline;
      return Text.computeBBox(label.text, x, y, {
        font: this.properties.calloutLabel,
        textAlign,
        textBaseline
      });
    };
    const avoidNeighbourYCollision = (label, next, direction) => {
      const box = getTextBBox(label).grow(minSpacing / 2);
      const other = getTextBBox(next).grow(minSpacing / 2);
      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === "to-top" ? box.y < other.y + other.height : box.y + box.height > other.y);
      if (collidesOrBehind) {
        const dy = direction === "to-top" ? box.y - other.y - other.height : box.y + box.height - other.y;
        next.calloutLabel.collisionOffsetY = dy;
      }
    };
    const avoidYCollisions = (labels) => {
      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];
      const midIndex = labels.indexOf(midLabel);
      for (let i = midIndex - 1; i >= 0; i--) {
        const prev = labels[i + 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-top");
      }
      for (let i = midIndex + 1; i < labels.length; i++) {
        const prev = labels[i - 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-bottom");
      }
    };
    const avoidXCollisions = (labels) => {
      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);
      const boxes = labels.map((label) => getTextBBox(label));
      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));
      let labelsCollideLabelsByX = false;
      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {
        const box = paddedBoxes[i];
        for (let j = i + 1; j < labels.length; j++) {
          const other = paddedBoxes[j];
          if (box.collidesBBox(other)) {
            labelsCollideLabelsByX = true;
            break;
          }
        }
      }
      const sectors = fullData.map((datum) => {
        const { startAngle, endAngle, outerRadius } = datum;
        return { startAngle, endAngle, innerRadius, outerRadius };
      });
      const labelsCollideSectors = boxes.some((box) => {
        return sectors.some((sector) => boxCollidesSector(box, sector));
      });
      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {
        return;
      }
      labels.filter((d) => d.calloutLabel.textAlign === "center").forEach((d) => {
        const label = d.calloutLabel;
        if (d.midCos < 0) {
          label.collisionTextAlign = "right";
        } else if (d.midCos > 0) {
          label.collisionTextAlign = "left";
        } else {
          label.collisionTextAlign = "center";
        }
      });
    };
    avoidYCollisions(leftLabels);
    avoidYCollisions(rightLabels);
    avoidXCollisions(topLabels);
    avoidXCollisions(bottomLabels);
  }
  updateCalloutLabelNodes(seriesRect) {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const { offset: offset4, color } = calloutLabel;
    const tempTextNode = new Text();
    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {
      const { datum } = text;
      const label = datum.calloutLabel;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      if (!label?.text || outerRadius === 0 || label.hidden) {
        text.visible = false;
        return;
      }
      const labelRadius = outerRadius + calloutLength + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const align = {
        textAlign: label.collisionTextAlign ?? label.textAlign,
        textBaseline: label.textBaseline
      };
      tempTextNode.text = label.text;
      tempTextNode.x = x;
      tempTextNode.y = y;
      tempTextNode.setFont(this.properties.calloutLabel);
      tempTextNode.setAlign(align);
      const box = tempTextNode.getBBox();
      let displayText = label.text;
      let visible = true;
      if (calloutLabel.avoidCollisions) {
        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);
        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\u2026`;
        visible = !hasVerticalOverflow;
      }
      text.text = displayText;
      text.x = x;
      text.y = y;
      text.setFont(this.properties.calloutLabel);
      text.setAlign(align);
      text.fill = color;
      text.visible = visible;
    });
  }
  async computeLabelsBBox(options, seriesRect) {
    const { calloutLabel, calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;
    if (!calloutLabel.avoidCollisions) {
      return null;
    }
    await this.maybeRefreshNodeData();
    this.updateRadiusScale(false);
    this.computeCalloutLabelCollisionOffsets();
    const textBoxes = [];
    const text = new Text();
    let titleBox;
    const { title } = this.properties;
    if (title?.text && title.enabled) {
      const dy = this.getTitleTranslationY();
      if (isFinite(dy)) {
        text.text = title.text;
        text.x = 0;
        text.y = dy;
        text.setFont(title);
        text.setAlign({
          textBaseline: "bottom",
          textAlign: "center"
        });
        titleBox = text.getBBox();
        textBoxes.push(titleBox);
      }
    }
    this.calloutNodeData.forEach((datum) => {
      const label = datum.calloutLabel;
      if (!label || datum.outerRadius === 0) {
        return null;
      }
      const labelRadius = datum.outerRadius + calloutLength + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      text.text = label.text;
      text.x = x;
      text.y = y;
      text.setFont(this.properties.calloutLabel);
      text.setAlign({
        textAlign: label.collisionTextAlign ?? label.textAlign,
        textBaseline: label.textBaseline
      });
      const box = text.getBBox();
      label.box = box;
      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {
        label.hidden = true;
        return;
      }
      if (titleBox) {
        const seriesTop = seriesRect.y - this.centerY;
        const titleCleanArea = new BBox(
          titleBox.x - minSpacing,
          seriesTop,
          titleBox.width + 2 * minSpacing,
          titleBox.y + titleBox.height + minSpacing - seriesTop
        );
        if (box.collidesBBox(titleCleanArea)) {
          label.hidden = true;
          return;
        }
      }
      if (options.hideWhenNecessary) {
        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(
          label.text,
          box,
          seriesRect
        );
        const isTooShort = label.text.length > 2 && textLength < 2;
        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {
          label.hidden = true;
          return;
        }
      }
      label.hidden = false;
      textBoxes.push(box);
    });
    if (textBoxes.length === 0) {
      return null;
    }
    return BBox.merge(textBoxes);
  }
  updateSectorLabelNodes() {
    const { radiusScale } = this;
    const innerRadius = radiusScale.convert(0);
    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;
    const isDonut = innerRadius > 0;
    const singleVisibleSector = this.seriesItemEnabled.filter(Boolean).length === 1;
    const updateSectorLabel = (text, datum) => {
      const { sectorLabel, outerRadius, startAngle, endAngle } = datum;
      let isTextVisible = false;
      if (sectorLabel && outerRadius !== 0) {
        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;
        text.fill = color;
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontSize = fontSize;
        text.fontFamily = fontFamily;
        text.text = sectorLabel.text;
        const shouldPutTextInCenter = !isDonut && singleVisibleSector;
        if (shouldPutTextInCenter) {
          text.x = 0;
          text.y = 0;
        } else {
          text.x = datum.midCos * labelRadius;
          text.y = datum.midSin * labelRadius;
        }
        text.textAlign = "center";
        text.textBaseline = "middle";
        const bbox = text.getBBox();
        const corners = [
          [bbox.x, bbox.y],
          [bbox.x + bbox.width, bbox.y],
          [bbox.x + bbox.width, bbox.y + bbox.height],
          [bbox.x, bbox.y + bbox.height]
        ];
        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };
        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {
          isTextVisible = true;
        }
      }
      text.visible = isTextVisible;
    };
    this.labelSelection.each(updateSectorLabel);
    this.highlightLabelSelection.each(updateSectorLabel);
  }
  updateZerosumRings() {
    this.zerosumOuterRing.size = this.getOuterRadius() * 2;
  }
  getDatumLegendName(nodeDatum) {
    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;
    if (legendItemKey && legendItem !== void 0) {
      return legendItem.text;
    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {
      return calloutLabel.text;
    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {
      return sectorLabel.text;
    }
  }
  pickNodeClosestDatum(point) {
    return pickByMatchingAngle(this, point);
  }
  getTooltipHtml(nodeDatum) {
    if (!this.properties.isValid()) {
      return EMPTY_TOOLTIP_CONTENT;
    }
    const {
      datum,
      angleValue,
      sectorFormat: { fill: color },
      itemId
    } = nodeDatum;
    const title = sanitizeHtml(this.properties.title?.text);
    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);
    const labelText = this.getDatumLegendName(nodeDatum);
    return this.properties.tooltip.toTooltipHtml(
      {
        title: title ?? labelText,
        content: title && labelText ? `${labelText}: ${content}` : content,
        backgroundColor: color
      },
      {
        datum,
        itemId,
        title,
        color,
        seriesId: this.id,
        angleKey: this.properties.angleKey,
        angleName: this.properties.angleName,
        radiusKey: this.properties.radiusKey,
        radiusName: this.properties.radiusName,
        calloutLabelKey: this.properties.calloutLabelKey,
        calloutLabelName: this.properties.calloutLabelName,
        sectorLabelKey: this.properties.sectorLabelKey,
        sectorLabelName: this.properties.sectorLabelName,
        legendItemKey: this.properties.legendItemKey
      }
    );
  }
  getLegendData(legendType) {
    const { visible, processedData, dataModel } = this;
    if (!dataModel || !processedData?.data.length || legendType !== "category") {
      return [];
    }
    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {
      return [];
    }
    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);
    const titleText = this.properties.title?.showInLegend && this.properties.title.text;
    const legendData = [];
    for (let index = 0; index < processedData.data.length; index++) {
      const { datum, values } = processedData.data[index];
      const labelParts = [];
      if (titleText) {
        labelParts.push(titleText);
      }
      const labels = this.getLabels(
        datum,
        2 * Math.PI,
        2 * Math.PI,
        false,
        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,
        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,
        legendItemIdx != null ? values[legendItemIdx] : void 0
      );
      if (legendItemKey && labels.legendItem !== void 0) {
        labelParts.push(labels.legendItem.text);
      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {
        labelParts.push(labels.calloutLabel?.text);
      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {
        labelParts.push(labels.sectorLabel?.text);
      }
      if (labelParts.length === 0)
        continue;
      const sectorFormat = this.getSectorFormat(datum, index, false);
      legendData.push({
        legendType: "category",
        id: this.id,
        itemId: index,
        seriesId: this.id,
        enabled: visible && this.legendItemEnabled[index],
        label: {
          text: labelParts.join(" - ")
        },
        symbols: [
          {
            marker: {
              fill: sectorFormat.fill,
              stroke: sectorFormat.stroke,
              fillOpacity: this.properties.fillOpacity,
              strokeOpacity: this.properties.strokeOpacity,
              strokeWidth: this.properties.strokeWidth
            }
          }
        ],
        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0
      });
    }
    return legendData;
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series, legendItemName } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    } else if (legendItemName != null) {
      this.toggleOtherSeriesItems(legendItemName, enabled);
    }
  }
  toggleSeriesItem(itemId, enabled) {
    this.seriesItemEnabled[itemId] = enabled;
    this.legendItemEnabled[itemId] = enabled;
    if (this.nodeData[itemId]) {
      this.nodeData[itemId].enabled = enabled;
    }
    this.nodeDataRefresh = true;
  }
  // Used for grid
  setLegendState(enabledItems) {
    this.legendItemEnabled = enabledItems;
    this.ctx.updateService.update(4 /* SERIES_UPDATE */);
  }
  toggleOtherSeriesItems(legendItemName, enabled) {
    if (!this.properties.legendItemKey || !this.dataModel) {
      return;
    }
    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);
    this.processedData?.data.forEach(({ values }, datumItemId) => {
      if (values[legendItemIdx] === legendItemName) {
        this.toggleSeriesItem(datumItemId, enabled);
      }
    });
  }
  animateEmptyUpdateReady(_data) {
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      true,
      this.properties.rotation,
      this.radiusScale,
      this.previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [this.itemSelection, this.highlightSelection, this.phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum)
    );
    seriesLabelFadeInAnimation(this, "callout", animationManager, this.calloutLabelSelection);
    seriesLabelFadeInAnimation(this, "sector", animationManager, this.labelSelection);
    seriesLabelFadeInAnimation(this, "highlight", animationManager, this.highlightLabelSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateWaitingUpdateReady() {
    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const dataDiff = processedData?.reduced?.diff;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;
    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;
    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;
    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {
      this.ctx.animationManager.skipCurrentBatch();
    }
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection, phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum),
      dataDiff
    );
    seriesLabelFadeInAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
    seriesLabelFadeInAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
    seriesLabelFadeInAnimation(this, "highlight", this.ctx.animationManager, this.highlightLabelSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateClearingUpdateEmpty() {
    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection, phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum)
    );
    seriesLabelFadeOutAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
    seriesLabelFadeOutAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
    seriesLabelFadeOutAnimation(this, "highlight", this.ctx.animationManager, this.highlightLabelSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  getDatumIdFromData(datum) {
    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {
      return;
    }
    if (legendItemKey) {
      return datum[legendItemKey];
    } else if (calloutLabelKey) {
      return datum[calloutLabelKey];
    } else if (sectorLabelKey) {
      return datum[sectorLabelKey];
    }
  }
  getDatumId(datum) {
    const { index } = datum;
    const datumId = this.getDatumIdFromData(datum.datum);
    return datumId != null ? String(datumId) : `${index}`;
  }
  onDataChange() {
    const { data, seriesItemEnabled, legendItemEnabled } = this;
    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];
    this.legendItemEnabled = data?.map((_, index) => legendItemEnabled[index] ?? true) ?? [];
  }
};
PieSeries.className = "PieSeries";
PieSeries.type = "pie";

// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts
var PieSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["polar"],
  identifier: "pie",
  moduleFactory: (ctx) => new PieSeries(ctx),
  tooltipDefaults: { range: "exact" },
  themeTemplate: pieTheme,
  paletteFactory: piePaletteFactory
};

// packages/ag-charts-community/src/util/vector.ts
var Vec2 = {
  add,
  angle,
  apply,
  equal,
  distance: distance2,
  distanceSquared: distanceSquared2,
  from,
  gradient,
  intercept,
  intersectAtX,
  intersectAtY,
  length,
  lengthSquared,
  multiply,
  normalized,
  origin,
  required,
  rotate,
  round: round3,
  sub
};
function add(a, b) {
  if (typeof b === "number") {
    return { x: a.x + b, y: a.y + b };
  }
  return { x: a.x + b.x, y: a.y + b.y };
}
function sub(a, b) {
  if (typeof b === "number") {
    return { x: a.x - b, y: a.y - b };
  }
  return { x: a.x - b.x, y: a.y - b.y };
}
function multiply(a, b) {
  if (typeof b === "number") {
    return { x: a.x * b, y: a.y * b };
  }
  return { x: a.x * b.x, y: a.y * b.y };
}
function length(a) {
  return Math.sqrt(a.x * a.x + a.y * a.y);
}
function lengthSquared(a) {
  return a.x * a.x + a.y * a.y;
}
function distance2(a, b) {
  const d = sub(a, b);
  return Math.sqrt(d.x * d.x + d.y * d.y);
}
function distanceSquared2(a, b) {
  const d = sub(a, b);
  return d.x * d.x + d.y * d.y;
}
function normalized(a) {
  const l = length(a);
  return { x: a.x / l, y: a.y / l };
}
function angle(a, b = origin()) {
  return Math.atan2(a.y, a.x) - Math.atan2(b.y, b.x);
}
function rotate(a, theta, b = origin()) {
  const l = length(a);
  return { x: b.x + l * Math.cos(theta), y: b.y + l * Math.sin(theta) };
}
function gradient(a, b, reflection) {
  const dx = b.x - a.x;
  const dy = reflection == null ? b.y - a.y : reflection - b.y - (reflection - a.y);
  return dy / dx;
}
function intercept(a, gradient2, reflection) {
  const y = reflection == null ? a.y : reflection - a.y;
  return y - gradient2 * a.x;
}
function intersectAtY(gradient2, coefficient, y = 0, reflection) {
  return {
    x: gradient2 === Infinity ? Infinity : (y - coefficient) / gradient2,
    y: reflection == null ? y : reflection - y
  };
}
function intersectAtX(gradient2, coefficient, x = 0, reflection) {
  const y = gradient2 === Infinity ? Infinity : gradient2 * x + coefficient;
  return { x, y: reflection == null ? y : reflection - y };
}
function round3(a) {
  return { x: Math.round(a.x), y: Math.round(a.y) };
}
function equal(a, b) {
  return a.x === b.x && a.y === b.y;
}
function from(a, b) {
  if (typeof a === "number") {
    return { x: a, y: b };
  }
  if ("regionOffsetX" in a) {
    return { x: a.regionOffsetX, y: a.regionOffsetY };
  }
  if ("offsetWidth" in a) {
    return { x: a.offsetWidth, y: a.offsetHeight };
  }
  if ("width" in a) {
    return [
      { x: a.x, y: a.y },
      { x: a.x + a.width, y: a.y + a.height }
    ];
  }
  if ("x1" in a) {
    return [
      { x: a.x1, y: a.y1 },
      { x: a.x2, y: a.y2 }
    ];
  }
  throw new Error(`Values can not be converted into a vector: [${a}] [${b}]`);
}
function apply(a, b) {
  a.x = b.x;
  a.y = b.y;
  return a;
}
function required(a) {
  return { x: a?.x ?? 0, y: a?.y ?? 0 };
}
function origin() {
  return { x: 0, y: 0 };
}

// packages/ag-charts-types/src/chart/icons.ts
var ICONS_LEGACY = [
  "delete-legacy",
  "disjoint-channel",
  "disjoint-channel-legacy",
  "horizontal-line-legacy",
  "line-color-legacy",
  "lock",
  "lock-legacy",
  "pan-end-legacy",
  "pan-left-legacy",
  "pan-right-legacy",
  "pan-start-legacy",
  "parallel-channel",
  "parallel-channel-legacy",
  "reset-legacy",
  "trend-line",
  "trend-line-legacy",
  "unlock",
  "unlock-legacy",
  "vertical-line",
  "vertical-line-legacy",
  "zoom-in-legacy",
  "zoom-in-alt",
  "zoom-in-alt-legacy",
  "zoom-out-legacy",
  "zoom-out-alt",
  "zoom-out-alt-legacy"
];

// packages/ag-charts-types/src/chart/navigatorOptions.ts
var __MINI_CHART_SERIES_OPTIONS = void 0;
var __VERIFY_MINI_CHART_SERIES_OPTIONS = void 0;
__VERIFY_MINI_CHART_SERIES_OPTIONS = __MINI_CHART_SERIES_OPTIONS;

// packages/ag-charts-types/src/chart/themeOptions.ts
var __THEME_OVERRIDES = void 0;
var __VERIFY_THEME_OVERRIDES = void 0;
__VERIFY_THEME_OVERRIDES = __THEME_OVERRIDES;

// packages/ag-charts-types/src/chart/tooltipOptions.ts
var AgTooltipPositionType = /* @__PURE__ */ ((AgTooltipPositionType2) => {
  AgTooltipPositionType2["POINTER"] = "pointer";
  AgTooltipPositionType2["NODE"] = "node";
  AgTooltipPositionType2["TOP"] = "top";
  AgTooltipPositionType2["RIGHT"] = "right";
  AgTooltipPositionType2["BOTTOM"] = "bottom";
  AgTooltipPositionType2["LEFT"] = "left";
  AgTooltipPositionType2["TOP_LEFT"] = "top-left";
  AgTooltipPositionType2["TOP_RIGHT"] = "top-right";
  AgTooltipPositionType2["BOTTOM_RIGHT"] = "bottom-right";
  AgTooltipPositionType2["BOTTOM_LEFT"] = "bottom-left";
  return AgTooltipPositionType2;
})(AgTooltipPositionType || {});

// packages/ag-charts-types/src/presets/gauge/commonOptions.ts
var __THEMEABLE_OPTIONS = void 0;
var __VERIFY_THEMEABLE_OPTIONS = void 0;
__VERIFY_THEMEABLE_OPTIONS = __THEMEABLE_OPTIONS;
var __AXIS_LABEL_OPTIONS = void 0;
var __VERIFY_AXIS_LABEL_OPTIONS = void 0;
__VERIFY_AXIS_LABEL_OPTIONS = __AXIS_LABEL_OPTIONS;

// packages/ag-charts-community/src/chart/toolbar/toolbarProperties.ts
var ToolbarGroupProperties = class extends BaseProperties {
  constructor(onChange, onButtonsChange) {
    super();
    this.onChange = onChange;
    this.onButtonsChange = onButtonsChange;
    this.align = "start";
    this.position = "top" /* Top */;
    this.size = "normal";
    this.buttonOverrides = /* @__PURE__ */ new Map();
  }
  buttonConfigurations() {
    const buttons = [...this.buttons ?? []];
    if (this.draggable) {
      buttons.unshift({
        icon: "drag-handle",
        tooltip: "toolbarAnnotationsDragHandle",
        value: "drag",
        id: "drag"
      });
    }
    return buttons?.map((button) => {
      const id = button.id ?? button.value;
      const overrides = this.buttonOverrides.get(id);
      return overrides != null ? { ...button, ...overrides } : button;
    }) ?? [];
  }
  buttonsChanged(configurationOnly) {
    this.onButtonsChange(this.buttonConfigurations(), configurationOnly);
  }
  overrideButtonConfiguration(id, options) {
    let overrides = this.buttonOverrides.get(id);
    if (overrides == null) {
      overrides = /* @__PURE__ */ Object.create(null);
      this.buttonOverrides.set(id, overrides);
    }
    for (const key in options) {
      const value = options[key];
      if (value == null) {
        delete overrides[key];
      } else {
        overrides[key] = value;
      }
    }
    this.buttonsChanged(true);
  }
};
__decorateClass([
  ObserveChanges((target) => {
    target.onChange(target.enabled);
  }),
  Validate(BOOLEAN)
], ToolbarGroupProperties.prototype, "enabled", 2);
__decorateClass([
  ObserveChanges((target) => {
    target.onChange(target.enabled);
  }),
  Validate(UNION([...TOOLBAR_ALIGNMENTS]), { optional: true })
], ToolbarGroupProperties.prototype, "align", 2);
__decorateClass([
  ObserveChanges((target) => {
    target.onChange(target.enabled);
  }),
  Validate(UNION(TOOLBAR_POSITIONS), { optional: true })
], ToolbarGroupProperties.prototype, "position", 2);
__decorateClass([
  Validate(BOOLEAN)
], ToolbarGroupProperties.prototype, "draggable", 2);
__decorateClass([
  ObserveChanges((target) => {
    target.onChange(target.enabled);
  }),
  Validate(UNION(["small", "normal"]), { optional: true })
], ToolbarGroupProperties.prototype, "size", 2);
__decorateClass([
  ObserveChanges((target) => {
    for (const button of target.buttons ?? []) {
      if (button.icon != null && ICONS_LEGACY.includes(button.icon)) {
        Logger.warnOnce(`Icon '${button.icon}' is deprecated, use another icon instead.`);
      }
      if (button.ariaLabel === "toolbarAnnotationsColor") {
        Logger.warnOnce(
          `Aria label '${button.ariaLabel}' is deprecated, use 'toolbarAnnotationsLineColor' instead.`
        );
      }
    }
    target.buttonsChanged(false);
  }),
  Validate(ARRAY, { optional: true })
], ToolbarGroupProperties.prototype, "buttons", 2);

// packages/ag-charts-community/src/chart/toolbar/toolbarStyles.ts
var block = "ag-charts-toolbar";
var elements = {
  align: "ag-charts-toolbar__align",
  section: "ag-charts-toolbar__section",
  button: "ag-charts-toolbar__button",
  icon: "ag-charts-toolbar__icon",
  label: "ag-charts-toolbar__label"
};
var modifiers = {
  ["top" /* Top */]: "ag-charts-toolbar--top",
  ["right" /* Right */]: "ag-charts-toolbar--right",
  ["bottom" /* Bottom */]: "ag-charts-toolbar--bottom",
  ["left" /* Left */]: "ag-charts-toolbar--left",
  ["floating" /* Floating */]: "ag-charts-toolbar--floating",
  ["floating-top" /* FloatingTop */]: "ag-charts-toolbar--floating-top",
  ["floating-bottom" /* FloatingBottom */]: "ag-charts-toolbar--floating-bottom",
  small: "ag-charts-toolbar--small",
  normal: "ag-charts-toolbar--normal",
  hidden: "ag-charts-toolbar--hidden",
  preventFlash: "ag-charts-toolbar--prevent-flash",
  floatingHidden: "ag-charts-toolbar--floating-hidden",
  align: {
    start: "ag-charts-toolbar__align--start",
    center: "ag-charts-toolbar__align--center",
    end: "ag-charts-toolbar__align--end"
  },
  button: {
    first: "ag-charts-toolbar__button--first",
    last: "ag-charts-toolbar__button--last",
    active: "ag-charts-toolbar__button--active",
    hiddenValue: "ag-charts-toolbar__button--hidden-value",
    hiddenToggled: "ag-charts-toolbar__button--hidden-toggled",
    fillVisible: "ag-charts-toolbar__button--fill-visible",
    strokeWidthVisible: "ag-charts-toolbar__button--stroke-width-visible",
    withTransition: "ag-charts-toolbar__button--with-transition",
    dragHandle: "ag-charts-toolbar__button--drag-handle",
    dragging: "ag-charts-toolbar__button--dragging"
  }
};

// packages/ag-charts-community/src/chart/toolbar/toolbar.ts
var Toolbar = class extends BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = true;
    this.seriesType = new ToolbarGroupProperties(
      this.onGroupChanged.bind(this, "seriesType"),
      this.onGroupButtonsChanged.bind(this, "seriesType")
    );
    this.annotations = new ToolbarGroupProperties(
      this.onGroupChanged.bind(this, "annotations"),
      this.onGroupButtonsChanged.bind(this, "annotations")
    );
    this.annotationOptions = new ToolbarGroupProperties(
      this.onGroupChanged.bind(this, "annotationOptions"),
      this.onGroupButtonsChanged.bind(this, "annotationOptions")
    );
    this.ranges = new ToolbarGroupProperties(
      this.onGroupChanged.bind(this, "ranges"),
      this.onGroupButtonsChanged.bind(this, "ranges")
    );
    this.zoom = new ToolbarGroupProperties(
      this.onGroupChanged.bind(this, "zoom"),
      this.onGroupButtonsChanged.bind(this, "zoom")
    );
    this.dragState = {
      client: { x: 0, y: 0 },
      position: {
        x: 0,
        y: 0
      },
      detached: false
    };
    this.horizontalSpacing = 10;
    this.verticalSpacing = 10;
    this.floatingDetectionRange = 38;
    this.positions = {
      ["top" /* Top */]: /* @__PURE__ */ new Set(),
      ["left" /* Left */]: /* @__PURE__ */ new Set(),
      ["right" /* Right */]: /* @__PURE__ */ new Set(),
      ["bottom" /* Bottom */]: /* @__PURE__ */ new Set(),
      ["floating" /* Floating */]: /* @__PURE__ */ new Set(),
      ["floating-top" /* FloatingTop */]: /* @__PURE__ */ new Set(),
      ["floating-bottom" /* FloatingBottom */]: /* @__PURE__ */ new Set()
    };
    this.positionAlignments = {
      ["top" /* Top */]: {},
      ["left" /* Left */]: {},
      ["right" /* Right */]: {},
      ["bottom" /* Bottom */]: {},
      ["floating" /* Floating */]: {},
      ["floating-top" /* FloatingTop */]: {},
      ["floating-bottom" /* FloatingBottom */]: {}
    };
    this.groupCallers = {
      seriesType: /* @__PURE__ */ new Set(),
      annotations: /* @__PURE__ */ new Set(),
      annotationOptions: /* @__PURE__ */ new Set(),
      ranges: /* @__PURE__ */ new Set(),
      zoom: /* @__PURE__ */ new Set()
    };
    this.groupButtons = {
      seriesType: [],
      annotations: [],
      annotationOptions: [],
      ranges: [],
      zoom: []
    };
    this.ariaToolbars = [
      { groups: ["seriesType", "annotations"], destroyFns: [], resetListeners: () => {
      } },
      { groups: ["annotationOptions"], destroyFns: [], resetListeners: () => {
      } },
      { groups: ["ranges"], destroyFns: [], resetListeners: () => {
      } },
      { groups: ["zoom"], destroyFns: [], resetListeners: () => {
      } }
    ];
    this.pendingButtonToggledEvents = [];
    this.groupProxied = /* @__PURE__ */ new Map();
    this.hasNewLocale = true;
    this.elements = {};
    for (const position of TOOLBAR_POSITIONS) {
      this.elements[position] = ctx.domManager.addChild("canvas-overlay", `toolbar-${position}`);
      this.elements[position].role = "presentation";
      this.renderToolbar(position);
    }
    this.toggleVisibilities();
    const dragStates = 32 /* Default */ | 8 /* Annotations */;
    const seriesRegion = ctx.regionManager.getRegion("series");
    this.destroyFns.push(
      ctx.interactionManager.addListener("hover", this.onHover.bind(this), 63 /* All */),
      ctx.interactionManager.addListener("leave", this.onLeave.bind(this), 63 /* All */),
      seriesRegion.addListener("drag-start", this.toggleNoPointerEvents.bind(this, true), dragStates),
      seriesRegion.addListener("drag-end", this.toggleNoPointerEvents.bind(this, false), 63 /* All */),
      ctx.toolbarManager.addListener("button-toggled", this.onButtonToggled.bind(this)),
      ctx.toolbarManager.addListener("button-updated", this.onButtonUpdated.bind(this)),
      ctx.toolbarManager.addListener("group-toggled", this.onGroupToggled.bind(this)),
      ctx.toolbarManager.addListener("group-updated", this.onGroupUpdated.bind(this)),
      ctx.toolbarManager.addListener("floating-anchor-changed", this.onFloatingAnchorChanged.bind(this)),
      ctx.toolbarManager.addListener("proxy-group-options", this.onProxyGroupOptions.bind(this)),
      ctx.layoutManager.registerElement(2 /* Toolbar */, this.onLayoutStart.bind(this)),
      ctx.layoutManager.addListener("layout:complete", this.onLayoutComplete.bind(this)),
      ctx.updateService.addListener("pre-dom-update", this.onPreDomUpdate.bind(this)),
      ctx.updateService.addListener("update-complete", this.onUpdateComplete.bind(this)),
      ctx.localeManager.addListener("locale-changed", () => {
        this.hasNewLocale = true;
      }),
      () => this.destroyElements()
    );
  }
  destroyElements() {
    this.ctx.domManager.removeStyles(block);
    for (const element2 of Object.keys(this.elements)) {
      this.ctx.domManager.removeChild("canvas-overlay", `toolbar-${element2}`);
    }
  }
  onHover(event) {
    const {
      enabled,
      elements: elements2,
      floatingDetectionRange,
      ctx: { scene }
    } = this;
    const {
      offsetY,
      sourceEvent: { target }
    } = event;
    const { FloatingBottom, FloatingTop } = ToolbarPosition;
    if (!enabled)
      return;
    const bottom = elements2[FloatingBottom];
    const top = elements2[FloatingTop];
    const bottomDetectionY = bottom.offsetTop - floatingDetectionRange;
    const bottomVisible = offsetY > bottomDetectionY && offsetY < scene.canvas.element.offsetHeight || target === bottom;
    const topDetectionY = top.offsetTop + top.offsetHeight + floatingDetectionRange;
    const topVisible = offsetY > 0 && offsetY < topDetectionY || target === top;
    this.translateFloatingElements(FloatingBottom, bottomVisible);
    this.translateFloatingElements(FloatingTop, topVisible);
  }
  onLeave(event) {
    const {
      enabled,
      ctx: { scene }
    } = this;
    const { relatedElement, targetElement } = event;
    const { FloatingBottom, FloatingTop } = ToolbarPosition;
    if (!enabled || targetElement !== scene.canvas.element)
      return;
    const isTargetButton = TOOLBAR_GROUPS.some(
      (group) => this.groupButtons[group].some((button) => button === relatedElement)
    );
    if (isTargetButton)
      return;
    this.translateFloatingElements(FloatingBottom, false);
    this.translateFloatingElements(FloatingTop, false);
  }
  // AG-12695 Temporarily set `pointer-events: none` on the annotationOptions when dragging, because the
  // buttons block to mouse from hovering over the canvas.
  toggleNoPointerEvents(on) {
    const className = "ag-charts-toolbar__no-pointer-events";
    this.groupButtons["annotationOptions"].forEach((b) => b.classList.toggle(className, on));
  }
  onGroupChanged(group) {
    if (this[group] == null || this.groupProxied.has(group))
      return;
    this.createGroup(group);
    this.toggleVisibilities();
  }
  onGroupButtonsChanged(group, buttons, configurationOnly) {
    if (!this.enabled || this.groupProxied.has(group))
      return;
    if (configurationOnly) {
      for (const buttonOptions of this[group].buttonConfigurations()) {
        this.refreshButtonContent(group, buttonOptions);
      }
    } else {
      this.createGroupButtons(group, buttons);
    }
    this.toggleVisibilities();
  }
  onLayoutComplete(opts) {
    for (const position of TOOLBAR_POSITIONS) {
      this.elements[position].classList.remove(modifiers.preventFlash);
    }
    if (this.enabled) {
      this.refreshInnerLayout(opts.series.rect);
    }
  }
  toggleButtonsTransition(enabled) {
    const className = modifiers.button.withTransition;
    for (const button of Object.values(this.groupButtons).flat()) {
      if (enabled && !button.classList.contains(className)) {
        button.getBoundingClientRect();
      }
      button.classList.toggle(className, enabled);
    }
  }
  onPreDomUpdate() {
    this.toggleButtonsTransition(false);
  }
  onUpdateComplete() {
    this.toggleButtonsTransition(true);
  }
  onButtonUpdated(event) {
    const { type: _type, group, id, ...params } = event;
    this[group].overrideButtonConfiguration(id, params);
  }
  setButtonActive(button, active) {
    button.classList.toggle(modifiers.button.active, active);
  }
  setButtonChecked(button, checked) {
    if (button.role === "switch") {
      button.ariaChecked = checked.toString();
    }
  }
  setButtonGroupFirstLast(group) {
    const childNodes = Array.from(group.childNodes ?? []);
    const setFirstClass = (first2, button, modifier) => {
      const buttonVisible = !button.classList.contains(modifiers.button.hiddenToggled);
      button.classList.toggle(modifier, buttonVisible && first2);
      return buttonVisible ? false : first2;
    };
    let first = true;
    childNodes.forEach((button) => first = setFirstClass(first, button, modifiers.button.first));
    let last = true;
    childNodes.toReversed().forEach((button) => last = setFirstClass(last, button, modifiers.button.last));
  }
  onButtonToggled(event) {
    const { group, id, active, enabled, visible, checked } = event;
    if (this.groupButtons[group].length === 0) {
      this.pendingButtonToggledEvents.push(event);
      return;
    }
    const button = this.groupButtons[group].find((b) => b.dataset.toolbarId === `${id}`);
    if (button == null)
      return;
    button.ariaDisabled = `${!enabled}`;
    button.classList.toggle(modifiers.button.hiddenToggled, !visible);
    this.setButtonActive(button, active);
    this.setButtonChecked(button, checked);
    this.setButtonGroupFirstLast(button.parentNode);
  }
  onGroupToggled(event) {
    const { caller, group, active, visible } = event;
    this.toggleGroup(caller, group, active, visible);
    this.toggleVisibilities();
  }
  onGroupUpdated(event) {
    const { group } = event;
    for (const ariaToolbar of this.ariaToolbars) {
      if (ariaToolbar.groups.includes(group)) {
        ariaToolbar.resetListeners();
        return;
      }
    }
  }
  onFloatingAnchorChanged(event) {
    const { elements: elements2, positions, horizontalSpacing, verticalSpacing } = this;
    const { group, anchor } = event;
    const element2 = elements2["floating" /* Floating */];
    if (this.dragState.detached || element2.classList.contains(modifiers.hidden)) {
      return;
    }
    this.dragState.detached = false;
    if (!positions["floating" /* Floating */].has(group))
      return;
    const position = anchor.position ?? "above";
    const { offsetWidth: width, offsetHeight: height } = element2;
    let top = anchor.y - height - verticalSpacing;
    let left = anchor.x - width / 2;
    if (position === "below") {
      top = anchor.y + verticalSpacing;
    } else if (position === "right") {
      top = anchor.y - height / 2;
      left = anchor.x + horizontalSpacing;
    } else if (position === "above-left") {
      left = anchor.x;
    }
    const groupBBox = new BBox(left, top, width, height);
    this.positionGroup(element2, group, groupBBox);
  }
  positionGroup(element2, group, bbox) {
    const {
      ctx: { domManager }
    } = this;
    const canvasRect = domManager.getBoundingClientRect();
    bbox.x = clamp(0, bbox.x, canvasRect.width - bbox.width);
    bbox.y = clamp(0, bbox.y, canvasRect.height - bbox.height);
    const left = `${Math.floor(bbox.x)}px`;
    const top = `${Math.floor(bbox.y)}px`;
    const dirty = element2.style.getPropertyValue("left") !== left || element2.style.getPropertyValue("top") !== top;
    if (!dirty)
      return;
    element2.style.setProperty("left", left);
    element2.style.setProperty("top", top);
    this.onGroupMoved(group, bbox);
  }
  onGroupMoved(group, bbox) {
    const {
      groupButtons,
      ctx: { toolbarManager }
    } = this;
    for (const button of groupButtons[group]) {
      if (button.classList.contains(modifiers.button.hiddenToggled))
        continue;
      const parent = button.offsetParent;
      toolbarManager.buttonMoved(
        group,
        button.dataset.toolbarId,
        new BBox(
          button.offsetLeft + (parent?.offsetLeft ?? 0),
          button.offsetTop + (parent?.offsetTop ?? 0),
          button.offsetWidth,
          button.offsetHeight
        ),
        bbox
      );
    }
  }
  buttonRect(button, canvasRect = this.ctx.domManager.getBoundingClientRect()) {
    const buttonRect = button.getBoundingClientRect();
    return new BBox(
      buttonRect.left - canvasRect.left,
      buttonRect.top - canvasRect.top,
      buttonRect.width,
      buttonRect.height
    );
  }
  onProxyGroupOptions(event) {
    if (!this.enabled)
      return;
    const { caller, group, options } = event;
    this.groupProxied.set(group, options);
    this[group].set(options);
    this.toggleGroup(caller, group, void 0, options.enabled);
    this.createGroup(group, options.enabled, options.position);
    if (options.enabled) {
      this.createGroupButtons(group, options.buttons);
    }
  }
  createGroup(group, enabled, position) {
    enabled ?? (enabled = this[group].enabled);
    position ?? (position = this[group].position);
    for (const pos of TOOLBAR_POSITIONS) {
      if (enabled && position === pos) {
        this.positions[pos].add(group);
      } else {
        this.positions[pos].delete(group);
      }
    }
  }
  createGroupButtons(group, buttons = []) {
    for (const button of this.groupButtons[group]) {
      button.remove();
    }
    this.groupButtons[group] = [];
    if (buttons.length === 0)
      return;
    const { align, position } = this[group];
    const alignElement = this.positionAlignments[position][align];
    if (!alignElement)
      return;
    const nextSection = (section2) => {
      const alignElementChildren = Array.from(alignElement.children);
      const dataGroup = "data-group";
      const dataSection = "data-section";
      let sectionElement = alignElementChildren.find((prevSection2) => {
        return prevSection2.getAttribute(dataGroup) === group && prevSection2.getAttribute(dataSection) === (section2 ?? "");
      });
      if (!sectionElement) {
        sectionElement = createElement("div");
        sectionElement.role = "presentation";
        sectionElement.setAttribute(dataGroup, group);
        sectionElement.setAttribute(dataSection, section2 ?? "");
        const groupIndex = TOOLBAR_GROUP_ORDERING[group];
        const insertBeforeElement = alignElementChildren.find((prevSection2) => {
          const prevGroup = prevSection2.getAttribute(dataGroup);
          const prevGroupIndex = TOOLBAR_GROUP_ORDERING[prevGroup];
          return prevGroupIndex > groupIndex;
        });
        if (insertBeforeElement != null) {
          alignElement.insertBefore(sectionElement, insertBeforeElement);
        } else {
          alignElement.appendChild(sectionElement);
        }
        this.destroyFns.push(() => sectionElement.remove());
      }
      sectionElement.classList.add(elements.section, modifiers[this[group].size]);
      return sectionElement;
    };
    let prevSection = buttons.at(0)?.section;
    let section = nextSection(prevSection);
    for (const options of buttons) {
      if (prevSection !== options.section) {
        this.setButtonGroupFirstLast(section);
        section = nextSection(options.section);
      }
      prevSection = options.section;
      const button = this.createButtonElement(group, options);
      section.appendChild(button);
      this.groupButtons[group].push(button);
    }
    this.setButtonGroupFirstLast(section);
    const onEscape = () => {
      this.ctx.toolbarManager.cancel(group);
    };
    let onFocus;
    let onBlur;
    if (isAnimatingFloatingPosition(position)) {
      onFocus = () => this.translateFloatingElements(position, true);
      onBlur = () => this.translateFloatingElements(position, false);
    }
    this.createAriaToolbar(group, alignElement, onFocus, onBlur, onEscape);
  }
  createAriaToolbar(group, toolbar, onFocus, onBlur, onEscape) {
    const orientation = this.computeAriaOrientation(this[group].position);
    const ariaToolbar = this.getAriaToolbar(group);
    ariaToolbar.resetListeners = () => {
      const buttons = ariaToolbar.groups.map((g) => this.groupButtons[g]).flat().filter(
        (b) => !b.classList.contains(modifiers.button.hiddenToggled) && !b.classList.contains(modifiers.button.dragHandle)
      );
      ariaToolbar.destroyFns.forEach((d) => d());
      ariaToolbar.destroyFns = initToolbarKeyNav({ orientation, toolbar, buttons, onEscape, onFocus, onBlur });
    };
    ariaToolbar.resetListeners();
    this.updateToolbarAriaLabel(group, toolbar);
  }
  computeAriaOrientation(position) {
    return {
      top: "horizontal",
      right: "vertical",
      bottom: "horizontal",
      left: "vertical",
      floating: "horizontal",
      "floating-top": "horizontal",
      "floating-bottom": "horizontal"
    }[position];
  }
  toggleGroup(caller, group, active, enabled) {
    if (enabled === true) {
      this.groupCallers[group].add(caller);
    } else if (enabled === false) {
      this.groupCallers[group].delete(caller);
    }
    if (active != null) {
      for (const button of this.groupButtons[group]) {
        this.setButtonActive(button, active);
      }
    }
  }
  processPendingEvents() {
    const pendingButtonToggledEvents = (this.pendingButtonToggledEvents ?? []).slice();
    for (const event of pendingButtonToggledEvents) {
      this.onButtonToggled(event);
    }
    this.pendingButtonToggledEvents = [];
  }
  onLayoutStart(ctx) {
    if (this.enabled) {
      this.refreshOuterLayout(ctx.layoutBox);
      this.refreshLocale();
    }
  }
  refreshOuterLayout(shrinkRect) {
    const { elements: elements2, horizontalSpacing, verticalSpacing } = this;
    if (!elements2.top.classList.contains(modifiers.hidden)) {
      shrinkRect.shrink(elements2.top.offsetHeight + verticalSpacing, "top");
    }
    if (!elements2.right.classList.contains(modifiers.hidden)) {
      shrinkRect.shrink(elements2.right.offsetWidth + horizontalSpacing, "right");
    }
    if (!elements2.bottom.classList.contains(modifiers.hidden)) {
      shrinkRect.shrink(elements2.bottom.offsetHeight + verticalSpacing, "bottom");
      elements2.bottom.style.top = `${shrinkRect.y + shrinkRect.height + verticalSpacing}px`;
    }
    if (!elements2.left.classList.contains(modifiers.hidden)) {
      shrinkRect.shrink(elements2.left.offsetWidth + horizontalSpacing, "left");
    }
  }
  refreshLocale() {
    const { hasNewLocale } = this;
    if (!hasNewLocale)
      return;
    for (const group of TOOLBAR_GROUPS) {
      const buttons = this[group].buttonConfigurations();
      for (const buttonOptions of buttons) {
        this.refreshButtonContent(group, buttonOptions);
      }
      this.updateToolbarAriaLabel(group);
    }
    this.hasNewLocale = false;
  }
  refreshInnerLayout(rect) {
    const { elements: elements2, verticalSpacing } = this;
    const { FloatingBottom, FloatingTop } = ToolbarPosition;
    elements2.top.style.top = `${rect.y - elements2.top.offsetHeight - verticalSpacing}px`;
    elements2.top.style.left = `${rect.x}px`;
    elements2.top.style.width = `${rect.width}px`;
    elements2.bottom.style.left = `${rect.x}px`;
    elements2.bottom.style.width = `${rect.width}px`;
    elements2.right.style.top = `${rect.y}px`;
    elements2.right.style.right = `0px`;
    elements2.right.style.height = `${rect.height}px`;
    elements2.left.style.top = `${rect.y}px`;
    elements2.left.style.left = `0px`;
    elements2.left.style.height = `${rect.height}px`;
    elements2[FloatingTop].style.top = `${rect.y}px`;
    elements2[FloatingBottom].style.top = `${rect.y + rect.height - elements2[FloatingBottom].offsetHeight}px`;
  }
  refreshButtonContent(group, buttonOptions) {
    const id = this.buttonId(buttonOptions);
    const button = this.groupProxied.get(group)?.buttons?.find((b) => this.buttonId(b) === id) ?? buttonOptions;
    const element2 = this.groupButtons[group].find((b) => b.getAttribute("data-toolbar-id") === id);
    if (element2 == null)
      return;
    this.updateButton(element2, button);
  }
  toggleVisibilities() {
    if (this.elements == null)
      return;
    const isGroupVisible = (group) => this[group].enabled && this.groupCallers[group].size > 0;
    const isButtonVisible = (element2) => (button) => {
      const id = this.buttonId(button);
      return id == null || id === element2.dataset.toolbarId;
    };
    for (const position of TOOLBAR_POSITIONS) {
      const visible = this.enabled && Array.from(this.positions[position].values()).some(isGroupVisible);
      if (position === "floating" /* Floating */ && !visible) {
        this.dragState.detached = false;
      }
      this.elements[position].classList.toggle(modifiers.hidden, !visible);
    }
    for (const group of TOOLBAR_GROUPS) {
      if (this[group] == null)
        continue;
      const groupVisible = isGroupVisible(group);
      for (const button of this.groupButtons[group]) {
        const buttonVisible = groupVisible && this[group].buttonConfigurations().some(isButtonVisible(button));
        button.classList.toggle(modifiers.button.hiddenValue, !buttonVisible);
      }
    }
  }
  translateFloatingElements(position, visible) {
    const { elements: elements2, verticalSpacing: verticalMargin, positionAlignments } = this;
    const element2 = elements2[position];
    const alignments = Object.values(positionAlignments[position]);
    element2.classList.toggle(modifiers.floatingHidden, !visible);
    const dir = position === "floating-bottom" /* FloatingBottom */ ? 1 : -1;
    for (const align of alignments) {
      align.style.transform = visible && align.style.transform !== "" ? "translateY(0)" : `translateY(${(element2.offsetHeight + verticalMargin) * dir}px)`;
    }
  }
  renderToolbar(position = "top" /* Top */) {
    const element2 = this.elements[position];
    element2.classList.add(block, modifiers[position], modifiers.preventFlash);
    if (isAnimatingFloatingPosition(position)) {
      element2.classList.add(modifiers.floatingHidden);
    }
    for (const align of TOOLBAR_ALIGNMENTS) {
      const alignmentElement = createElement("div");
      alignmentElement.role = "presentation";
      alignmentElement.classList.add(elements.align, modifiers.align[align]);
      element2.appendChild(alignmentElement);
      this.positionAlignments[position][align] = alignmentElement;
    }
  }
  createButtonElement(group, options) {
    const button = createElement("button");
    button.classList.add(elements.button);
    button.dataset.toolbarGroup = group;
    setAttribute(button, "tabindex", -1);
    if (options.haspopup) {
      setAttributes(button, { "aria-haspopup": true, "aria-expanded": false });
    }
    button.dataset.toolbarId = this.buttonId(options);
    button.addEventListener(
      "click",
      makeAccessibleClickListener(
        button,
        (event) => this.onButtonPress(event, button, group, options.id, options.value)
      )
    );
    if (options.value === "drag") {
      button.addEventListener(
        "mousedown",
        makeAccessibleClickListener(button, (event) => this.onDragStart(event, button, group))
      );
      button.classList.add(modifiers.button.dragHandle);
    }
    if (options.role === "switch") {
      setAttributes(button, { role: options.role, "aria-checked": false });
    }
    this.updateButton(button, options);
    this.destroyFns.push(() => button.remove());
    return button;
  }
  getAriaToolbar(group) {
    for (const ariaToolbar of this.ariaToolbars) {
      if (ariaToolbar.groups.includes(group)) {
        return ariaToolbar;
      }
    }
    throw new Error(`AG Charts - cannot find aria-toolbar of '${group}'`);
  }
  updateToolbarAriaLabel(group, alignElement) {
    if (!alignElement) {
      const { align, position } = this[group];
      alignElement = this.positionAlignments[position][align];
      if (!alignElement)
        return;
    }
    const map = {
      seriesType: "ariaLabelFinancialCharts",
      annotations: "ariaLabelFinancialCharts",
      annotationOptions: "ariaLabelAnnotationOptionsToolbar",
      ranges: "ariaLabelRangesToolbar",
      zoom: "ariaLabelZoomToolbar"
    };
    alignElement.ariaLabel = this.ctx.localeManager.t(map[group]);
  }
  expandButtonConfig(button, options) {
    if (options.role !== "switch" || button.ariaChecked !== "true" || options.checkedOverrides === void 0)
      return options;
    return {
      icon: options.checkedOverrides.icon ?? options.icon,
      label: options.checkedOverrides.label ?? options.label,
      ariaLabel: options.checkedOverrides.ariaLabel ?? options.ariaLabel,
      tooltip: options.checkedOverrides.tooltip ?? options.tooltip
    };
  }
  updateButton(button, options) {
    const { domManager, localeManager } = this.ctx;
    const { icon, label, ariaLabel, tooltip } = this.expandButtonConfig(button, options);
    if (tooltip) {
      button.title = localeManager.t(tooltip);
    }
    let inner = "";
    if (icon != null) {
      inner = `<span class="${domManager.getIconClassNames(icon)} ${elements.icon}"></span>`;
    }
    if (label != null) {
      const tlabel = localeManager.t(label);
      inner = `${inner}<span class="${elements.label}">${tlabel}</span>`;
    }
    button.innerHTML = inner;
    button.classList.toggle(modifiers.button.fillVisible, options.fill != null);
    button.style.setProperty("--fill", options.fill ?? null);
    const strokeWidthVisible = options.strokeWidth != null;
    button.classList.toggle(modifiers.button.strokeWidthVisible, strokeWidthVisible);
    button.style.setProperty("--strokeWidth", strokeWidthVisible ? `${options.strokeWidth}px` : null);
    const tAriaLabel = ariaLabel ? this.ctx.localeManager.t(ariaLabel) : void 0;
    setAttribute(button, "aria-label", tAriaLabel);
  }
  onButtonPress(event, button, group, id, value) {
    this.ctx.toolbarManager.pressButton(group, this.buttonId({ id, value }), value, this.buttonRect(button), event);
  }
  onDragStart(event, button, group) {
    const element2 = this.elements["floating" /* Floating */];
    event.preventDefault();
    event.stopPropagation();
    this.dragState = {
      client: Vec2.from(event.clientX, event.clientY),
      position: Vec2.from(
        Number(element2.style.getPropertyValue("left").replace("px", "")),
        Number(element2.style.getPropertyValue("top").replace("px", ""))
      ),
      detached: true
    };
    button.classList.toggle(modifiers.button.dragging, true);
    const onDrag = (e) => this.onDrag(e, group);
    const onDragEnd = () => {
      button.classList.toggle(modifiers.button.dragging, false);
      window2.removeEventListener("mousemove", onDrag);
    };
    const window2 = getWindow();
    window2.addEventListener("mousemove", onDrag);
    window2.addEventListener("mouseup", onDragEnd, {
      once: true
    });
    this.ctx.toolbarManager.groupMoved(group);
  }
  onDrag(event, group) {
    const { elements: elements2, dragState } = this;
    const element2 = elements2["floating" /* Floating */];
    const { offsetWidth: width, offsetHeight: height } = element2;
    const offset4 = Vec2.sub(Vec2.from(event.clientX, event.clientY), dragState.client);
    const position = Vec2.add(dragState.position, offset4);
    const groupBBox = new BBox(position.x, position.y, width, height);
    this.positionGroup(element2, group, groupBBox);
  }
  buttonId(button) {
    const { id, value, label } = button;
    if (id != null) {
      return id;
    } else if (value != null && typeof value !== "object") {
      return String(value);
    }
    return label ?? "";
  }
};
__decorateClass([
  ObserveChanges((target) => {
    target.processPendingEvents();
    target.toggleVisibilities();
  }),
  Validate(BOOLEAN)
], Toolbar.prototype, "enabled", 2);

// packages/ag-charts-community/src/chart/toolbar/toolbarModule.ts
var DAY = 1e3 * 60 * 60 * 24;
var MONTH = DAY * 30;
var YEAR = DAY * 365;
var seriesType = {
  enabled: false,
  position: "left",
  align: "start",
  buttons: [
    {
      tooltip: "toolbarSeriesTypeDropdown",
      value: "type",
      // @ts-expect-error
      haspopup: true
    }
  ]
};
var annotations = {
  enabled: true,
  position: "left",
  align: "start",
  buttons: [
    {
      icon: "trend-line-drawing",
      tooltip: "toolbarAnnotationsLineAnnotations",
      value: "line-menu",
      section: "line-annotations",
      // @ts-expect-error
      haspopup: true
    },
    {
      icon: "text-annotation",
      tooltip: "toolbarAnnotationsTextAnnotations",
      value: "text-menu",
      section: "text-annotations",
      // @ts-expect-error
      haspopup: true
    },
    {
      icon: "arrow-drawing",
      tooltip: "toolbarAnnotationsShapeAnnotations",
      value: "shape-menu",
      section: "shape-annotations",
      // @ts-expect-error
      haspopup: true
    },
    {
      icon: "measurer-drawing",
      tooltip: "toolbarAnnotationsMeasurerAnnotations",
      value: "measurer-menu",
      section: "measure-annotations",
      // @ts-expect-error
      haspopup: true
    },
    {
      icon: "delete",
      tooltip: "toolbarAnnotationsClearAll",
      value: "clear",
      section: "tools"
    }
  ]
};
var annotationOptions = {
  enabled: true,
  position: "floating",
  align: "start",
  draggable: true,
  buttons: [
    {
      icon: "text-annotation",
      tooltip: "toolbarAnnotationsTextColor",
      value: "text-color",
      // @ts-expect-error
      haspopup: true
    },
    {
      icon: "line-color",
      tooltip: "toolbarAnnotationsLineColor",
      value: "line-color",
      // @ts-expect-error
      haspopup: true
    },
    {
      icon: "fill-color",
      tooltip: "toolbarAnnotationsFillColor",
      value: "fill-color",
      // @ts-expect-error
      haspopup: true
    },
    {
      tooltip: "toolbarAnnotationsTextSize",
      value: "text-size",
      // @ts-expect-error
      haspopup: true
    },
    {
      tooltip: "toolbarAnnotationsLineStrokeWidth",
      value: "line-stroke-width",
      // @ts-expect-error
      haspopup: true
    },
    {
      icon: "line-style-solid",
      tooltip: "toolbarAnnotationsLineStyle",
      value: "line-style-type",
      // @ts-expect-error
      haspopup: true
    },
    {
      icon: "settings",
      tooltip: "toolbarAnnotationsSettings",
      value: "settings",
      // @ts-expect-error
      haspopup: true
    },
    {
      role: "switch",
      icon: "unlocked",
      tooltip: "toolbarAnnotationsLock",
      ariaLabel: "toolbarAnnotationsLock",
      checkedOverrides: {
        icon: "locked",
        tooltip: "toolbarAnnotationsUnlock"
      },
      value: "lock"
    },
    {
      icon: "delete",
      tooltip: "toolbarAnnotationsDelete",
      value: "delete"
    }
  ]
};
var ranges = {
  enabled: false,
  position: DEFAULT_TOOLBAR_POSITION,
  align: "start",
  buttons: [
    {
      label: "toolbarRange1Month",
      ariaLabel: "toolbarRange1MonthAria",
      value: MONTH
    },
    {
      label: "toolbarRange3Months",
      ariaLabel: "toolbarRange3MonthsAria",
      value: 3 * MONTH
    },
    {
      label: "toolbarRange6Months",
      ariaLabel: "toolbarRange6MonthsAria",
      value: 6 * MONTH
    },
    {
      label: "toolbarRangeYearToDate",
      ariaLabel: "toolbarRangeYearToDateAria",
      value: (_start, end) => [(/* @__PURE__ */ new Date(`${new Date(end).getFullYear()}-01-01`)).getTime(), end],
      id: "year-to-date"
    },
    {
      label: "toolbarRange1Year",
      ariaLabel: "toolbarRange1YearAria",
      value: YEAR
    },
    {
      label: "toolbarRangeAll",
      ariaLabel: "toolbarRangeAllAria",
      value: (start, end) => [start, end],
      id: "all"
    }
  ]
};
var zoom = {
  enabled: true,
  position: "top",
  align: "end",
  buttons: [
    {
      icon: "zoom-out",
      tooltip: "toolbarZoomZoomOut",
      value: "zoom-out"
    },
    {
      icon: "zoom-in",
      tooltip: "toolbarZoomZoomIn",
      value: "zoom-in"
    },
    {
      icon: "pan-left",
      tooltip: "toolbarZoomPanLeft",
      value: "pan-left"
    },
    {
      icon: "pan-right",
      tooltip: "toolbarZoomPanRight",
      value: "pan-right"
    },
    {
      icon: "pan-start",
      tooltip: "toolbarZoomPanStart",
      value: "pan-start"
    },
    {
      icon: "pan-end",
      tooltip: "toolbarZoomPanEnd",
      value: "pan-end"
    },
    {
      icon: "reset",
      tooltip: "toolbarZoomReset",
      value: "reset"
    }
  ]
};
var ToolbarModule = {
  type: "root",
  optionsKey: "toolbar",
  packageType: "community",
  chartTypes: ["cartesian"],
  moduleFactory: (ctx) => new Toolbar(ctx),
  themeTemplate: {
    toolbar: {
      enabled: true,
      seriesType,
      annotations,
      annotationOptions,
      ranges,
      zoom
    }
  }
};

// packages/ag-charts-community/src/chart/factory/registerInbuiltModules.ts
function registerInbuiltModules() {
  moduleRegistry.register(
    BackgroundModule,
    CommunityLegendModule,
    LocaleModule,
    NavigatorModule,
    ToolbarModule,
    AreaSeriesModule,
    BarSeriesModule,
    BubbleSeriesModule,
    LineSeriesModule,
    ScatterSeriesModule,
    DonutSeriesModule,
    PieSeriesModule,
    HistogramSeriesModule
  );
  for (const AxisConstructor of [NumberAxis, CategoryAxis, TimeAxis, GroupedCategoryAxis, LogAxis]) {
    axisRegistry.register(AxisConstructor.type, {
      moduleFactory: (ctx) => new AxisConstructor(ctx),
      hidden: AxisConstructor === GroupedCategoryAxis
    });
  }
}

// packages/ag-charts-community/src/chart/factory/setupModules.ts
function setupModules() {
  for (const m of moduleRegistry.modules) {
    if (m.packageType === "enterprise" && !verifyIfModuleExpected(m)) {
      Logger.errorOnce("Unexpected enterprise module registered: " + m.identifier);
    }
    if (m.type === "root" && m.themeTemplate) {
      for (const chartType2 of m.chartTypes) {
        chartDefaults.set(chartType2, m.themeTemplate);
      }
    }
    if (m.type === "series") {
      if (m.chartTypes.length > 1) {
        throw new Error(`AG Charts - Module definition error: ${m.identifier}`);
      }
      seriesRegistry.register(m.identifier, m);
    }
    if (m.type === "series-option" && m.themeTemplate) {
      for (const seriesType2 of m.seriesTypes) {
        seriesRegistry.setThemeTemplate(seriesType2, m.themeTemplate);
      }
    }
    if (m.type === "axis-option" && m.themeTemplate) {
      for (const axisType of m.axisTypes) {
        const axisTypeTheme = axisRegistry.getThemeTemplate(axisType);
        const theme = mergeDefaults(m.themeTemplate, axisTypeTheme);
        axisRegistry.setThemeTemplate(axisType, theme);
      }
    }
    if (m.type === "axis") {
      axisRegistry.register(m.identifier, m);
    }
    if (m.type === "legend") {
      legendRegistry.register(m.identifier, m);
    }
  }
  if (moduleRegistry.hasEnterpriseModules()) {
    const expectedButUnused = getUnusedExpectedModules();
    if (expectedButUnused.length > 0) {
      Logger.errorOnce("Enterprise modules expected but not registered: ", expectedButUnused);
    }
  }
}

// packages/ag-charts-community/src/chart/flowProportionChart.ts
function isFlowProportion(series) {
  return series.type === "sankey" || series.type === "chord";
}
var FlowProportionChart = class extends Chart {
  getChartType() {
    return "flow-proportion";
  }
  async updateData() {
    await super.updateData();
    const { nodes } = this.getOptions();
    this.series.forEach((series) => {
      if (isFlowProportion(series)) {
        series.setChartNodes(nodes);
      }
    });
  }
  performLayout(ctx) {
    const { seriesRoot, annotationRoot, highlightRoot } = this;
    const { layoutBox } = ctx;
    const seriesRect = layoutBox.clone();
    layoutBox.shrink(this.seriesArea.padding.toJson());
    this.seriesRect = layoutBox;
    this.animationRect = layoutBox;
    seriesRoot.visible = this.series.some((s) => s.visible);
    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {
      group.translationX = Math.floor(layoutBox.x);
      group.translationY = Math.floor(layoutBox.y);
      group.setClipRect(seriesRect.clone());
    }
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      series: { visible: seriesRoot.visible, rect: seriesRect, paddedRect: layoutBox }
    });
  }
};
FlowProportionChart.className = "FlowProportionChart";
FlowProportionChart.type = "flow-proportion";

// packages/ag-charts-community/src/chart/axis/polarAxis.ts
var PolarAxis = class extends Axis {
  constructor() {
    super(...arguments);
    this.shape = "polygon";
    this.innerRadiusRatio = 0;
    this.defaultTickMinSpacing = 20;
  }
  computeLabelsBBox(_options, _seriesRect) {
    return null;
  }
  computeRange() {
  }
  getAxisLinePoints() {
    return void 0;
  }
};
__decorateClass([
  Validate(UNION(["polygon", "circle"], "a polar axis shape"))
], PolarAxis.prototype, "shape", 2);
__decorateClass([
  Validate(RATIO)
], PolarAxis.prototype, "innerRadiusRatio", 2);

// packages/ag-charts-community/src/chart/gaugeChart.ts
function isRadialGaugeSeries(series) {
  return series.type === "radial-gauge";
}
function isLinearGaugeSeries(series) {
  return series.type === "linear-gauge";
}
var GaugeChart = class extends Chart {
  getChartType() {
    return "gauge";
  }
  updateRadialGauge(seriesRect, series) {
    const angleAxis = this.axes.find((axis) => axis.direction === "x" /* X */);
    if (!(angleAxis instanceof PolarAxis))
      return;
    angleAxis.computeRange();
    const seriesRectX0 = seriesRect.x;
    const seriesRectX1 = seriesRectX0 + seriesRect.width;
    const seriesRectY0 = seriesRect.y;
    const seriesRectY1 = seriesRectY0 + seriesRect.height;
    const [startAngle, endAngle] = angleAxis.range;
    const sweepAngle = normalizeAngle360Inclusive(endAngle - startAngle);
    const largerThanHalf = sweepAngle > Math.PI;
    const containsTop = largerThanHalf || isBetweenAngles(1.5 * Math.PI, startAngle, endAngle);
    const containsRight = largerThanHalf || isBetweenAngles(0 * Math.PI, startAngle, endAngle);
    const containsBottom = largerThanHalf || isBetweenAngles(0.5 * Math.PI, startAngle, endAngle);
    const containsLeft = largerThanHalf || isBetweenAngles(1 * Math.PI, startAngle, endAngle);
    let textAlign;
    if (containsLeft && !containsRight) {
      textAlign = "right";
    } else if (!containsLeft && containsRight) {
      textAlign = "left";
    } else {
      textAlign = "center";
    }
    let verticalAlign;
    if (containsTop && !containsBottom) {
      verticalAlign = "bottom";
    } else if (!containsTop && containsBottom) {
      verticalAlign = "top";
    } else {
      verticalAlign = "middle";
    }
    const unitBox = sectorBox({
      startAngle,
      endAngle,
      innerRadius: 0,
      outerRadius: 0.5
    });
    const centerXOffset = -(unitBox.x + unitBox.width / 2) * 2;
    const centerYOffset = -(unitBox.y + unitBox.height / 2) * 2;
    const { minimumRadius = 0, maximumRadius } = series;
    const radiusBounds = Math.max(
      0.5 * Math.min(seriesRect.width / unitBox.width, seriesRect.height / unitBox.height),
      // seriesRect may have negative size
      0
    );
    let radius = Math.min(maximumRadius ?? Infinity, Math.max(radiusBounds, minimumRadius ?? 0));
    const MAX_ITERATIONS = 8;
    for (let i = 0; i < MAX_ITERATIONS; i += 1) {
      const isFinalIteration = radius <= minimumRadius || i === MAX_ITERATIONS - 1;
      const centerX = seriesRect.x + seriesRect.width / 2 + centerXOffset * radius;
      const centerY = seriesRect.y + seriesRect.height / 2 + centerYOffset * radius;
      angleAxis.translation.x = centerX;
      angleAxis.translation.y = centerY;
      angleAxis.gridLength = radius;
      angleAxis.calculateLayout();
      const bbox = angleAxis.computeLabelsBBox({ hideWhenNecessary: isFinalIteration }, seriesRect);
      if (isFinalIteration)
        break;
      let shrinkDelta = 0;
      if (bbox != null) {
        const bboxX0 = bbox.x + centerX;
        const bboxX1 = bboxX0 + bbox.width;
        const bboxY0 = bbox.y + centerY;
        const bboxY1 = bboxY0 + bbox.height;
        shrinkDelta = Math.max(
          seriesRectY0 - bboxY0,
          seriesRectX0 - bboxX0,
          bboxY1 - seriesRectY1,
          bboxX1 - seriesRectX1,
          0
        );
      }
      if (shrinkDelta > 0) {
        radius = Math.max(radius - shrinkDelta, minimumRadius);
      } else {
        break;
      }
    }
    angleAxis.translation.x = seriesRect.x + seriesRect.width / 2 + centerXOffset * radius;
    angleAxis.translation.y = seriesRect.y + seriesRect.height / 2 + centerYOffset * radius;
    series.centerX = seriesRect.width / 2 + centerXOffset * radius;
    series.centerY = seriesRect.height / 2 + centerYOffset * radius;
    series.radius = radius;
    series.textAlign = textAlign;
    series.verticalAlign = verticalAlign;
    if (radius === 0 || radius > radiusBounds) {
      Logger.warnOnce("There was insufficient space to display the Radial Gauge.");
    }
  }
  updateLinearGauge(seriesRect, series) {
    const xAxis = this.axes.find((axis) => axis.direction === "x" /* X */);
    const yAxis = this.axes.find((axis) => axis.direction === "y" /* Y */);
    if (!(xAxis instanceof CartesianAxis))
      return seriesRect;
    if (!(yAxis instanceof CartesianAxis))
      return seriesRect;
    const { horizontal, thickness } = series;
    let horizontalInset = 0;
    let verticalInset = 0;
    const scale2 = new LinearScale();
    scale2.domain = [0, 100];
    scale2.range = horizontal ? xAxis.range : yAxis.range;
    const ticks = scale2.ticks();
    if (horizontal) {
      horizontalInset = series.computeInset("x" /* X */, ticks);
    } else {
      verticalInset = series.computeInset("y" /* Y */, ticks);
    }
    const seriesWidth = seriesRect.width - Math.abs(horizontalInset);
    const seriesHeight = seriesRect.height - Math.abs(verticalInset);
    const width = Math.max(horizontal ? seriesWidth : thickness, 0);
    const height = Math.max(horizontal ? thickness : seriesHeight, 0);
    const x0 = seriesRect.x + (seriesWidth - width) / 2 + Math.max(horizontalInset, 0);
    const y0 = seriesRect.y + (seriesHeight - height) / 2 - Math.min(verticalInset, 0);
    xAxis.range = [0, width];
    xAxis.gridLength = width;
    xAxis.calculateLayout();
    xAxis.translation.x = x0;
    xAxis.translation.y = y0 + (xAxis.position === "bottom" ? thickness : 0);
    yAxis.range = [0, height];
    yAxis.gridLength = height;
    yAxis.calculateLayout();
    yAxis.translation.x = x0 + (yAxis.position === "right" ? thickness : 0);
    yAxis.translation.y = y0;
    series.originX = x0 - seriesRect.x;
    series.originY = y0 - seriesRect.y;
    if (width === 0 || height === 0) {
      Logger.warnOnce("There was insufficient space to display the Linear Gauge.");
    }
  }
  performLayout(ctx) {
    const { seriesRoot, annotationRoot, highlightRoot, series, seriesArea } = this;
    const { layoutBox } = ctx;
    const seriesRect = layoutBox.clone();
    layoutBox.shrink(seriesArea.padding.toJson());
    const firstSeries = this.series[0];
    if (isRadialGaugeSeries(firstSeries)) {
      this.updateRadialGauge(layoutBox, firstSeries);
    } else if (isLinearGaugeSeries(firstSeries)) {
      this.updateLinearGauge(layoutBox, firstSeries);
    }
    this.axes.forEach((axis) => axis.update());
    this.seriesRect = seriesRect.clone().translate(seriesRect.x - layoutBox.x, seriesRect.y - layoutBox.y);
    this.animationRect = layoutBox;
    seriesRoot.visible = series.some((s) => s.visible);
    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {
      group.translationX = Math.floor(layoutBox.x);
      group.translationY = Math.floor(layoutBox.y);
    }
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      series: { visible: seriesRoot.visible, rect: seriesRect, paddedRect: layoutBox }
    });
  }
  getAriaLabel() {
    const captions = [];
    const chartCaption = this.getCaptionText();
    if (chartCaption.length !== 0) {
      captions.push(chartCaption);
    }
    for (const series of this.series) {
      captions.push(series.getCaptionText());
    }
    const caption = captions.join(". ");
    return this.ctx.localeManager.t("ariaAnnounceGaugeChart", { caption });
  }
};
GaugeChart.className = "GaugeChart";
GaugeChart.type = "gauge";

// packages/ag-charts-community/src/chart/hierarchyChart.ts
var HierarchyChart = class extends Chart {
  constructor(options, resources) {
    super(options, resources);
  }
  getChartType() {
    return "hierarchy";
  }
  performLayout(ctx) {
    const { seriesRoot, annotationRoot, highlightRoot } = this;
    const { layoutBox } = ctx;
    const seriesRect = layoutBox.clone();
    layoutBox.shrink(this.seriesArea.padding.toJson());
    this.seriesRect = layoutBox;
    this.animationRect = layoutBox;
    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {
      group.translationX = Math.floor(layoutBox.x);
      group.translationY = Math.floor(layoutBox.y);
    }
    seriesRoot.visible = this.series[0].visible;
    seriesRoot.setClipRect(layoutBox.clone());
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      series: { visible: true, rect: seriesRect, paddedRect: layoutBox }
    });
  }
  getAriaLabel() {
    const caption = this.getCaptionText();
    return this.ctx.localeManager.t("ariaAnnounceHierarchyChart", { caption });
  }
};
HierarchyChart.className = "HierarchyChart";
HierarchyChart.type = "hierarchy";

// packages/ag-charts-community/src/chart/polarChart.ts
var PolarChart = class extends Chart {
  constructor(options, resources) {
    super(options, resources);
    this.padding = new Padding(40);
    this.ctx.axisManager.axisGroup.zIndex = 6 /* AXIS_FOREGROUND */;
  }
  getChartType() {
    return "polar";
  }
  async performLayout(ctx) {
    const { layoutBox } = ctx;
    const seriesRect = layoutBox.clone();
    layoutBox.shrink(this.seriesArea.padding.toJson());
    this.seriesRect = layoutBox;
    this.animationRect = layoutBox;
    await this.computeCircle(layoutBox);
    this.axes.forEach((axis) => axis.update());
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      series: { visible: true, rect: seriesRect, paddedRect: layoutBox }
    });
  }
  updateAxes(cx, cy, radius) {
    const angleAxis = this.axes.find((axis) => axis.direction === "x" /* X */);
    const radiusAxis = this.axes.find((axis) => axis.direction === "y" /* Y */);
    if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis))
      return;
    const angleScale = angleAxis.scale;
    const innerRadiusRatio = radiusAxis.innerRadiusRatio;
    angleAxis.innerRadiusRatio = innerRadiusRatio;
    angleAxis.computeRange();
    angleAxis.gridLength = radius;
    radiusAxis.gridAngles = angleScale.ticks?.().map((value) => angleScale.convert(value));
    radiusAxis.gridRange = angleAxis.range;
    radiusAxis.range = [radius, radius * innerRadiusRatio];
    [angleAxis, radiusAxis].forEach((axis) => {
      axis.translation.x = cx;
      axis.translation.y = cy;
      axis.calculateLayout();
    });
  }
  async computeCircle(seriesBox) {
    const polarSeries = this.series.filter(isPolarSeries);
    const polarAxes = this.axes.filter(isPolarAxis);
    const setSeriesCircle = (cx, cy, r) => {
      this.updateAxes(cx, cy, r);
      polarSeries.forEach((series) => {
        series.centerX = cx;
        series.centerY = cy;
        series.radius = r;
      });
      const pieSeries = polarSeries.filter((s) => s.type === "donut" || s.type === "pie");
      if (pieSeries.length > 1) {
        const innerRadii = pieSeries.map((series) => {
          const innerRadius = series.getInnerRadius();
          return { series, innerRadius };
        }).sort((a, b) => a.innerRadius - b.innerRadius);
        innerRadii.at(-1).series.surroundingRadius = void 0;
        for (let i = 0; i < innerRadii.length - 1; i++) {
          innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;
        }
      }
    };
    const centerX = seriesBox.x + seriesBox.width / 2;
    const centerY = seriesBox.y + seriesBox.height / 2;
    const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);
    let radius = initialRadius;
    setSeriesCircle(centerX, centerY, radius);
    const shake = async ({ hideWhenNecessary = false } = {}) => {
      const labelBoxes = [];
      for (const series of iterate(polarAxes, polarSeries)) {
        const box = await series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);
        if (box) {
          labelBoxes.push(box);
        }
      }
      if (labelBoxes.length === 0) {
        setSeriesCircle(centerX, centerY, initialRadius);
        return;
      }
      const labelBox = BBox.merge(labelBoxes);
      const refined = this.refineCircle(labelBox, radius, seriesBox);
      setSeriesCircle(refined.centerX, refined.centerY, refined.radius);
      radius = refined.radius;
    };
    await shake();
    await shake();
    await shake();
    await shake({ hideWhenNecessary: true });
    await shake({ hideWhenNecessary: true });
    for (const series of iterate(polarAxes, polarSeries)) {
      await series.computeLabelsBBox({ hideWhenNecessary: true }, seriesBox);
    }
    return { radius, centerX, centerY };
  }
  refineCircle(labelsBox, radius, seriesBox) {
    const minCircleRatio = 0.5;
    const circleLeft = -radius;
    const circleTop = -radius;
    const circleRight = radius;
    const circleBottom = radius;
    let padLeft = Math.max(0, circleLeft - labelsBox.x);
    let padTop = Math.max(0, circleTop - labelsBox.y);
    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);
    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);
    padLeft = padRight = Math.max(padLeft, padRight);
    padTop = padBottom = Math.max(padTop, padBottom);
    const availCircleWidth = seriesBox.width - padLeft - padRight;
    const availCircleHeight = seriesBox.height - padTop - padBottom;
    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;
    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;
    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;
    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);
    if (newRadius < minRadius) {
      newRadius = minRadius;
      const horizontalPadding = padLeft + padRight;
      const verticalPadding = padTop + padBottom;
      if (2 * newRadius + verticalPadding > seriesBox.height) {
        const padHeight = seriesBox.height - 2 * newRadius;
        if (Math.min(padTop, padBottom) * 2 > padHeight) {
          padTop = padHeight / 2;
          padBottom = padHeight / 2;
        } else if (padTop > padBottom) {
          padTop = padHeight - padBottom;
        } else {
          padBottom = padHeight - padTop;
        }
      }
      if (2 * newRadius + horizontalPadding > seriesBox.width) {
        const padWidth = seriesBox.width - 2 * newRadius;
        if (Math.min(padLeft, padRight) * 2 > padWidth) {
          padLeft = padWidth / 2;
          padRight = padWidth / 2;
        } else if (padLeft > padRight) {
          padLeft = padWidth - padRight;
        } else {
          padRight = padWidth - padLeft;
        }
      }
    }
    const newWidth = padLeft + 2 * newRadius + padRight;
    const newHeight = padTop + 2 * newRadius + padBottom;
    return {
      centerX: seriesBox.x + (seriesBox.width - newWidth) / 2 + padLeft + newRadius,
      centerY: seriesBox.y + (seriesBox.height - newHeight) / 2 + padTop + newRadius,
      radius: newRadius
    };
  }
};
PolarChart.className = "PolarChart";
PolarChart.type = "polar";
function isPolarSeries(series) {
  return series instanceof PolarSeries;
}
function isPolarAxis(axis) {
  return axis instanceof PolarAxis;
}

// packages/ag-charts-community/src/chart/standaloneChart.ts
var StandaloneChart = class extends Chart {
  constructor(options, resources) {
    super(options, resources);
  }
  getChartType() {
    return "standalone";
  }
  performLayout(ctx) {
    const { seriesRoot, annotationRoot, highlightRoot } = this;
    const { layoutBox } = ctx;
    const seriesRect = layoutBox.clone();
    layoutBox.shrink(this.seriesArea.padding.toJson());
    this.seriesRect = layoutBox;
    this.animationRect = layoutBox;
    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {
      group.translationX = Math.floor(layoutBox.x);
      group.translationY = Math.floor(layoutBox.y);
    }
    seriesRoot.visible = this.series[0].visible;
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      series: { visible: true, rect: seriesRect, paddedRect: layoutBox }
    });
  }
  getAriaLabel() {
    const caption = this.getCaptionText();
    return this.ctx.localeManager.t("ariaAnnounceHierarchyChart", { caption });
  }
};
StandaloneChart.className = "StandaloneChart";
StandaloneChart.type = "standalone";

// packages/ag-charts-community/src/chart/series/topology/mercatorScale.ts
var radsInDeg = Math.PI / 180;
var lonX = (lon) => lon * radsInDeg;
var latY = (lat) => -Math.log(Math.tan(Math.PI * 0.25 + lat * radsInDeg * 0.5));
var xLon = (x) => x / radsInDeg;
var yLat = (y) => (Math.atan(Math.exp(-y)) - Math.PI * 0.25) / (radsInDeg * 0.5);
var MercatorScale = class _MercatorScale {
  constructor(domain, range3) {
    this.domain = domain;
    this.range = range3;
    this.type = "mercator";
    this.bounds = _MercatorScale.bounds(domain);
  }
  static bounds(domain) {
    const [[lon0, lat0], [lon1, lat1]] = domain;
    const x0 = lonX(lon0);
    const y0 = latY(lat0);
    const x1 = lonX(lon1);
    const y1 = latY(lat1);
    return new BBox(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x1 - x0), Math.abs(y1 - y0));
  }
  static fixedScale() {
    return new _MercatorScale(
      [
        [xLon(0), yLat(0)],
        [xLon(1), yLat(1)]
      ],
      [
        [0, 0],
        [1, 1]
      ]
    );
  }
  convert([lon, lat]) {
    const [[x0, y0], [x1, y1]] = this.range;
    const xScale = (x1 - x0) / this.bounds.width;
    const yScale = (y1 - y0) / this.bounds.height;
    return [(lonX(lon) - this.bounds.x) * xScale + x0, (latY(lat) - this.bounds.y) * yScale + y0];
  }
  invert([x, y]) {
    const [[x0, y0], [x1, y1]] = this.range;
    const xScale = (x1 - x0) / this.bounds.width;
    const yScale = (y1 - y0) / this.bounds.height;
    return [xLon((x - x0) / xScale + this.bounds.x), yLat((y - y0) / yScale + this.bounds.y)];
  }
};

// packages/ag-charts-community/src/chart/topologyChart.ts
function isTopologySeries(series) {
  return series.type === "map-shape" || series.type === "map-line" || series.type === "map-marker" || series.type === "map-shape-background" || series.type === "map-line-background";
}
var TopologyChart = class extends Chart {
  constructor(options, resources) {
    super(options, resources);
    this.xAxis = new NumberAxis(this.getModuleContext());
    this.xAxis.position = "bottom";
    this.yAxis = new NumberAxis(this.getModuleContext());
    this.yAxis.position = "left";
    this.ctx.zoomManager.updateAxes([this.xAxis, this.yAxis]);
  }
  getChartType() {
    return "topology";
  }
  async updateData() {
    await super.updateData();
    const { topology } = this.getOptions();
    this.series.forEach((series) => {
      if (isTopologySeries(series)) {
        series.setChartTopology(topology);
      }
    });
  }
  performLayout(ctx) {
    const { seriesRoot, annotationRoot, highlightRoot } = this;
    const { layoutBox } = ctx;
    const seriesRect = layoutBox.clone();
    layoutBox.shrink(this.seriesArea.padding.toJson());
    this.seriesRect = layoutBox;
    this.animationRect = layoutBox;
    const mapSeries = this.series.filter(isTopologySeries);
    const combinedBbox = mapSeries.reduce((combined, series) => {
      if (!series.visible)
        return combined;
      const bbox = series.topologyBounds;
      if (bbox == null)
        return combined;
      if (combined == null)
        return bbox;
      combined.merge(bbox);
      return combined;
    }, void 0);
    let scale2;
    if (combinedBbox != null) {
      const { lon0, lat0, lon1, lat1 } = combinedBbox;
      const domain = [
        [lon0, lat0],
        [lon1, lat1]
      ];
      const bounds = MercatorScale.bounds(domain);
      const { width, height } = layoutBox;
      const viewBoxScale = Math.min(width / bounds.width, height / bounds.height);
      const viewBoxWidth = bounds.width * viewBoxScale;
      const viewBoxHeight = bounds.height * viewBoxScale;
      const viewBoxOriginX = (width - viewBoxWidth) / 2;
      const viewBoxOriginY = (height - viewBoxHeight) / 2;
      const x0 = viewBoxOriginX;
      const y0 = viewBoxOriginY;
      const x1 = viewBoxOriginX + viewBoxWidth;
      const y1 = viewBoxOriginY + viewBoxHeight;
      const xZoom = this.ctx.zoomManager.getAxisZoom(this.xAxis.id);
      const yZoom = this.ctx.zoomManager.getAxisZoom(this.yAxis.id);
      const xSpan = (x1 - x0) / (xZoom.max - xZoom.min);
      const xStart = x0 - xSpan * xZoom.min;
      const ySpan = (y1 - y0) / (1 - yZoom.min - (1 - yZoom.max));
      const yStart = y0 - ySpan * (1 - yZoom.max);
      scale2 = new MercatorScale(domain, [
        [xStart, yStart],
        [xStart + xSpan, yStart + ySpan]
      ]);
    }
    mapSeries.forEach((series) => {
      series.scale = scale2;
    });
    const seriesVisible = this.series.some((s) => s.visible);
    seriesRoot.visible = seriesVisible;
    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {
      group.translationX = Math.floor(layoutBox.x);
      group.translationY = Math.floor(layoutBox.y);
      group.setClipRect(layoutBox.clone());
    }
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      series: { visible: seriesVisible, rect: seriesRect, paddedRect: layoutBox }
    });
  }
};
TopologyChart.className = "TopologyChart";
TopologyChart.type = "topology";

// packages/ag-charts-community/src/api/preset/presetUtils.ts
function assertEmpty(_t) {
}
var IGNORED_PROP = Symbol("IGNORED_PROP");
function pickProps(opts, values) {
  const out = {};
  for (const key in values) {
    const value = values[key];
    if (value !== IGNORED_PROP && Object.hasOwn(opts, key)) {
      out[key] = value;
    }
  }
  return out;
}

// packages/ag-charts-community/src/api/preset/gauge.ts
function isRadialGauge(opts) {
  return opts.type === "radial-gauge";
}
function isLinearGauge(opts) {
  return opts.type === "linear-gauge";
}
function radialGaugeOptions(opts) {
  const {
    animation,
    background,
    container,
    contextMenu,
    footnote,
    height,
    listeners,
    locale,
    minHeight,
    minWidth,
    padding,
    subtitle,
    theme,
    title,
    width,
    type,
    cursor,
    nodeClickRange,
    tooltip,
    value,
    scale: scale2 = {},
    startAngle,
    endAngle,
    highlightStyle,
    segmentation,
    bar,
    needle,
    targets,
    outerRadius,
    innerRadius,
    outerRadiusRatio,
    innerRadiusRatio,
    cornerRadius,
    cornerMode,
    label,
    secondaryLabel,
    spacing,
    ...rest
  } = opts;
  assertEmpty(rest);
  const {
    fills: scaleFills,
    fillMode: scaleFillMode,
    fill: scaleFill,
    fillOpacity: scaleFillOpacity,
    stroke: scaleStroke,
    strokeWidth: scaleStrokeWidth,
    strokeOpacity: scaleStrokeOpacity,
    lineDash: scaleLineDash,
    lineDashOffset: scaleLineDashOffset,
    min: scaleMin = 0,
    max: scaleMax = 1,
    interval: scaleInterval = {},
    label: scaleLabel = {},
    ...scaleRest
  } = scale2;
  assertEmpty(scaleRest);
  const chartOpts = pickProps(opts, {
    animation,
    background,
    container,
    contextMenu,
    footnote,
    height,
    listeners,
    locale,
    minHeight,
    minWidth,
    padding,
    subtitle,
    theme,
    title,
    width
  });
  const scaleOpts = pickProps(scale2, {
    fills: scaleFills,
    fillMode: scaleFillMode,
    fill: scaleFill,
    fillOpacity: scaleFillOpacity,
    stroke: scaleStroke,
    strokeWidth: scaleStrokeWidth,
    strokeOpacity: scaleStrokeOpacity,
    lineDash: scaleLineDash,
    lineDashOffset: scaleLineDashOffset
  });
  const seriesOpts = pickProps(opts, {
    startAngle: IGNORED_PROP,
    endAngle: IGNORED_PROP,
    needle: needle != null ? { enabled: true, ...needle } : IGNORED_PROP,
    scale: scaleOpts,
    type,
    cursor,
    nodeClickRange,
    listeners,
    tooltip,
    value,
    highlightStyle,
    segmentation,
    bar,
    targets,
    outerRadius,
    innerRadius,
    outerRadiusRatio,
    innerRadiusRatio,
    cornerRadius,
    cornerMode,
    label,
    secondaryLabel,
    spacing,
    ...rest
  });
  const axesOpts = [
    {
      type: "angle-number",
      min: scaleMin,
      max: scaleMax,
      startAngle,
      endAngle,
      interval: scaleInterval ?? {},
      label: scaleLabel ?? {}
    },
    { type: "radius-number" }
  ];
  return {
    ...chartOpts,
    series: [seriesOpts],
    axes: axesOpts
  };
}
function linearGaugeOptions(opts) {
  const {
    animation,
    background,
    container,
    contextMenu,
    footnote,
    height,
    listeners,
    locale,
    minHeight,
    minWidth,
    padding,
    subtitle,
    theme,
    title,
    width,
    type,
    cursor,
    nodeClickRange,
    tooltip,
    value,
    scale: scale2 = {},
    direction = "vertical",
    thickness,
    highlightStyle,
    segmentation,
    bar,
    targets,
    cornerRadius,
    cornerMode,
    label,
    ...rest
  } = opts;
  assertEmpty(rest);
  const {
    fills: scaleFills,
    fillMode: scaleFillMode,
    fill: scaleFill,
    fillOpacity: scaleFillOpacity,
    stroke: scaleStroke,
    strokeWidth: scaleStrokeWidth,
    strokeOpacity: scaleStrokeOpacity,
    lineDash: scaleLineDash,
    lineDashOffset: scaleLineDashOffset,
    min: scaleMin = 0,
    max: scaleMax = 1,
    interval: scaleInterval = {},
    label: scaleLabel = {},
    ...scaleRest
  } = scale2;
  assertEmpty(scaleRest);
  const chartOpts = pickProps(opts, {
    animation,
    background,
    container,
    contextMenu,
    footnote,
    height,
    listeners,
    locale,
    minHeight,
    minWidth,
    padding,
    subtitle,
    theme,
    title,
    width
  });
  const scaleOpts = pickProps(scale2, {
    fills: scaleFills,
    fillMode: scaleFillMode,
    fill: scaleFill,
    fillOpacity: scaleFillOpacity,
    stroke: scaleStroke,
    strokeWidth: scaleStrokeWidth,
    strokeOpacity: scaleStrokeOpacity,
    lineDash: scaleLineDash,
    lineDashOffset: scaleLineDashOffset
  });
  const seriesOpts = pickProps(opts, {
    scale: scaleOpts,
    type,
    cursor,
    nodeClickRange,
    listeners,
    tooltip,
    value,
    direction,
    thickness,
    highlightStyle,
    segmentation,
    bar,
    targets,
    cornerRadius,
    cornerMode,
    label,
    ...rest
  });
  const { placement: labelPlacement, ...axisLabel } = scaleLabel;
  let mainAxisPosition;
  let crossAxisPosition;
  const horizontal = direction === "horizontal";
  if (horizontal) {
    mainAxisPosition = labelPlacement === "before" ? "top" : "bottom";
    crossAxisPosition = "left";
  } else {
    mainAxisPosition = labelPlacement === "after" ? "right" : "left";
    crossAxisPosition = "bottom";
  }
  const mainAxis = {
    type: "number",
    position: mainAxisPosition,
    min: scaleMin,
    max: scaleMax,
    reverse: !horizontal,
    interval: scaleInterval,
    label: axisLabel,
    nice: false
  };
  const crossAxis = {
    type: "number",
    position: crossAxisPosition,
    min: 0,
    max: 1,
    label: {
      enabled: false
    }
  };
  const axesOpts = horizontal ? [mainAxis, crossAxis] : [crossAxis, mainAxis];
  return {
    ...chartOpts,
    series: [seriesOpts],
    axes: axesOpts
  };
}
function applyThemeDefaults(opts, presetTheme) {
  if (presetTheme == null)
    return opts;
  const { targets: targetsTheme, ...gaugeTheme } = presetTheme;
  opts = mergeDefaults(opts, gaugeTheme);
  if (opts.targets != null && targetsTheme != null) {
    opts.targets = mergeArrayDefaults(opts.targets, targetsTheme);
  }
  return opts;
}
function gauge(opts, presetTheme) {
  if (isRadialGauge(opts)) {
    const radialGaugeOpts = applyThemeDefaults(opts, presetTheme);
    return radialGaugeOptions(radialGaugeOpts);
  } else if (isLinearGauge(opts)) {
    const linearGaugeOpts = applyThemeDefaults(opts, presetTheme);
    return linearGaugeOptions(linearGaugeOpts);
  }
  const {
    animation,
    background,
    container,
    contextMenu,
    footnote,
    height,
    listeners,
    locale,
    minHeight,
    minWidth,
    padding,
    subtitle,
    theme,
    title,
    width
  } = opts;
  return pickProps(opts, {
    animation,
    background,
    container,
    contextMenu,
    footnote,
    height,
    listeners,
    locale,
    minHeight,
    minWidth,
    padding,
    subtitle,
    theme,
    title,
    width
  });
}

// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts
function fromTheme(theme, cb) {
  if (isObject(theme)) {
    return cb(theme);
  }
}
var chartTypes2 = ["ohlc", "line", "step-line", "hlc", "high-low", "candlestick", "hollow-candlestick"];
function priceVolume(opts, _presetTheme, getTheme) {
  const {
    xKey,
    dateKey = xKey ?? "date",
    highKey = "high",
    openKey = "open",
    lowKey = "low",
    closeKey = "close",
    volumeKey = "volume",
    chartType: chartType2 = "candlestick",
    navigator: navigator2 = false,
    volume = true,
    rangeToolbar,
    rangeButtons = rangeToolbar ?? true,
    statusBar = true,
    annotations: annotations2,
    toolbar = annotations2 ?? true,
    zoom: zoom2 = true,
    theme,
    data,
    ...unusedOpts
  } = opts;
  if (xKey != null) {
    Logger.warnOnce("Property [xKey] is deprecated, use [dateKey] instead.");
  }
  if (rangeToolbar != null) {
    Logger.warnOnce("Property [rangeToolbar] is deprecated, use [rangeButtons] instead.");
  }
  if (annotations2 != null) {
    Logger.warnOnce("Property [annotations] is deprecated, use [toolbar] instead.");
  }
  const priceSeries = createPriceSeries(theme, chartType2, dateKey, highKey, lowKey, openKey, closeKey);
  const volumeSeries = createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey);
  const miniChart = volume ? {
    miniChart: {
      enabled: navigator2,
      series: [
        {
          type: "line",
          xKey: dateKey,
          yKey: volumeKey,
          marker: { enabled: false }
        }
      ]
    }
  } : null;
  const navigatorOpts = {
    navigator: {
      enabled: navigator2,
      ...miniChart
    }
  };
  const annotationOpts = {
    annotations: {
      enabled: toolbar,
      // @ts-expect-error
      data,
      xKey: dateKey,
      volumeKey: volume ? volumeKey : void 0
    }
  };
  const statusBarOpts = statusBar ? {
    statusBar: {
      enabled: true,
      data,
      highKey,
      openKey,
      lowKey,
      closeKey,
      volumeKey: volume ? volumeKey : void 0
    }
  } : null;
  const zoomOpts = {
    zoom: {
      enabled: zoom2,
      // @ts-expect-error
      enableIndependentAxes: true
    }
  };
  const toolbarOpts = {
    chartToolbar: { enabled: true },
    toolbar: {
      seriesType: {
        enabled: toolbar
      },
      annotationOptions: {
        enabled: toolbar
      },
      annotations: {
        enabled: toolbar
      },
      ranges: {
        enabled: rangeButtons
      }
    }
  };
  const volumeAxis = volume ? [
    {
      type: "number",
      position: "left",
      keys: [volumeKey],
      label: { enabled: false },
      crosshair: { enabled: false },
      gridLine: { enabled: false },
      nice: false,
      // @ts-expect-error
      layoutConstraints: {
        stacked: false,
        width: 20,
        unit: "percentage",
        align: "end"
      }
    }
  ] : [];
  return {
    theme: {
      baseTheme: typeof theme === "string" ? theme : "ag-financial",
      ...mergeDefaults(typeof theme === "object" ? theme : null, {
        overrides: {
          common: {
            title: { padding: 4 },
            padding: {
              top: 6,
              right: 8,
              bottom: 5
            }
          }
        }
      })
    },
    animation: { enabled: false },
    legend: { enabled: false },
    series: [...volumeSeries, ...priceSeries],
    axes: [
      {
        type: "number",
        position: "right",
        keys: [openKey, closeKey, highKey, lowKey],
        interval: {
          maxSpacing: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.interval?.maxSpacing) ?? 45
        },
        label: {
          format: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.label?.format) ?? ".2f"
        },
        crosshair: {
          enabled: true,
          snap: false
        },
        // @ts-expect-error
        layoutConstraints: {
          stacked: false,
          width: 100,
          unit: "percentage",
          align: "start"
        }
      },
      ...volumeAxis,
      {
        type: "ordinal-time",
        position: "bottom",
        line: {
          enabled: false
        },
        label: {
          enabled: true
        },
        crosshair: {
          enabled: true
        }
      }
    ],
    tooltip: { enabled: false },
    data,
    ...annotationOpts,
    ...navigatorOpts,
    ...statusBarOpts,
    ...zoomOpts,
    ...toolbarOpts,
    ...unusedOpts
  };
}
function createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey) {
  if (!volume)
    return [];
  const barSeriesFill = fromTheme(theme, (t) => t.overrides?.bar?.series?.fill);
  const itemStyler = barSeriesFill ? { fill: barSeriesFill } : {
    itemStyler({ datum }) {
      const { up, down } = getTheme().palette;
      return { fill: datum[openKey] < datum[closeKey] ? up?.fill : down?.fill };
    }
  };
  return [
    {
      type: "bar",
      xKey: "date",
      yKey: volumeKey,
      // @ts-expect-error
      focusPriority: 1,
      tooltip: { enabled: false },
      highlight: { enabled: false },
      fillOpacity: fromTheme(theme, (t) => t.overrides?.bar?.series?.fillOpacity) ?? 0.5,
      ...itemStyler
    }
  ];
}
var RANGE_AREA_TYPE = "range-area";
function createPriceSeries(theme, chartType2, xKey, highKey, lowKey, openKey, closeKey) {
  if (chartType2 === RANGE_AREA_TYPE) {
    Logger.warnOnce(`type '${chartType2}' is deprecated, use 'hlc' chart type instead`);
    chartType2 = "hlc";
  }
  const keys = {
    xKey,
    openKey,
    closeKey,
    highKey,
    lowKey
  };
  const singleKeys = {
    xKey,
    yKey: closeKey
  };
  const common = {
    pickOutsideVisibleMinorAxis: true
  };
  switch (chartType2 ?? "candlestick") {
    case "ohlc":
      return [
        {
          type: "ohlc",
          // @ts-expect-error
          focusPriority: 0,
          ...common,
          ...keys
        }
      ];
    case "line":
      return [
        {
          type: "line",
          // @ts-expect-error
          focusPriority: 0,
          ...common,
          ...singleKeys,
          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,
          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }
        }
      ];
    case "step-line":
      return [
        {
          type: "line",
          // @ts-expect-error
          focusPriority: 0,
          ...common,
          ...singleKeys,
          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,
          interpolation: fromTheme(theme, (t) => t.overrides?.line?.series?.interpolation) ?? {
            type: "step"
          },
          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }
        }
      ];
    case "hlc": {
      const rangeAreaColors = getThemeColors(RANGE_AREA_TYPE, theme);
      return [
        {
          type: RANGE_AREA_TYPE,
          // @ts-expect-error
          focusPriority: 0,
          ...common,
          xKey,
          yHighKey: highKey,
          yLowKey: closeKey,
          fill: rangeAreaColors.fill ?? PALETTE_UP_FILL,
          stroke: rangeAreaColors.stroke ?? PALETTE_UP_STROKE,
          fillOpacity: fromTheme(theme, (t) => t.overrides?.["range-area"]?.series?.fillOpacity) ?? 0.3,
          strokeWidth: fromTheme(theme, (t) => t.overrides?.["range-area"]?.series?.strokeWidth) ?? 2
        },
        {
          type: RANGE_AREA_TYPE,
          // @ts-expect-error
          focusPriority: 0,
          ...common,
          xKey,
          yHighKey: closeKey,
          yLowKey: lowKey,
          fill: rangeAreaColors.fill ?? PALETTE_DOWN_FILL,
          stroke: rangeAreaColors.stroke ?? PALETTE_DOWN_STROKE,
          fillOpacity: fromTheme(theme, (t) => t.overrides?.["range-area"]?.series?.fillOpacity) ?? 0.3,
          strokeWidth: fromTheme(theme, (t) => t.overrides?.["range-area"]?.series?.strokeWidth) ?? 2
        },
        {
          type: "line",
          ...common,
          ...singleKeys,
          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_ALT_NEUTRAL_STROKE,
          strokeWidth: fromTheme(theme, (t) => t.overrides?.line?.series?.strokeWidth) ?? 2,
          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }
        }
      ];
    }
    case "high-low": {
      const rangeBarColors = getThemeColors("range-bar", theme);
      return [
        {
          type: "range-bar",
          // @ts-expect-error
          focusPriority: 0,
          ...common,
          xKey,
          yHighKey: highKey,
          yLowKey: lowKey,
          fill: rangeBarColors.fill ?? PALETTE_NEUTRAL_FILL,
          stroke: rangeBarColors.stroke ?? PALETTE_NEUTRAL_STROKE,
          tooltip: {
            range: "nearest"
          }
        }
      ];
    }
    case "candlestick":
      return [
        {
          type: "candlestick",
          // @ts-expect-error
          focusPriority: 0,
          ...common,
          ...keys
        }
      ];
    case "hollow-candlestick": {
      const item = fromTheme(theme, (t) => t.overrides?.candlestick?.series?.item);
      return [
        {
          type: "candlestick",
          // @ts-expect-error
          focusPriority: 0,
          ...common,
          ...keys,
          item: {
            up: {
              fill: item?.up?.fill ?? "transparent"
            }
          }
        }
      ];
    }
    default:
      Logger.warnOnce(`unknown chart type: ${chartType2}; expected one of: ${chartTypes2.join(", ")}`);
      return [
        {
          type: "candlestick",
          // @ts-expect-error
          focusPriority: 0,
          ...common,
          ...keys
        }
      ];
  }
}
function getThemeColors(seriesType2, theme) {
  const fill = fromTheme(theme, (t) => t.overrides?.[seriesType2]?.series?.fill);
  const stroke = fromTheme(theme, (t) => t.overrides?.[seriesType2]?.series?.stroke);
  return { fill, stroke };
}

// packages/ag-charts-community/src/api/preset/sparkline.ts
var commonAxisProperties = {
  line: {
    enabled: false
  },
  title: {
    enabled: false
  },
  label: {
    enabled: false
  },
  crosshair: {
    enabled: false,
    strokeOpacity: 0.25,
    lineDash: [0],
    label: {
      enabled: false
    }
  }
};
var numericAxisProperties = {
  ...commonAxisProperties,
  nice: false
};
var bottomCrossHairAxisProperties = {
  bottom: {
    crosshair: {
      enabled: IS_ENTERPRISE
    }
  }
};
var crossHairAxes = {
  category: bottomCrossHairAxisProperties,
  number: bottomCrossHairAxisProperties,
  log: bottomCrossHairAxisProperties,
  time: bottomCrossHairAxisProperties
};
var crossHairTooltip = {
  position: {
    type: "sparkline"
  }
};
var SPARKLINE_THEME = {
  overrides: {
    common: {
      animation: {
        enabled: false
      },
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      },
      axes: {
        number: {
          ...numericAxisProperties,
          interval: {
            values: [0]
          }
        },
        log: {
          ...numericAxisProperties
        },
        time: {
          ...numericAxisProperties
        },
        category: {
          ...commonAxisProperties,
          gridLine: {
            enabled: false
          }
        }
      }
    },
    bar: {
      series: {
        // @ts-expect-error
        sparklineMode: true
      },
      tooltip: {
        range: "nearest"
      }
    },
    line: {
      seriesArea: {
        padding: {
          top: 2,
          right: 2,
          bottom: 2,
          left: 2
        }
      },
      axes: crossHairAxes,
      series: {
        strokeWidth: 1,
        marker: {
          enabled: false,
          size: 3
        },
        tooltip: crossHairTooltip
      }
    },
    area: {
      seriesArea: {
        padding: {
          top: 1,
          right: 0,
          bottom: 1,
          left: 0
        }
      },
      axes: crossHairAxes,
      series: {
        strokeWidth: 1,
        fillOpacity: 0.4,
        tooltip: crossHairTooltip
      }
    }
  }
};
function setInitialBaseTheme(baseTheme, initialBaseTheme) {
  if (typeof baseTheme === "string") {
    return {
      ...initialBaseTheme,
      baseTheme
    };
  }
  if (baseTheme != null) {
    return {
      ...baseTheme,
      // @ts-expect-error internal implementation
      baseTheme: setInitialBaseTheme(baseTheme.baseTheme, initialBaseTheme)
    };
  }
  return initialBaseTheme;
}
function sparkline(opts) {
  const {
    background,
    container,
    height,
    listeners,
    locale,
    minHeight,
    minWidth,
    padding,
    width,
    theme: baseTheme,
    data,
    xAxis,
    yAxis,
    ...optsRest
  } = opts;
  assertEmpty(optsRest);
  const seriesOptions = optsRest;
  const swapAxes = seriesOptions.type !== "bar" || seriesOptions.direction !== "horizontal";
  const chartOpts = pickProps(opts, {
    background,
    container,
    height,
    listeners,
    locale,
    minHeight,
    minWidth,
    padding,
    width,
    data,
    xAxis: IGNORED_PROP,
    yAxis: IGNORED_PROP,
    theme: IGNORED_PROP
  });
  chartOpts.theme = setInitialBaseTheme(baseTheme, SPARKLINE_THEME);
  chartOpts.series = [seriesOptions];
  chartOpts.axes = swapAxes ? [
    { type: "number", ...yAxis, position: "left" },
    { type: "category", ...xAxis, position: "bottom" }
  ] : [
    { type: "category", ...xAxis, position: "left" },
    { type: "number", ...yAxis, position: "bottom" }
  ];
  return chartOpts;
}

// packages/ag-charts-community/src/api/preset/presets.ts
var PRESETS = {
  "price-volume": priceVolume,
  gauge,
  sparkline
};

// packages/ag-charts-community/src/chart/factory/processEnterpriseOptions.ts
function removeUsedEnterpriseOptions(options, silent) {
  let usedOptions = [];
  const isGaugeChart = isAgGaugeChartOptions(options);
  const type = optionsType(options);
  const optionsChartType = type ? chartTypes.get(type) : "unknown";
  for (const {
    type: type2,
    chartTypes: moduleChartTypes,
    optionsKey,
    optionsInnerKey,
    identifier
  } of EXPECTED_ENTERPRISE_MODULES) {
    if (optionsChartType !== "unknown" && !moduleChartTypes.includes(optionsChartType))
      continue;
    if (type2 === "root" || type2 === "legend") {
      const optionValue = options[optionsKey];
      if (optionValue == null)
        continue;
      if (!optionsInnerKey) {
        usedOptions.push(optionsKey);
        delete options[optionsKey];
      } else if (optionValue[optionsInnerKey]) {
        usedOptions.push(`${optionsKey}.${optionsInnerKey}`);
        delete optionValue[optionsInnerKey];
      }
    } else if (type2 === "axis") {
      if (!("axes" in options) || !options.axes?.some((axis) => axis.type === identifier))
        continue;
      usedOptions.push(`axis[type=${identifier}]`);
      options.axes = options.axes.filter((axis) => axis.type !== identifier);
    } else if (type2 === "axis-option") {
      if (!("axes" in options) || !options.axes?.some((axis) => axis[optionsKey]))
        continue;
      usedOptions.push(`axis.${optionsKey}`);
      options.axes.forEach((axis) => {
        if (axis[optionsKey]) {
          delete axis[optionsKey];
        }
      });
    } else if (type2 === "series") {
      if (!options.series?.some((series) => series.type === identifier))
        continue;
      usedOptions.push(`series[type=${identifier}]`);
      options.series = options.series.filter((series) => series.type !== identifier);
    } else if (type2 === "series-option") {
      if (!options.series?.some((series) => series[optionsKey]))
        continue;
      usedOptions.push(`series.${optionsKey}`);
      options.series.forEach((series) => {
        if (series[optionsKey]) {
          delete series[optionsKey];
        }
      });
    }
  }
  if (usedOptions.length && !silent) {
    if (isGaugeChart) {
      usedOptions = ["AgCharts.createGauge"];
    }
    let enterprisePackageName = "ag-charts-enterprise";
    let enterpriseReferenceUrl = "https://ag-grid.com/charts/javascript/installation/";
    if (options.mode === "integrated") {
      enterprisePackageName = "ag-grid-charts-enterprise' or 'ag-grid-enterprise/charts-enterprise";
      enterpriseReferenceUrl = "https://www.ag-grid.com/javascript-data-grid/integrated-charts-installation/";
    }
    Logger.warnOnce(
      [
        `unable to use these enterprise features as '${enterprisePackageName}' has not been loaded:`,
        "",
        ...usedOptions,
        "",
        `See: ${enterpriseReferenceUrl}`
      ].join("\n")
    );
  }
}

// packages/ag-charts-community/src/util/string.util.ts
function stringifyValue(value, maxLength = Infinity) {
  switch (typeof value) {
    case "undefined":
      return "undefined";
    case "number":
      if (isNaN(value)) {
        return "NaN";
      } else if (value === Infinity) {
        return "Infinity";
      } else if (value === -Infinity) {
        return "-Infinity";
      }
    default:
      value = JSON.stringify(value);
      if (value.length > maxLength) {
        return `${value.slice(0, maxLength)}... (+${value.length - maxLength} characters)`;
      }
      return value;
  }
}

// packages/ag-charts-community/src/util/validate.ts
var descriptionSymbol = Symbol("description");
var requiredSymbol = Symbol("required");
function isValid(options, optionsDefs, path) {
  const { errors } = validate(options, optionsDefs, path);
  for (const { message } of errors) {
    Logger.warn(message);
  }
  return errors.length === 0;
}
function validateMessage(path, value, validatorOrDefs) {
  const description = isString(validatorOrDefs) ? validatorOrDefs : validatorOrDefs[descriptionSymbol];
  const expecting = description ? `; expecting ${description}` : "";
  const prefix = path ? `Option \`${path}\`` : "Value";
  return `${prefix} cannot be set to \`${stringifyValue(value)}\`${expecting}, ignoring.`;
}
function validate(options, optionsDefs, path = "") {
  if (!isObject(options)) {
    return {
      valid: null,
      errors: [{ path, value: options, message: validateMessage(path, options, "an object") }]
    };
  }
  const optionsKeys = new Set(Object.keys(options));
  const errors = [];
  const valid = {};
  function extendPath(key) {
    if (isArray(optionsDefs)) {
      return `${path}[${key}]`;
    }
    return path ? `${path}.${key}` : key;
  }
  for (const [key, validatorOrDefs] of Object.entries(optionsDefs)) {
    optionsKeys.delete(key);
    const value = options[key];
    if (!validatorOrDefs[requiredSymbol] && typeof value === "undefined")
      continue;
    if (isFunction(validatorOrDefs)) {
      if (validatorOrDefs(value)) {
        valid[key] = value;
      } else {
        errors.push({ key, path, value, message: validateMessage(extendPath(key), value, validatorOrDefs) });
      }
    } else {
      const nestedResult = validate(value, validatorOrDefs, extendPath(key));
      valid[key] = nestedResult.valid;
      errors.push(...nestedResult.errors);
    }
  }
  for (const key of optionsKeys) {
    errors.push({
      key,
      path,
      unknown: true,
      message: `Unknown option \`${extendPath(key)}\`, ignoring.`
    });
  }
  return { valid, errors };
}
function attachDescription(validator, description) {
  return Object.assign((value) => validator(value), { [descriptionSymbol]: description });
}
var or = (...validators) => attachDescription(
  (value) => validators.some((validator) => validator(value)),
  validators.map((v) => v[descriptionSymbol]).filter(Boolean).join(" or ")
);
var array = attachDescription(isArray, "an array");
var boolean = attachDescription(isBoolean, "a boolean");
var callback = attachDescription(isFunction, "a function");
var number = attachDescription(isFiniteNumber, "a number");
var object = attachDescription(isObject, "an object");
var string = attachDescription(isString, "a string");
var numberMin = (min, inclusive = true) => attachDescription(
  (value) => isFiniteNumber(value) && (value > min || inclusive && value === min),
  `a number greater than ${inclusive ? "or equal to " : ""}${min}`
);
var numberRange = (min, max) => attachDescription(
  (value) => isFiniteNumber(value) && value >= min && value <= max,
  `a number between ${min} and ${max} inclusive`
);
var positiveNumber = numberMin(0);
var minOneNumber = numberMin(1);
var ratio = numberRange(0, 1);
var degree = numberRange(0, 360);
var arrayOf = (validator, description) => attachDescription(
  (value) => isArray(value) && value.every(validator),
  description ?? `${validator[descriptionSymbol]} array`
);

// packages/ag-charts-community/src/module/coreModulesTypes.ts
function paletteType(partial) {
  if (partial?.up || partial?.down || partial?.neutral) {
    return "user-full";
  } else if (partial?.fills || partial?.strokes) {
    return "user-indexed";
  }
  return "inbuilt";
}

// packages/ag-charts-community/src/chart/themes/chartTheme.ts
var DEFAULT_BACKGROUND_FILL = "white";
var CHART_TYPE_CONFIG = {
  get cartesian() {
    return { seriesTypes: chartTypes.cartesianTypes, commonOptions: ["zoom", "navigator"] };
  },
  get polar() {
    return { seriesTypes: chartTypes.polarTypes, commonOptions: [] };
  },
  get hierarchy() {
    return { seriesTypes: chartTypes.hierarchyTypes, commonOptions: [] };
  },
  get topology() {
    return { seriesTypes: chartTypes.topologyTypes, commonOptions: [] };
  },
  get "flow-proportion"() {
    return { seriesTypes: chartTypes.flowProportionTypes, commonOptions: [] };
  },
  get standalone() {
    return { seriesTypes: chartTypes.standaloneTypes, commonOptions: [] };
  },
  get gauge() {
    return { seriesTypes: chartTypes.gaugeTypes, commonOptions: [] };
  }
};
var PRESET_OVERRIDES_TYPES = {
  "radial-gauge": true,
  "linear-gauge": true
};
function isPresetOverridesType(type) {
  return PRESET_OVERRIDES_TYPES[type] === true;
}
var CHART_TYPE_SPECIFIC_COMMON_OPTIONS = Object.values(CHART_TYPE_CONFIG).reduce((r, { commonOptions }) => r.concat(commonOptions), []);
var _ChartTheme = class _ChartTheme {
  static getAxisDefaults(overrideDefaults) {
    return mergeDefaults(overrideDefaults, {
      title: {
        enabled: false,
        text: "Axis Title",
        spacing: 25,
        fontWeight: "normal" /* NORMAL */,
        fontSize: 13 /* MEDIUM */,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_LABEL_COLOUR
      },
      label: {
        fontSize: 12 /* SMALL */,
        fontFamily: DEFAULT_FONT_FAMILY,
        padding: 5,
        color: DEFAULT_LABEL_COLOUR,
        avoidCollisions: true
      },
      line: {
        enabled: true,
        width: 1,
        stroke: DEFAULT_AXIS_LINE_COLOUR
      },
      tick: {
        enabled: false,
        width: 1,
        stroke: DEFAULT_AXIS_LINE_COLOUR
      },
      gridLine: {
        enabled: true,
        style: [{ stroke: DEFAULT_AXIS_GRID_COLOUR, lineDash: [] }]
      },
      crossLines: {
        enabled: false,
        fill: DEFAULT_CROSS_LINES_COLOUR,
        stroke: DEFAULT_CROSS_LINES_COLOUR,
        fillOpacity: 0.1,
        strokeWidth: 1,
        label: {
          enabled: false,
          fontSize: 12 /* SMALL */,
          fontFamily: DEFAULT_FONT_FAMILY,
          padding: 5,
          color: DEFAULT_LABEL_COLOUR
        }
      },
      crosshair: {
        enabled: true
      }
    });
  }
  getChartDefaults() {
    return {
      minHeight: 300,
      minWidth: 300,
      background: { visible: true, fill: DEFAULT_BACKGROUND_COLOUR },
      padding: { top: DEFAULT_PADDING, right: DEFAULT_PADDING, bottom: DEFAULT_PADDING, left: DEFAULT_PADDING },
      keyboard: { enabled: true },
      title: {
        enabled: false,
        text: "Title",
        fontWeight: "normal" /* NORMAL */,
        fontSize: 17 /* LARGE */,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_LABEL_COLOUR,
        wrapping: "hyphenate",
        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,
        textAlign: DEFAULT_CAPTION_ALIGNMENT
      },
      subtitle: {
        enabled: false,
        text: "Subtitle",
        spacing: 20,
        fontSize: 13 /* MEDIUM */,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_MUTED_LABEL_COLOUR,
        wrapping: "hyphenate",
        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,
        textAlign: DEFAULT_CAPTION_ALIGNMENT
      },
      footnote: {
        enabled: false,
        text: "Footnote",
        spacing: 20,
        fontSize: 13 /* MEDIUM */,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: "rgb(140, 140, 140)",
        wrapping: "hyphenate",
        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,
        textAlign: DEFAULT_CAPTION_ALIGNMENT
      },
      legend: {
        position: "bottom" /* BOTTOM */,
        spacing: 30,
        listeners: {},
        toggleSeries: true,
        item: {
          paddingX: 16,
          paddingY: 8,
          marker: { size: 15, padding: 8 },
          showSeriesStroke: true,
          label: {
            color: DEFAULT_LABEL_COLOUR,
            fontSize: 12 /* SMALL */,
            fontFamily: DEFAULT_FONT_FAMILY
          }
        },
        reverseOrder: false,
        pagination: {
          marker: { size: 12 },
          activeStyle: { fill: DEFAULT_LABEL_COLOUR },
          inactiveStyle: { fill: DEFAULT_MUTED_LABEL_COLOUR },
          highlightStyle: { fill: DEFAULT_LABEL_COLOUR },
          label: { color: DEFAULT_LABEL_COLOUR }
        }
      },
      tooltip: {
        enabled: true,
        darkTheme: IS_DARK_THEME,
        delay: 0
      },
      overlays: { darkTheme: IS_DARK_THEME },
      listeners: {}
    };
  }
  constructor(options = {}) {
    const { overrides, palette } = deepClone(options);
    const defaults = this.createChartConfigPerChartType(this.getDefaults());
    const presets = {};
    if (overrides) {
      this.mergeOverrides(defaults, presets, overrides);
    }
    const { fills, strokes, ...otherColors } = this.getDefaultColors();
    this.palette = mergeDefaults(palette, {
      fills: Object.values(fills),
      strokes: Object.values(strokes),
      ...otherColors
    });
    this.paletteType = paletteType(palette);
    this.config = Object.freeze(this.templateTheme(defaults));
    this.presets = presets;
  }
  mergeOverrides(defaults, presets, overrides) {
    for (const { seriesTypes, commonOptions } of Object.values(CHART_TYPE_CONFIG)) {
      const cleanedCommon = { ...overrides.common };
      for (const commonKey of CHART_TYPE_SPECIFIC_COMMON_OPTIONS) {
        if (!commonOptions.includes(commonKey)) {
          delete cleanedCommon[commonKey];
        }
      }
      if (!cleanedCommon)
        continue;
      for (const s of seriesTypes) {
        const seriesType2 = s;
        if (!isPresetOverridesType(seriesType2)) {
          defaults[seriesType2] = mergeDefaults(cleanedCommon, defaults[seriesType2]);
        }
      }
    }
    chartTypes.seriesTypes.forEach((s) => {
      const seriesType2 = s;
      const seriesOverrides = overrides[seriesType2];
      if (isPresetOverridesType(seriesType2)) {
        presets[seriesType2] = seriesOverrides;
      } else {
        defaults[seriesType2] = mergeDefaults(seriesOverrides, defaults[seriesType2]);
      }
    });
  }
  createChartConfigPerChartType(config) {
    for (const [nextType, { seriesTypes }] of Object.entries(CHART_TYPE_CONFIG)) {
      const typeDefaults = chartDefaults.get(nextType);
      for (const seriesType2 of seriesTypes) {
        config[seriesType2] || (config[seriesType2] = deepClone(typeDefaults));
      }
    }
    return config;
  }
  getDefaults() {
    const getOverridesByType = (chartType2, seriesTypes) => {
      const result = {};
      const chartTypeDefaults = {
        axes: {},
        ...legendRegistry.getThemeTemplates(),
        ...this.getChartDefaults(),
        ...chartDefaults.get(chartType2)
      };
      for (const seriesType2 of seriesTypes) {
        result[seriesType2] = mergeDefaults(
          seriesRegistry.getThemeTemplate(seriesType2),
          result[seriesType2] ?? deepClone(chartTypeDefaults)
        );
        const { axes } = result[seriesType2];
        for (const axisType of axisRegistry.keys()) {
          axes[axisType] = mergeDefaults(
            axes[axisType],
            axisRegistry.getThemeTemplate(axisType),
            _ChartTheme.cartesianAxisDefault[axisType]
          );
        }
      }
      return result;
    };
    return mergeDefaults(
      getOverridesByType("cartesian", chartTypes.cartesianTypes),
      getOverridesByType("polar", chartTypes.polarTypes),
      getOverridesByType("hierarchy", chartTypes.hierarchyTypes),
      getOverridesByType("topology", chartTypes.topologyTypes),
      getOverridesByType("flow-proportion", chartTypes.flowProportionTypes),
      getOverridesByType("standalone", chartTypes.standaloneTypes),
      getOverridesByType("gauge", chartTypes.gaugeTypes)
    );
  }
  templateTheme(themeTemplate) {
    const themeInstance = deepClone(themeTemplate);
    const params = this.getTemplateParameters();
    jsonWalk(themeInstance, (node) => {
      if (isArray(node)) {
        for (let i = 0; i < node.length; i++) {
          const symbol = node[i];
          if (params.has(symbol)) {
            node[i] = params.get(symbol);
          }
        }
      } else {
        for (const [name, value] of Object.entries(node)) {
          if (params.has(value)) {
            node[name] = params.get(value);
          }
        }
      }
    });
    return deepClone(themeInstance);
  }
  getDefaultColors() {
    return {
      fills: DEFAULT_FILLS,
      strokes: DEFAULT_STROKES,
      up: { fill: DEFAULT_FILLS.GREEN, stroke: DEFAULT_STROKES.GREEN },
      down: { fill: DEFAULT_FILLS.RED, stroke: DEFAULT_STROKES.RED },
      neutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY },
      altUp: { fill: DEFAULT_FILLS.BLUE, stroke: DEFAULT_STROKES.BLUE },
      altDown: { fill: DEFAULT_FILLS.ORANGE, stroke: DEFAULT_STROKES.ORANGE },
      altNeutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const { isEnterprise } = enterpriseModule;
    const params = /* @__PURE__ */ new Map();
    params.set(IS_DARK_THEME, false);
    params.set(IS_ENTERPRISE, isEnterprise);
    params.set(IS_COMMUNITY, !isEnterprise);
    params.set(DEFAULT_FONT_FAMILY, "Verdana, sans-serif");
    params.set(DEFAULT_LABEL_COLOUR, "rgb(70, 70, 70)");
    params.set(DEFAULT_INVERTED_LABEL_COLOUR, "white");
    params.set(DEFAULT_MUTED_LABEL_COLOUR, "rgb(140, 140, 140)");
    params.set(DEFAULT_AXIS_GRID_COLOUR, "rgb(224,234,241)");
    params.set(DEFAULT_AXIS_LINE_COLOUR, "rgb(195, 195, 195)");
    params.set(DEFAULT_CROSS_LINES_COLOUR, "rgb(70, 70, 70)");
    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_BACKGROUND_FILL);
    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_BACKGROUND_FILL);
    params.set(DEFAULT_SHADOW_COLOUR, "rgba(0, 0, 0, 0.5)");
    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [
      DEFAULT_FILLS.ORANGE,
      DEFAULT_FILLS.YELLOW,
      DEFAULT_FILLS.GREEN
    ]);
    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [DEFAULT_FILLS.GREEN, DEFAULT_FILLS.YELLOW, DEFAULT_FILLS.RED]);
    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [
      "#5090dc",
      "#629be0",
      "#73a6e3",
      "#85b1e7",
      "#96bcea",
      "#a8c8ee",
      "#b9d3f1",
      "#cbdef5"
    ]);
    params.set(DEFAULT_PADDING, 20);
    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, "block");
    params.set(DEFAULT_CAPTION_ALIGNMENT, "center");
    params.set(DEFAULT_HIERARCHY_FILLS, ["#ffffff", "#e0e5ea", "#c1ccd5", "#a3b4c1", "#859cad"]);
    params.set(DEFAULT_HIERARCHY_STROKES, ["#ffffff", "#c5cbd1", "#a4b1bd", "#8498a9", "#648096"]);
    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);
    params.set(DEFAULT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);
    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_BACKGROUND_FILL);
    params.set(DEFAULT_ANNOTATION_STATISTICS_FILL, "#fafafa");
    params.set(DEFAULT_ANNOTATION_STATISTICS_STROKE, "#dddddd");
    params.set(DEFAULT_ANNOTATION_STATISTICS_COLOR, "#000000");
    params.set(DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE, "#181d1f");
    params.set(DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL, "#e35c5c");
    params.set(DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE, "#e35c5c");
    params.set(DEFAULT_TEXTBOX_FILL, "#fafafa");
    params.set(DEFAULT_TEXTBOX_STROKE, "#dddddd");
    params.set(DEFAULT_TEXTBOX_COLOR, "#000000");
    params.set(DEFAULT_TOOLBAR_POSITION, "top");
    params.set(DEFAULT_GRIDLINE_ENABLED, false);
    const defaultColors = this.getDefaultColors();
    params.set(PALETTE_UP_STROKE, this.palette.up?.stroke ?? defaultColors.up.stroke);
    params.set(PALETTE_UP_FILL, this.palette.up?.fill ?? defaultColors.up.fill);
    params.set(PALETTE_DOWN_STROKE, this.palette.down?.stroke ?? defaultColors.down.stroke);
    params.set(PALETTE_DOWN_FILL, this.palette.down?.fill ?? defaultColors.down.fill);
    params.set(PALETTE_NEUTRAL_STROKE, this.palette.neutral?.stroke ?? defaultColors.neutral.stroke);
    params.set(PALETTE_NEUTRAL_FILL, this.palette.neutral?.fill ?? defaultColors.neutral.fill);
    params.set(PALETTE_ALT_UP_STROKE, this.palette.altUp?.stroke ?? defaultColors.up.stroke);
    params.set(PALETTE_ALT_UP_FILL, this.palette.altUp?.fill ?? defaultColors.up.fill);
    params.set(PALETTE_ALT_DOWN_STROKE, this.palette.altDown?.stroke ?? defaultColors.down.stroke);
    params.set(PALETTE_ALT_DOWN_FILL, this.palette.altDown?.fill ?? defaultColors.down.fill);
    params.set(PALETTE_ALT_NEUTRAL_FILL, this.palette.altNeutral?.fill ?? defaultColors.altNeutral.fill);
    params.set(PALETTE_ALT_NEUTRAL_STROKE, this.palette.altNeutral?.stroke ?? defaultColors.altNeutral.stroke);
    return params;
  }
};
_ChartTheme.cartesianAxisDefault = {
  ["number" /* NUMBER */]: _ChartTheme.getAxisDefaults({
    line: { enabled: false }
  }),
  ["log" /* LOG */]: _ChartTheme.getAxisDefaults({
    base: 10,
    line: { enabled: false },
    interval: { minSpacing: NaN }
  }),
  ["category" /* CATEGORY */]: _ChartTheme.getAxisDefaults({
    groupPaddingInner: 0.1,
    label: { autoRotate: true },
    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED },
    crosshair: { enabled: false }
  }),
  ["time" /* TIME */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),
  ["ordinal-time" /* ORDINAL_TIME */]: _ChartTheme.getAxisDefaults({
    groupPaddingInner: 0,
    label: { autoRotate: false },
    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }
  }),
  ["angle-category" /* ANGLE_CATEGORY */]: _ChartTheme.getAxisDefaults({
    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }
  }),
  ["angle-number" /* ANGLE_NUMBER */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),
  ["radius-category" /* RADIUS_CATEGORY */]: _ChartTheme.getAxisDefaults({
    line: { enabled: false }
  }),
  ["radius-number" /* RADIUS_NUMBER */]: _ChartTheme.getAxisDefaults({
    line: { enabled: false }
  }),
  "grouped-category": _ChartTheme.getAxisDefaults({
    tick: { enabled: true }
  })
};
var ChartTheme = _ChartTheme;

// packages/ag-charts-community/src/chart/themes/darkTheme.ts
var DEFAULT_DARK_BACKGROUND_FILL = "#192232";
var DEFAULT_DARK_FILLS = {
  BLUE: "#5090dc",
  ORANGE: "#ffa03a",
  GREEN: "#459d55",
  CYAN: "#34bfe1",
  YELLOW: "#e1cc00",
  VIOLET: "#9669cb",
  GRAY: "#b5b5b5",
  MAGENTA: "#bd5aa7",
  BROWN: "#8a6224",
  RED: "#ef5452"
};
var DEFAULT_DARK_STROKES = {
  BLUE: "#74a8e6",
  ORANGE: "#ffbe70",
  GREEN: "#6cb176",
  CYAN: "#75d4ef",
  YELLOW: "#f6e559",
  VIOLET: "#aa86d8",
  GRAY: "#a1a1a1",
  MAGENTA: "#ce7ab9",
  BROWN: "#997b52",
  RED: "#ff7872"
};
var DarkTheme = class extends ChartTheme {
  getDefaultColors() {
    return {
      fills: DEFAULT_DARK_FILLS,
      strokes: DEFAULT_DARK_STROKES,
      up: { fill: DEFAULT_DARK_FILLS.GREEN, stroke: DEFAULT_DARK_STROKES.GREEN },
      down: { fill: DEFAULT_DARK_FILLS.RED, stroke: DEFAULT_DARK_STROKES.RED },
      neutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY },
      altUp: { fill: DEFAULT_DARK_FILLS.BLUE, stroke: DEFAULT_DARK_STROKES.BLUE },
      altDown: { fill: DEFAULT_DARK_FILLS.ORANGE, stroke: DEFAULT_DARK_STROKES.ORANGE },
      altNeutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(IS_DARK_THEME, true);
    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);
    params.set(DEFAULT_LABEL_COLOUR, "white");
    params.set(DEFAULT_MUTED_LABEL_COLOUR, "#7D91A0");
    params.set(DEFAULT_AXIS_GRID_COLOUR, "#545A6E");
    params.set(DEFAULT_CROSS_LINES_COLOUR, "white");
    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [
      DEFAULT_DARK_FILLS.ORANGE,
      DEFAULT_DARK_FILLS.YELLOW,
      DEFAULT_DARK_FILLS.GREEN
    ]);
    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [
      DEFAULT_DARK_FILLS.GREEN,
      DEFAULT_DARK_FILLS.YELLOW,
      DEFAULT_DARK_FILLS.RED
    ]);
    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [
      "#5090dc",
      "#4882c6",
      "#4073b0",
      "#38659a",
      "#305684",
      "#28486e",
      "#203a58",
      "#182b42"
    ]);
    params.set(DEFAULT_HIERARCHY_FILLS, ["#192834", "#253746", "#324859", "#3f596c", "#4d6a80"]);
    params.set(DEFAULT_HIERARCHY_STROKES, ["#192834", "#3b5164", "#496275", "#577287", "#668399"]);
    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);
    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);
    params.set(DEFAULT_ANNOTATION_COLOR, DEFAULT_DARK_FILLS.BLUE);
    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, "white");
    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_DARK_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_DARK_BACKGROUND_FILL);
    params.set(DEFAULT_ANNOTATION_STATISTICS_FILL, "#28313e");
    params.set(DEFAULT_ANNOTATION_STATISTICS_STROKE, "#4b525d");
    params.set(DEFAULT_ANNOTATION_STATISTICS_COLOR, "#ffffff");
    params.set(DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE, "#ffffff");
    params.set(DEFAULT_TEXTBOX_FILL, "#28313e");
    params.set(DEFAULT_TEXTBOX_STROKE, "#4b525d");
    params.set(DEFAULT_TEXTBOX_COLOR, "#ffffff");
    return params;
  }
  constructor(options) {
    super(options);
  }
};

// packages/ag-charts-community/src/chart/themes/financialDark.ts
var FINANCIAL_DARK_FILLS = {
  GREEN: "#089981",
  RED: "#F23645",
  BLUE: "#5090dc",
  GRAY: "#A9A9A9"
};
var FINANCIAL_DARK_STROKES = {
  GREEN: "#089981",
  RED: "#F23645",
  BLUE: "#5090dc",
  GRAY: "#909090"
};
var FinancialDark = class extends DarkTheme {
  getDefaultColors() {
    return {
      fills: { ...FINANCIAL_DARK_FILLS },
      strokes: { ...FINANCIAL_DARK_STROKES },
      up: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },
      down: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },
      neutral: { fill: FINANCIAL_DARK_FILLS.BLUE, stroke: FINANCIAL_DARK_STROKES.BLUE },
      altUp: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },
      altDown: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },
      altNeutral: { fill: FINANCIAL_DARK_FILLS.GRAY, stroke: FINANCIAL_DARK_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [
      FINANCIAL_DARK_FILLS.GREEN,
      FINANCIAL_DARK_FILLS.BLUE,
      FINANCIAL_DARK_FILLS.RED
    ]);
    params.set(DEFAULT_ANNOTATION_COLOR, FINANCIAL_DARK_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_DARK_FILLS.BLUE);
    params.set(DEFAULT_AXIS_GRID_COLOUR, "#343A4E");
    params.set(DEFAULT_PADDING, 0);
    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, "overlay");
    params.set(DEFAULT_CAPTION_ALIGNMENT, "left");
    params.set(DEFAULT_TOOLBAR_POSITION, "bottom");
    params.set(DEFAULT_GRIDLINE_ENABLED, true);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/financialLight.ts
var FINANCIAL_LIGHT_FILLS = {
  GREEN: "#089981",
  RED: "#F23645",
  BLUE: "#5090dc",
  GRAY: "#A9A9A9"
};
var FINANCIAL_LIGHT_STROKES = {
  GREEN: "#089981",
  RED: "#F23645",
  BLUE: "#5090dc",
  GRAY: "#909090"
};
var FinancialLight = class extends ChartTheme {
  getDefaultColors() {
    return {
      fills: { ...FINANCIAL_LIGHT_FILLS },
      strokes: { ...FINANCIAL_LIGHT_STROKES },
      up: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },
      down: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },
      neutral: { fill: FINANCIAL_LIGHT_FILLS.BLUE, stroke: FINANCIAL_LIGHT_STROKES.BLUE },
      altUp: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },
      altDown: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },
      altNeutral: { fill: FINANCIAL_LIGHT_FILLS.GRAY, stroke: FINANCIAL_LIGHT_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [
      FINANCIAL_LIGHT_FILLS.GREEN,
      FINANCIAL_LIGHT_FILLS.BLUE,
      FINANCIAL_LIGHT_FILLS.RED
    ]);
    params.set(DEFAULT_ANNOTATION_COLOR, FINANCIAL_LIGHT_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_LIGHT_FILLS.BLUE);
    params.set(DEFAULT_AXIS_GRID_COLOUR, "#F2F3F3");
    params.set(DEFAULT_PADDING, 0);
    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, "overlay");
    params.set(DEFAULT_CAPTION_ALIGNMENT, "left");
    params.set(DEFAULT_TOOLBAR_POSITION, "bottom");
    params.set(DEFAULT_GRIDLINE_ENABLED, true);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/materialDark.ts
var MATERIAL_DARK_FILLS = {
  BLUE: "#2196F3",
  ORANGE: "#FF9800",
  GREEN: "#4CAF50",
  CYAN: "#00BCD4",
  YELLOW: "#FFEB3B",
  VIOLET: "#7E57C2",
  GRAY: "#9E9E9E",
  MAGENTA: "#F06292",
  BROWN: "#795548",
  RED: "#F44336"
};
var MATERIAL_DARK_STROKES = {
  BLUE: "#90CAF9",
  ORANGE: "#FFCC80",
  GREEN: "#A5D6A7",
  CYAN: "#80DEEA",
  YELLOW: "#FFF9C4",
  VIOLET: "#B39DDB",
  GRAY: "#E0E0E0",
  MAGENTA: "#F48FB1",
  BROWN: "#A1887F",
  RED: "#EF9A9A"
};
var MaterialDark = class extends DarkTheme {
  getDefaultColors() {
    return {
      fills: MATERIAL_DARK_FILLS,
      strokes: MATERIAL_DARK_STROKES,
      up: { fill: MATERIAL_DARK_FILLS.GREEN, stroke: MATERIAL_DARK_STROKES.GREEN },
      down: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },
      neutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY },
      altUp: { fill: MATERIAL_DARK_FILLS.BLUE, stroke: MATERIAL_DARK_STROKES.BLUE },
      altDown: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },
      altNeutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [
      MATERIAL_DARK_FILLS.ORANGE,
      MATERIAL_DARK_FILLS.YELLOW,
      MATERIAL_DARK_FILLS.GREEN
    ]);
    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [
      "#2196f3",
      // 500
      "#208FEC",
      // (interpolated)
      "#1E88E5",
      // 600
      "#1C7FDC",
      // (interpolated)
      "#1976d2",
      // 700
      "#176EC9",
      // (interpolated)
      "#1565c0"
      // 800
    ]);
    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [
      MATERIAL_DARK_FILLS.GREEN,
      MATERIAL_DARK_FILLS.YELLOW,
      MATERIAL_DARK_FILLS.RED
    ]);
    params.set(DEFAULT_ANNOTATION_COLOR, MATERIAL_DARK_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_DARK_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/materialLight.ts
var MATERIAL_LIGHT_FILLS = {
  BLUE: "#2196F3",
  ORANGE: "#FF9800",
  GREEN: "#4CAF50",
  CYAN: "#00BCD4",
  YELLOW: "#FFEB3B",
  VIOLET: "#7E57C2",
  GRAY: "#9E9E9E",
  MAGENTA: "#F06292",
  BROWN: "#795548",
  RED: "#F44336"
};
var MATERIAL_LIGHT_STROKES = {
  BLUE: "#1565C0",
  ORANGE: "#E65100",
  GREEN: "#2E7D32",
  CYAN: "#00838F",
  YELLOW: "#F9A825",
  VIOLET: "#4527A0",
  GRAY: "#616161",
  MAGENTA: "#C2185B",
  BROWN: "#4E342E",
  RED: "#B71C1C"
};
var MaterialLight = class extends ChartTheme {
  getDefaultColors() {
    return {
      fills: MATERIAL_LIGHT_FILLS,
      strokes: MATERIAL_LIGHT_STROKES,
      up: { fill: MATERIAL_LIGHT_FILLS.GREEN, stroke: MATERIAL_LIGHT_STROKES.GREEN },
      down: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },
      neutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY },
      altUp: { fill: MATERIAL_LIGHT_FILLS.BLUE, stroke: MATERIAL_LIGHT_STROKES.BLUE },
      altDown: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },
      altNeutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [
      MATERIAL_LIGHT_FILLS.ORANGE,
      MATERIAL_LIGHT_FILLS.YELLOW,
      MATERIAL_LIGHT_FILLS.GREEN
    ]);
    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [
      "#2196f3",
      // 500
      "#329EF4",
      // (interpolated)
      "#42a5f5",
      // 400
      "#53ADF6",
      // (interpolated)
      "#64b5f6",
      // 300
      "#7AC0F8",
      // (interpolated)
      "#90caf9"
      // 200
    ]);
    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [
      MATERIAL_LIGHT_FILLS.GREEN,
      MATERIAL_LIGHT_FILLS.YELLOW,
      MATERIAL_LIGHT_FILLS.RED
    ]);
    params.set(DEFAULT_ANNOTATION_COLOR, MATERIAL_LIGHT_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_LIGHT_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/polychromaDark.ts
var POLYCHROMA_DARK_FILLS = {
  BLUE: "#436ff4",
  PURPLE: "#9a7bff",
  MAGENTA: "#d165d2",
  PINK: "#f0598b",
  RED: "#f47348",
  ORANGE: "#f2a602",
  YELLOW: "#e9e201",
  GREEN: "#21b448",
  CYAN: "#00b9a2",
  MODERATE_BLUE: "#00aee4",
  GRAY: "#bbbbbb"
};
var POLYCHROMA_DARK_STROKES = {
  BLUE: "#6698ff",
  PURPLE: "#c0a3ff",
  MAGENTA: "#fc8dfc",
  PINK: "#ff82b1",
  RED: "#ff9b70",
  ORANGE: "#ffcf4e",
  YELLOW: "#ffff58",
  GREEN: "#58dd70",
  CYAN: "#51e2c9",
  MODERATE_BLUE: "#4fd7ff",
  GRAY: "#eeeeee"
};
var PolychromaDark = class extends DarkTheme {
  getDefaultColors() {
    return {
      fills: POLYCHROMA_DARK_FILLS,
      strokes: POLYCHROMA_DARK_STROKES,
      up: { fill: POLYCHROMA_DARK_FILLS.GREEN, stroke: POLYCHROMA_DARK_STROKES.GREEN },
      down: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },
      neutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY },
      altUp: { fill: POLYCHROMA_DARK_FILLS.BLUE, stroke: POLYCHROMA_DARK_STROKES.BLUE },
      altDown: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },
      altNeutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED]);
    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [
      POLYCHROMA_DARK_FILLS.BLUE,
      POLYCHROMA_DARK_FILLS.PURPLE,
      POLYCHROMA_DARK_FILLS.MAGENTA,
      POLYCHROMA_DARK_FILLS.PINK,
      POLYCHROMA_DARK_FILLS.RED,
      POLYCHROMA_DARK_FILLS.ORANGE,
      POLYCHROMA_DARK_FILLS.YELLOW,
      POLYCHROMA_DARK_FILLS.GREEN
    ]);
    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED]);
    params.set(DEFAULT_ANNOTATION_COLOR, POLYCHROMA_DARK_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_DARK_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/polychromaLight.ts
var POLYCHROMA_LIGHT_FILLS = {
  BLUE: "#436ff4",
  PURPLE: "#9a7bff",
  MAGENTA: "#d165d2",
  PINK: "#f0598b",
  RED: "#f47348",
  ORANGE: "#f2a602",
  YELLOW: "#e9e201",
  GREEN: "#21b448",
  CYAN: "#00b9a2",
  MODERATE_BLUE: "#00aee4",
  GRAY: "#bbbbbb"
};
var POLYCHROMA_LIGHT_STROKES = {
  BLUE: "#2346c9",
  PURPLE: "#7653d4",
  MAGENTA: "#a73da9",
  PINK: "#c32d66",
  RED: "#c84b1c",
  ORANGE: "#c87f00",
  YELLOW: "#c1b900",
  GREEN: "#008c1c",
  CYAN: "#00927c",
  MODERATE_BLUE: "#0087bb",
  GRAY: "#888888"
};
var PolychromaLight = class extends ChartTheme {
  getDefaultColors() {
    return {
      fills: POLYCHROMA_LIGHT_FILLS,
      strokes: POLYCHROMA_LIGHT_STROKES,
      up: { fill: POLYCHROMA_LIGHT_FILLS.GREEN, stroke: POLYCHROMA_LIGHT_STROKES.GREEN },
      down: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },
      neutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY },
      altUp: { fill: POLYCHROMA_LIGHT_FILLS.BLUE, stroke: POLYCHROMA_LIGHT_STROKES.BLUE },
      altDown: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },
      altNeutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED]);
    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [
      POLYCHROMA_LIGHT_FILLS.BLUE,
      POLYCHROMA_LIGHT_FILLS.PURPLE,
      POLYCHROMA_LIGHT_FILLS.MAGENTA,
      POLYCHROMA_LIGHT_FILLS.PINK,
      POLYCHROMA_LIGHT_FILLS.RED,
      POLYCHROMA_LIGHT_FILLS.ORANGE,
      POLYCHROMA_LIGHT_FILLS.YELLOW,
      POLYCHROMA_LIGHT_FILLS.GREEN
    ]);
    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED]);
    params.set(DEFAULT_ANNOTATION_COLOR, POLYCHROMA_LIGHT_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_LIGHT_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/sheetsDark.ts
var SHEETS_DARK_FILLS = {
  BLUE: "#4472C4",
  ORANGE: "#ED7D31",
  GRAY: "#A5A5A5",
  YELLOW: "#FFC000",
  MODERATE_BLUE: "#5B9BD5",
  GREEN: "#70AD47",
  DARK_GRAY: "#7B7B7B",
  DARK_BLUE: "#264478",
  VERY_DARK_GRAY: "#636363",
  DARK_YELLOW: "#997300"
};
var SHEETS_DARK_STROKES = {
  BLUE: "#6899ee",
  ORANGE: "#ffa55d",
  GRAY: "#cdcdcd",
  YELLOW: "#ffea53",
  MODERATE_BLUE: "#82c3ff",
  GREEN: "#96d56f",
  DARK_GRAY: "#a1a1a1",
  DARK_BLUE: "#47689f",
  VERY_DARK_GRAY: "#878787",
  DARK_YELLOW: "#c0993d"
};
var SheetsDark = class extends DarkTheme {
  getDefaultColors() {
    return {
      fills: { ...SHEETS_DARK_FILLS, RED: SHEETS_DARK_FILLS.ORANGE },
      strokes: { ...SHEETS_DARK_STROKES, RED: SHEETS_DARK_STROKES.ORANGE },
      up: { fill: SHEETS_DARK_FILLS.GREEN, stroke: SHEETS_DARK_STROKES.GREEN },
      down: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },
      neutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY },
      altUp: { fill: SHEETS_DARK_FILLS.BLUE, stroke: SHEETS_DARK_STROKES.BLUE },
      altDown: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },
      altNeutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [
      SHEETS_DARK_FILLS.ORANGE,
      SHEETS_DARK_FILLS.YELLOW,
      SHEETS_DARK_FILLS.GREEN
    ]);
    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [
      SHEETS_DARK_FILLS.GREEN,
      SHEETS_DARK_FILLS.YELLOW,
      SHEETS_DARK_FILLS.ORANGE
    ]);
    params.set(DEFAULT_ANNOTATION_COLOR, SHEETS_DARK_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_DARK_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/sheetsLight.ts
var SHEETS_LIGHT_FILLS = {
  BLUE: "#5281d5",
  ORANGE: "#ff8d44",
  GRAY: "#b5b5b5",
  YELLOW: "#ffd02f",
  MODERATE_BLUE: "#6aabe6",
  GREEN: "#7fbd57",
  DARK_GRAY: "#8a8a8a",
  DARK_BLUE: "#335287",
  VERY_DARK_GRAY: "#717171",
  DARK_YELLOW: "#a98220"
};
var SHEETS_LIGHT_STROKES = {
  BLUE: "#214d9b",
  ORANGE: "#c25600",
  GRAY: "#7f7f7f",
  YELLOW: "#d59800",
  MODERATE_BLUE: "#3575ac",
  GREEN: "#4b861a",
  DARK_GRAY: "#575757",
  DARK_BLUE: "#062253",
  VERY_DARK_GRAY: "#414141",
  DARK_YELLOW: "#734f00"
};
var SheetsLight = class extends ChartTheme {
  getDefaultColors() {
    return {
      fills: { ...SHEETS_LIGHT_FILLS, RED: SHEETS_LIGHT_FILLS.ORANGE },
      strokes: { ...SHEETS_LIGHT_STROKES, RED: SHEETS_LIGHT_STROKES.ORANGE },
      up: { fill: SHEETS_LIGHT_FILLS.GREEN, stroke: SHEETS_LIGHT_STROKES.GREEN },
      down: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },
      neutral: { fill: SHEETS_LIGHT_STROKES.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY },
      altUp: { fill: SHEETS_LIGHT_FILLS.BLUE, stroke: SHEETS_LIGHT_STROKES.BLUE },
      altDown: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },
      altNeutral: { fill: SHEETS_LIGHT_FILLS.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [
      SHEETS_LIGHT_FILLS.ORANGE,
      SHEETS_LIGHT_FILLS.YELLOW,
      SHEETS_LIGHT_FILLS.GREEN
    ]);
    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [
      SHEETS_LIGHT_FILLS.GREEN,
      SHEETS_LIGHT_FILLS.YELLOW,
      SHEETS_LIGHT_FILLS.ORANGE
    ]);
    params.set(DEFAULT_ANNOTATION_COLOR, SHEETS_LIGHT_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_LIGHT_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/vividDark.ts
var VIVID_DARK_FILLS = {
  BLUE: "#0083ff",
  ORANGE: "#ff6600",
  GREEN: "#00af00",
  CYAN: "#00ccff",
  YELLOW: "#f7c700",
  VIOLET: "#ac26ff",
  GRAY: "#a7a7b7",
  MAGENTA: "#e800c5",
  BROWN: "#b54300",
  RED: "#ff0000"
};
var VIVID_DARK_STROKES = {
  BLUE: "#67b7ff",
  ORANGE: "#ffc24d",
  GREEN: "#5cc86f",
  CYAN: "#54ebff",
  VIOLET: "#fff653",
  YELLOW: "#c18aff",
  GRAY: "#aeaeae",
  MAGENTA: "#f078d4",
  BROWN: "#ba8438",
  RED: "#ff726e"
};
var VividDark = class extends DarkTheme {
  getDefaultColors() {
    return {
      fills: VIVID_DARK_FILLS,
      strokes: VIVID_DARK_STROKES,
      up: { fill: VIVID_DARK_FILLS.GREEN, stroke: VIVID_DARK_STROKES.GREEN },
      down: { fill: VIVID_DARK_FILLS.RED, stroke: VIVID_DARK_STROKES.RED },
      neutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY },
      altUp: { fill: VIVID_DARK_FILLS.BLUE, stroke: VIVID_DARK_STROKES.BLUE },
      altDown: { fill: VIVID_DARK_FILLS.ORANGE, stroke: VIVID_DARK_STROKES.ORANGE },
      altNeutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [
      VIVID_DARK_FILLS.ORANGE,
      VIVID_DARK_FILLS.YELLOW,
      VIVID_DARK_FILLS.GREEN
    ]);
    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [
      "#0083ff",
      "#0076e6",
      "#0069cc",
      "#005cb3",
      "#004f99",
      "#004280",
      "#003466",
      "#00274c"
    ]);
    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [
      VIVID_DARK_FILLS.GREEN,
      VIVID_DARK_FILLS.YELLOW,
      VIVID_DARK_FILLS.RED
    ]);
    params.set(DEFAULT_ANNOTATION_COLOR, VIVID_DARK_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_DARK_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/themes/vividLight.ts
var VIVID_FILLS = {
  BLUE: "#0083ff",
  ORANGE: "#ff6600",
  GREEN: "#00af00",
  CYAN: "#00ccff",
  YELLOW: "#f7c700",
  VIOLET: "#ac26ff",
  GRAY: "#a7a7b7",
  MAGENTA: "#e800c5",
  BROWN: "#b54300",
  RED: "#ff0000"
};
var VIVID_STROKES = {
  BLUE: "#0f68c0",
  ORANGE: "#d47100",
  GREEN: "#007922",
  CYAN: "#009ac2",
  VIOLET: "#bca400",
  YELLOW: "#753cac",
  GRAY: "#646464",
  MAGENTA: "#9b2685",
  BROWN: "#6c3b00",
  RED: "#cb0021"
};
var VividLight = class extends ChartTheme {
  getDefaultColors() {
    return {
      fills: VIVID_FILLS,
      strokes: VIVID_STROKES,
      up: { fill: VIVID_FILLS.GREEN, stroke: VIVID_STROKES.GREEN },
      down: { fill: VIVID_FILLS.RED, stroke: VIVID_STROKES.RED },
      neutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY },
      altUp: { fill: VIVID_FILLS.BLUE, stroke: VIVID_STROKES.BLUE },
      altDown: { fill: VIVID_FILLS.ORANGE, stroke: VIVID_STROKES.ORANGE },
      altNeutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY }
    };
  }
  getTemplateParameters() {
    const params = super.getTemplateParameters();
    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [VIVID_FILLS.ORANGE, VIVID_FILLS.YELLOW, VIVID_FILLS.GREEN]);
    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [
      "#0083ff",
      "#1a8fff",
      "#339cff",
      "#4da8ff",
      "#66b5ff",
      "#80c1ff",
      "#99cdff",
      "#b3daff"
    ]);
    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [VIVID_FILLS.GREEN, VIVID_FILLS.YELLOW, VIVID_FILLS.RED]);
    params.set(DEFAULT_ANNOTATION_COLOR, VIVID_FILLS.BLUE);
    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_FILLS.BLUE);
    return params;
  }
};

// packages/ag-charts-community/src/chart/mapping/themes.ts
var lightTheme = () => new ChartTheme();
var darkTheme = () => new DarkTheme();
var themes = {
  // darkThemes,
  "ag-default-dark": darkTheme,
  "ag-sheets-dark": () => new SheetsDark(),
  "ag-polychroma-dark": () => new PolychromaDark(),
  "ag-vivid-dark": () => new VividDark(),
  "ag-material-dark": () => new MaterialDark(),
  "ag-financial-dark": () => new FinancialDark(),
  // lightThemes,
  null: lightTheme,
  undefined: lightTheme,
  "ag-default": lightTheme,
  "ag-sheets": () => new SheetsLight(),
  "ag-polychroma": () => new PolychromaLight(),
  "ag-vivid": () => new VividLight(),
  "ag-material": () => new MaterialLight(),
  "ag-financial": () => new FinancialLight()
};
function getChartTheme(value) {
  if (value instanceof ChartTheme) {
    return value;
  }
  if (value == null || typeof value === "string") {
    const stockTheme = themes[value];
    if (stockTheme) {
      return stockTheme();
    }
    Logger.warnOnce(`the theme [${value}] is invalid, using [ag-default] instead.`);
    return lightTheme();
  }
  if (isValid(value, themeOptionsDef, "theme")) {
    const flattenedTheme = reduceThemeOptions(value);
    const baseTheme = flattenedTheme.baseTheme ? getChartTheme(flattenedTheme.baseTheme) : lightTheme();
    return new baseTheme.constructor(flattenedTheme);
  }
  return lightTheme();
}
function reduceThemeOptions(options) {
  let maybeNested = options;
  let palette;
  const overrides = [];
  while (typeof maybeNested === "object") {
    palette ?? (palette = maybeNested.palette);
    if (maybeNested.overrides) {
      overrides.push(maybeNested.overrides);
    }
    maybeNested = maybeNested.baseTheme;
  }
  return {
    baseTheme: maybeNested,
    overrides: mergeDefaults(...overrides),
    palette
  };
}
var themeOptionsDef = {
  baseTheme: or(string, object),
  overrides: object,
  palette: {
    fills: arrayOf(string),
    strokes: arrayOf(string),
    up: { fill: string, stroke: string },
    down: { fill: string, stroke: string },
    neutral: { fill: string, stroke: string }
  }
};

// packages/ag-charts-community/src/module/optionsModule.ts
var unthemedSeries = /* @__PURE__ */ new Set(["map-shape-background", "map-line-background"]);
var ChartOptions = class {
  constructor(userOptions, processedOverrides, specialOverrides, metadata) {
    this.debug = Debug.create(true, "opts");
    var _a;
    this.optionMetadata = metadata ?? {};
    this.processedOverrides = processedOverrides ?? {};
    const cloneOptions = { shallow: ["data"] };
    this.userOptions = deepClone(userOptions, cloneOptions);
    let options = deepClone(userOptions, cloneOptions);
    const { presetType } = this.optionMetadata;
    if (presetType != null) {
      const presetConstructor = PRESETS[presetType];
      const presetParams = options;
      const presetSubType = options.type;
      const presetTheme = presetSubType != null ? getChartTheme(options.theme).presets[presetSubType] : void 0;
      this.debug(">>> AgCharts.createOrUpdate() - applying preset", presetParams);
      options = presetConstructor?.(presetParams, presetTheme, () => this.activeTheme) ?? options;
    }
    if (!enterpriseModule.isEnterprise) {
      removeUsedEnterpriseOptions(options);
    }
    this.activeTheme = getChartTheme(options.theme);
    if (presetType) {
      options = this.activeTheme.templateTheme(options);
    }
    this.sanityCheckAndCleanup(options);
    this.defaultAxes = this.getDefaultAxes(options);
    this.specialOverrides = this.specialOverridesDefaults({ ...specialOverrides });
    const chartType2 = this.optionsType(options);
    const {
      axes: axesThemes = {},
      annotations: { axesButtons = null, ...annotationsThemes } = {},
      series: _,
      ...themeDefaults
    } = this.getSeriesThemeConfig(chartType2);
    this.processedOptions = deepClone(
      mergeDefaults(
        processedOverrides,
        options,
        axesButtons != null ? { annotations: { axesButtons } } : {},
        themeDefaults,
        this.defaultAxes
      ),
      cloneOptions
    );
    this.processAxesOptions(this.processedOptions, axesThemes);
    this.processSeriesOptions(this.processedOptions);
    this.processMiniChartSeriesOptions(this.processedOptions);
    this.annotationThemes = annotationsThemes;
    if ((isAgCartesianChartOptions(this.processedOptions) || isAgPolarChartOptionsWithSeriesBasedLegend(this.processedOptions)) && this.processedOptions.legend?.enabled == null) {
      (_a = this.processedOptions).legend ?? (_a.legend = {});
      this.processedOptions.legend.enabled = this.processedOptions.series.length > 1;
    }
    this.enableConfiguredOptions(this.processedOptions, options);
    if (!enterpriseModule.isEnterprise) {
      removeUsedEnterpriseOptions(this.processedOptions, true);
    }
  }
  getOptions() {
    return this.processedOptions ?? {};
  }
  diffOptions(options) {
    return jsonDiff(options, this.processedOptions);
  }
  getSeriesThemeConfig(seriesType2) {
    const themeConfig = deepClone(this.activeTheme?.config[seriesType2] ?? {});
    this.removeLeftoverSymbols(themeConfig);
    return themeConfig;
  }
  getDefaultAxes(options) {
    const optionsType2 = this.optionsType(options);
    const firstSeriesOptions = options.series?.find((series) => (series.type ?? "line") === optionsType2) ?? {};
    return seriesRegistry.cloneDefaultAxes(optionsType2, firstSeriesOptions);
  }
  optionsType(options) {
    return options.series?.[0]?.type ?? "line";
  }
  sanityCheckAndCleanup(options) {
    this.deprecationWarnings(options);
    this.axesTypeIntegrity(options);
    this.seriesTypeIntegrity(options);
    this.soloSeriesIntegrity(options);
    this.removeDisabledOptions(options);
    this.removeLeftoverSymbols(options);
    if (options.series?.some((s) => s.type === "bullet") && options.sync != null && options.sync.enabled !== false) {
      Logger.warnOnce("bullet series cannot be synced, disabling synchronization.");
      delete options.sync;
    }
  }
  processAxesOptions(options, axesThemes) {
    if (!("axes" in options))
      return;
    options.axes = options.axes.map((axis) => {
      const { crossLines: crossLinesTheme, ...axisTheme } = mergeDefaults(
        axesThemes[axis.type]?.[axis.position],
        axesThemes[axis.type]
      );
      if (axis.crossLines) {
        axis.crossLines = mergeArrayDefaults(axis.crossLines, crossLinesTheme);
      }
      const gridLineStyle = axisTheme.gridLine?.style;
      if (axis.gridLine?.style && gridLineStyle?.length) {
        axis.gridLine.style = axis.gridLine.style.map(
          (style, index) => style.stroke != null || style.lineDash != null ? mergeDefaults(style, gridLineStyle.at(index % gridLineStyle.length)) : style
        );
      }
      const { top: _1, right: _2, bottom: _3, left: _4, ...axisOptions } = mergeDefaults(axis, axisTheme);
      return axisOptions;
    });
  }
  processSeriesOptions(options) {
    const defaultTooltipPosition = this.getTooltipPositionDefaults(options);
    const userPalette = isObject(options.theme) ? paletteType(options.theme?.palette) : "inbuilt";
    const paletteOptions = {
      colourIndex: 0,
      userPalette
    };
    const processedSeries = options.series?.map((series) => {
      series.type ?? (series.type = this.getDefaultSeriesType(options));
      const { innerLabels: innerLabelsTheme, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};
      const seriesPaletteOptions = unthemedSeries.has(series.type) ? { colourIndex: 0, userPalette } : paletteOptions;
      const palette = this.getSeriesPalette(series.type, seriesPaletteOptions);
      const defaultTooltipRange = this.getTooltipRangeDefaults(options, series.type);
      const seriesOptions = mergeDefaults(
        this.getSeriesGroupingOptions(series),
        series,
        defaultTooltipPosition,
        defaultTooltipRange,
        seriesTheme,
        palette,
        { visible: true }
      );
      if (seriesOptions.innerLabels) {
        seriesOptions.innerLabels = mergeArrayDefaults(seriesOptions.innerLabels, innerLabelsTheme);
      }
      return this.activeTheme.templateTheme(seriesOptions);
    });
    options.series = this.setSeriesGroupingOptions(processedSeries ?? []);
  }
  processMiniChartSeriesOptions(options) {
    let miniChartSeries = options.navigator?.miniChart?.series;
    if (miniChartSeries == null)
      return;
    const paletteOptions = {
      colourIndex: 0,
      userPalette: isObject(options.theme) ? paletteType(options.theme.palette) : "inbuilt"
    };
    miniChartSeries = miniChartSeries.map((series) => {
      series.type ?? (series.type = "line");
      const { innerLabels: _, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};
      const seriesOptions = mergeDefaults(
        this.getSeriesGroupingOptions(series),
        series,
        seriesTheme,
        this.getSeriesPalette(series.type, paletteOptions)
      );
      return this.activeTheme.templateTheme(seriesOptions);
    });
    options.navigator.miniChart.series = this.setSeriesGroupingOptions(miniChartSeries);
  }
  getSeriesPalette(seriesType2, options) {
    const paletteFactory = seriesRegistry.getPaletteFactory(seriesType2);
    const { colourIndex: colourOffset, userPalette } = options;
    const { fills = [], strokes = [] } = this.activeTheme.palette;
    return paletteFactory?.({
      userPalette,
      colorsCount: Math.max(fills.length, strokes.length),
      themeTemplateParameters: this.activeTheme.getTemplateParameters(),
      palette: this.activeTheme.palette,
      takeColors(count) {
        options.colourIndex += count;
        return {
          fills: circularSliceArray(fills, count, colourOffset),
          strokes: circularSliceArray(strokes, count, colourOffset)
        };
      }
    });
  }
  getSeriesGroupingOptions(series) {
    const groupable = seriesRegistry.isGroupable(series.type);
    const stackable = seriesRegistry.isStackable(series.type);
    const stackedByDefault = seriesRegistry.isStackedByDefault(series.type);
    if (series.grouped && !groupable) {
      Logger.warnOnce(`unsupported grouping of series type "${series.type}".`);
    }
    if ((series.stacked || series.stackGroup) && !stackable) {
      Logger.warnOnce(`unsupported stacking of series type "${series.type}".`);
    }
    let { grouped, stacked } = series;
    stacked ?? (stacked = (stackedByDefault || series.stackGroup != null) && !(groupable && grouped));
    grouped ?? (grouped = true);
    return {
      stacked: stackable && stacked,
      grouped: groupable && grouped && !(stackable && stacked)
    };
  }
  setSeriesGroupingOptions(allSeries) {
    const seriesGroups = this.getSeriesGrouping(allSeries);
    this.debug("setSeriesGroupingOptions() - series grouping: ", seriesGroups);
    const groupIdx = {};
    const groupCount2 = seriesGroups.reduce((countMap, seriesGroup) => {
      var _a;
      if (seriesGroup.groupType === "default" /* DEFAULT */) {
        return countMap;
      }
      countMap[_a = seriesGroup.seriesType] ?? (countMap[_a] = 0);
      countMap[seriesGroup.seriesType] += seriesGroup.groupType === "stack" /* STACK */ ? 1 : seriesGroup.series.length;
      return countMap;
    }, {});
    return seriesGroups.flatMap((seriesGroup) => {
      var _a;
      groupIdx[_a = seriesGroup.seriesType] ?? (groupIdx[_a] = 0);
      switch (seriesGroup.groupType) {
        case "stack" /* STACK */: {
          const groupIndex = groupIdx[seriesGroup.seriesType]++;
          return seriesGroup.series.map(
            (series, stackIndex) => Object.assign(series, {
              seriesGrouping: {
                groupId: seriesGroup.groupId,
                groupIndex,
                groupCount: groupCount2[seriesGroup.seriesType],
                stackIndex,
                stackCount: seriesGroup.series.length
              }
            })
          );
        }
        case "group" /* GROUP */:
          return seriesGroup.series.map(
            (series) => Object.assign(series, {
              seriesGrouping: {
                groupId: seriesGroup.groupId,
                groupIndex: groupIdx[seriesGroup.seriesType]++,
                groupCount: groupCount2[seriesGroup.seriesType],
                stackIndex: 0,
                stackCount: 0
              }
            })
          );
      }
      return seriesGroup.series;
    }).map(({ stacked: _, grouped: __, ...seriesOptions }) => seriesOptions);
  }
  getSeriesGroupId(series) {
    return [series.type, series.xKey, series.stacked ? series.stackGroup ?? "stacked" : "grouped"].filter(Boolean).join("-");
  }
  getSeriesGrouping(allSeries) {
    const groupMap = /* @__PURE__ */ new Map();
    return allSeries.reduce((result, series) => {
      const seriesType2 = series.type;
      if (!series.stacked && !series.grouped) {
        result.push({ groupType: "default" /* DEFAULT */, seriesType: seriesType2, series: [series], groupId: "__default__" });
      } else {
        const groupId = this.getSeriesGroupId(series);
        if (!groupMap.has(groupId)) {
          const groupType = series.stacked ? "stack" /* STACK */ : "group" /* GROUP */;
          const record = { groupType, seriesType: seriesType2, series: [], groupId };
          groupMap.set(groupId, record);
          result.push(record);
        }
        groupMap.get(groupId).series.push(series);
      }
      return result;
    }, []);
  }
  getDefaultSeriesType(options) {
    if (isAgCartesianChartOptions(options)) {
      return "line";
    } else if (isAgPolarChartOptions(options)) {
      return "pie";
    } else if (isAgHierarchyChartOptions(options)) {
      return "treemap";
    } else if (isAgTopologyChartOptions(options)) {
      return "map-shape";
    } else if (isAgFlowProportionChartOptions(options)) {
      return "sankey";
    } else if (isAgStandaloneChartOptions(options)) {
      return "pyramid";
    } else if (isAgGaugeChartOptions(options)) {
      return "radial-gauge";
    }
    throw new Error("Invalid chart options type detected.");
  }
  getTooltipPositionDefaults(options) {
    const position = options.tooltip?.position;
    if (!isPlainObject(position)) {
      return;
    }
    const { type, xOffset, yOffset } = position;
    const result = {};
    if (isString(type) && isEnumValue(AgTooltipPositionType, type)) {
      result.type = type;
    }
    if (isFiniteNumber(xOffset)) {
      result.xOffset = xOffset;
    }
    if (isFiniteNumber(yOffset)) {
      result.yOffset = yOffset;
    }
    return { tooltip: { position: result } };
  }
  // AG-11591 Support for new series-specific & legacy chart-global 'tooltip.range' options
  //
  // The `chart.series[].tooltip.range` option is a bit different for legacy reason. This use to be
  // global option (`chart.tooltip.range`) that could override the theme. But now, the tooltip range
  // option is series-specific.
  //
  // To preserve backward compatiblity, the `chart.tooltip.range` theme default has been changed from
  // 'nearest' to undefined.
  getTooltipRangeDefaults(options, seriesType2) {
    return {
      tooltip: {
        range: options.tooltip?.range ?? seriesRegistry.getTooltipDefauls(seriesType2)?.range
      }
    };
  }
  deprecationWarnings(options) {
    const deprecatedArrayProps = { yKeys: "yKey", yNames: "yName" };
    Object.entries(deprecatedArrayProps).forEach(([oldProp, newProp]) => {
      if (options.series?.some((s) => s[oldProp] != null)) {
        Logger.warnOnce(
          `Property [series.${oldProp}] is deprecated, please use [series.${newProp}] and multiple series instead.`
        );
      }
    });
  }
  axesTypeIntegrity(options) {
    if ("axes" in options) {
      const axes = options.axes ?? [];
      for (const { type } of axes) {
        if (!isAxisOptionType(type)) {
          delete options.axes;
          const expectedTypes = axisRegistry.publicKeys().join(", ");
          Logger.warnOnce(`unknown axis type: ${type}; expected one of: ${expectedTypes}`);
        }
      }
    }
  }
  seriesTypeIntegrity(options) {
    options.series = options.series?.filter(({ type }) => {
      if (type == null || isSeriesOptionType(type) || isEnterpriseSeriesType(type)) {
        return true;
      }
      Logger.warnOnce(
        `unknown series type: ${type}; expected one of: ${publicChartTypes.seriesTypes.join(", ")}`
      );
    });
  }
  soloSeriesIntegrity(options) {
    const allSeries = options.series;
    if (allSeries && allSeries.length > 1 && allSeries.some((series) => seriesRegistry.isSolo(series.type))) {
      const mainSeriesType = this.optionsType(options);
      if (seriesRegistry.isSolo(mainSeriesType)) {
        Logger.warn(
          `series[0] of type '${mainSeriesType}' is incompatible with other series types. Only processing series[0]`
        );
        options.series = allSeries.slice(0, 1);
      } else {
        const { solo, nonSolo } = groupBy(
          allSeries,
          (s) => seriesRegistry.isSolo(s.type) ? "solo" : "nonSolo"
        );
        const rejects = unique(solo.map((s) => s.type)).join(", ");
        Logger.warn(`Unable to mix these series types with the lead series type: ${rejects}`);
        options.series = nonSolo;
      }
    }
  }
  enableConfiguredOptions(options, userOptions) {
    jsonWalk(
      userOptions,
      (visitingUserOpts, visitingMergedOpts) => {
        if (visitingMergedOpts && "enabled" in visitingMergedOpts && !visitingMergedOpts._enabledFromTheme && visitingUserOpts.enabled == null) {
          visitingMergedOpts.enabled = true;
        }
      },
      { skip: ["data", "theme"] },
      options
    );
    jsonWalk(
      options,
      (visitingMergedOpts) => {
        if (visitingMergedOpts._enabledFromTheme != null) {
          delete visitingMergedOpts._enabledFromTheme;
        }
      },
      { skip: ["data", "theme"] }
    );
  }
  removeDisabledOptions(options) {
    jsonWalk(
      options,
      (optionsNode) => {
        if ("enabled" in optionsNode && optionsNode.enabled === false) {
          Object.keys(optionsNode).forEach((key) => {
            if (key === "enabled")
              return;
            delete optionsNode[key];
          });
        }
      },
      { skip: ["data", "theme"] }
    );
  }
  removeLeftoverSymbols(options) {
    jsonWalk(
      options,
      (optionsNode) => {
        if (!optionsNode || !isObject(optionsNode))
          return;
        for (const [key, value] of Object.entries(optionsNode)) {
          if (isSymbol(value)) {
            delete optionsNode[key];
          }
        }
      },
      { skip: ["data"] }
    );
  }
  specialOverridesDefaults(options) {
    if (options.window != null) {
      setWindow(options.window);
    } else if (typeof window !== "undefined") {
      options.window = window;
    } else if (typeof global !== "undefined") {
      options.window = global.window;
    }
    if (options.document != null) {
      setDocument(options.document);
    } else if (typeof document !== "undefined") {
      options.document = document;
    } else if (typeof global !== "undefined") {
      options.document = global.document;
    }
    if (options.window == null) {
      throw new Error("AG Charts - unable to resolve global window");
    }
    if (options.document == null) {
      throw new Error("AG Charts - unable to resolve global document");
    }
    return options;
  }
};

// packages/ag-charts-community/src/api/agCharts.ts
var debug2 = Debug.create(true, "opts");
function chartType(options) {
  if (isAgCartesianChartOptions(options)) {
    return "cartesian";
  } else if (isAgPolarChartOptions(options)) {
    return "polar";
  } else if (isAgHierarchyChartOptions(options)) {
    return "hierarchy";
  } else if (isAgTopologyChartOptions(options)) {
    return "topology";
  } else if (isAgFlowProportionChartOptions(options)) {
    return "flow-proportion";
  } else if (isAgStandaloneChartOptions(options)) {
    return "standalone";
  } else if (isAgGaugeChartOptions(options)) {
    return "gauge";
  }
  throw new Error(`AG Chart - unknown type of chart for options with type: ${options.type}`);
}
var AgCharts = class {
  static licenseCheck(options) {
    if (this.licenseChecked)
      return;
    this.licenseManager = enterpriseModule.licenseManager?.(options);
    this.licenseManager?.setLicenseKey(this.licenseKey, this.gridContext);
    this.licenseManager?.validateLicense();
    this.licenseChecked = true;
  }
  static setLicenseKey(licenseKey) {
    this.licenseKey = licenseKey;
  }
  static setGridContext(gridContext) {
    this.gridContext = gridContext;
  }
  static getLicenseDetails(licenseKey) {
    return enterpriseModule.licenseManager?.({}).getLicenseDetails(licenseKey);
  }
  /**
   * Returns the `AgChartInstance` for a DOM node, if there is one.
   */
  static getInstance(element2) {
    return AgChartsInternal.getInstance(element2);
  }
  /**
   * Create a new `AgChartInstance` based upon the given configuration options.
   */
  static create(userOptions, optionsMetadata) {
    this.licenseCheck(userOptions);
    const chart = AgChartsInternal.createOrUpdate({
      userOptions,
      licenseManager: this.licenseManager,
      styles: enterpriseModule.styles != null ? [["ag-charts-enterprise", enterpriseModule.styles]] : [],
      optionsMetadata
    });
    if (this.licenseManager?.isDisplayWatermark() && this.licenseManager) {
      enterpriseModule.injectWatermark?.(chart.chart.ctx.domManager, this.licenseManager.getWatermarkMessage());
    }
    return chart;
  }
  static createFinancialChart(options) {
    return this.create(options, { presetType: "price-volume" });
  }
  static createGauge(options) {
    return this.create(options, { presetType: "gauge" });
  }
  static __createSparkline(options) {
    return this.create(options, { presetType: "sparkline" });
  }
};
AgCharts.licenseChecked = false;
AgCharts.gridContext = false;
var _AgChartsInternal = class _AgChartsInternal {
  static getInstance(element2) {
    const chart = Chart.getInstance(element2);
    return chart ? AgChartInstanceProxy.chartInstances.get(chart) : void 0;
  }
  static initialiseModules() {
    if (_AgChartsInternal.initialised)
      return;
    registerInbuiltModules();
    setupModules();
    _AgChartsInternal.initialised = true;
  }
  static createOrUpdate(opts) {
    let { proxy } = opts;
    const {
      userOptions,
      licenseManager,
      styles,
      processedOverrides = proxy?.chart.chartOptions.processedOverrides ?? {},
      specialOverrides = proxy?.chart.chartOptions.specialOverrides ?? {},
      optionsMetadata = proxy?.chart.chartOptions.optionMetadata ?? {}
    } = opts;
    const { presetType } = optionsMetadata;
    _AgChartsInternal.initialiseModules();
    debug2(">>> AgCharts.createOrUpdate() user options", userOptions);
    let mutableOptions = userOptions;
    if (AgCharts.optionsMutationFn) {
      mutableOptions = AgCharts.optionsMutationFn(mutableOptions, presetType);
      debug2(">>> AgCharts.createOrUpdate() MUTATED user options", mutableOptions);
    }
    const { overrideDevicePixelRatio, document: document2, window: userWindow, styleContainer, ...options } = mutableOptions;
    const chartOptions = new ChartOptions(
      options,
      processedOverrides,
      {
        ...specialOverrides,
        document: document2,
        window: userWindow,
        overrideDevicePixelRatio,
        styleContainer
      },
      optionsMetadata
    );
    let chart = proxy?.chart;
    if (chart == null || chartType(chartOptions.processedOptions) !== chartType(chart?.chartOptions.processedOptions)) {
      chart = _AgChartsInternal.createChartInstance(chartOptions, chart);
      styles?.forEach(([id, css]) => {
        chart?.ctx.domManager.addStyles(id, css);
      });
    }
    if (proxy == null) {
      proxy = new AgChartInstanceProxy(chart, _AgChartsInternal.callbackApi, licenseManager);
    } else {
      proxy.chart = chart;
    }
    if (debug2.check() && typeof window !== "undefined") {
      window.agChartInstances ?? (window.agChartInstances = {});
      window.agChartInstances[chart.id] = chart;
    }
    chart.queuedUserOptions.push(userOptions);
    chart.requestFactoryUpdate((chartRef) => {
      chartRef.applyOptions(chartOptions);
      const queueIdx = chartRef.queuedUserOptions.indexOf(userOptions) + 1;
      chartRef.queuedUserOptions.splice(0, queueIdx);
    });
    return proxy;
  }
  static updateUserDelta(proxy, deltaOptions) {
    deltaOptions = deepClone(deltaOptions, { shallow: ["data"] });
    jsonWalk(
      deltaOptions,
      (node) => {
        if (typeof node !== "object")
          return;
        for (const [key, value] of Object.entries(node)) {
          if (typeof value === "undefined") {
            Object.assign(node, { [key]: Symbol("UNSET") });
          }
        }
      },
      { skip: ["data"] }
    );
    const { chart } = proxy;
    const lastUpdateOptions = chart.getOptions();
    const userOptions = mergeDefaults(deltaOptions, lastUpdateOptions);
    debug2(">>> AgCharts.updateUserDelta() user delta", deltaOptions);
    debug2("AgCharts.updateUserDelta() - base options", lastUpdateOptions);
    _AgChartsInternal.createOrUpdate({ userOptions, proxy });
  }
  static createChartInstance(options, oldChart) {
    const transferableResource = oldChart?.destroy({ keepTransferableResources: true });
    const ChartConstructor = _AgChartsInternal.getChartByOptions(options.processedOptions);
    return new ChartConstructor(options, transferableResource);
  }
  static getChartByOptions(options) {
    if (isAgCartesianChartOptions(options)) {
      return CartesianChart;
    } else if (isAgHierarchyChartOptions(options)) {
      return HierarchyChart;
    } else if (isAgPolarChartOptions(options)) {
      return PolarChart;
    } else if (isAgTopologyChartOptions(options)) {
      return TopologyChart;
    } else if (isAgFlowProportionChartOptions(options)) {
      return FlowProportionChart;
    } else if (isAgStandaloneChartOptions(options)) {
      return StandaloneChart;
    } else if (isAgGaugeChartOptions(options)) {
      return GaugeChart;
    }
    throw new Error(
      `AG Charts - couldn't apply configuration, check options are correctly structured and series types are specified`
    );
  }
};
_AgChartsInternal.caretaker = new MementoCaretaker(VERSION);
_AgChartsInternal.initialised = false;
_AgChartsInternal.callbackApi = {
  caretaker: _AgChartsInternal.caretaker,
  create(userOptions, processedOverrides, specialOverrides, optionsMetadata) {
    return _AgChartsInternal.createOrUpdate({
      userOptions,
      processedOverrides,
      specialOverrides,
      optionsMetadata
    });
  },
  update(opts, chart) {
    return _AgChartsInternal.createOrUpdate({ userOptions: opts, proxy: chart });
  },
  updateUserDelta(chart, deltaOptions) {
    return _AgChartsInternal.updateUserDelta(chart, deltaOptions);
  }
};
var AgChartsInternal = _AgChartsInternal;

// packages/ag-charts-community/src/main-modules.ts
function setupCommunityModules() {
  registerInbuiltModules();
  return { AgCharts, version: VERSION };
}
