type StateDefinition<State extends string, Event extends string> = {
    [key in Event]?: Destination<State>;
};
type Destination<State extends string> = Array<StateTransition<State>> | StateTransition<State> | StateTransitionAction | State | HierarchyState | StateMachine<any, any>;
type StateUtils<State extends string> = {
    onEnter?: (from?: State, data?: any) => void;
    onExit?: () => void;
};
type StateTransition<State> = {
    /**
     * Return `false` to prevent the action and transition. The FSM will pick the first transition that passes its
     * guard or does not have one.
     */
    guard?: (data?: any) => boolean;
    target?: State | HierarchyState | StateMachine<any, any>;
    action?: StateTransitionAction;
};
type StateTransitionAction = (data?: any) => void;
type HierarchyState = '__parent' | '__child';
/**
 * A Hierarchical Finite State Machine is a system that must be in exactly one of a list of states, where those states
 * can also be other state machines. It can only transition between one state and another if a transition event is
 * provided between the two states.
 */
export declare class StateMachine<State extends string, Event extends string> {
    private readonly defaultState;
    private readonly states;
    private readonly enterEach?;
    static readonly child: "__child";
    static readonly parent: "__parent";
    protected readonly debug: import("./debug").DebugLogger;
    private state;
    private childState?;
    constructor(defaultState: State, states: Record<State, StateDefinition<State, Event> & StateUtils<State>>, enterEach?: ((from: State | HierarchyState, to: State | HierarchyState) => void) | undefined);
    transition(event: Event, data?: any): void;
    transitionAsync(event: Event, data?: any): void;
    protected is(value: unknown): boolean;
    protected resetHierarchy(): void;
    private transitionChild;
    private getDestinationState;
}
export {};
